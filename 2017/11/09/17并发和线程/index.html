<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="个人博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://luoqian67.github.io/blog">
    <!--SEO-->





<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>python-并发和线程 | 个人博客</title>


    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/blog/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/blog/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/blog/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Luo Qian">
            <img src="/blog/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/blog/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://luoqian67.github.io/blog">个人博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/Linux/"><i class="fa "></i>Linux</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/python/"><i class="fa "></i>python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/杂项教程/"><i class="fa "></i>杂项</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="python-并发和线程">
            
	            python-并发和线程
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/python" title="python">
                        python
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/11/09</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>并行、parallel</p>
<p>​    同时做某些事情，可以互不干扰的同一时刻做几件事</p>
<p>并发、concurrency</p>
<p>​    一个时段内有事情要处理。</p>
<hr>
<h3 id="并发的解决"><a href="#并发的解决" class="headerlink" title="并发的解决"></a>并发的解决</h3><h5 id="1、队列、缓冲区"><a href="#1、队列、缓冲区" class="headerlink" title="1、队列、缓冲区"></a>1、队列、缓冲区</h5><p>使用队列，先进先出，解决了资源使用的问题。排成的<strong>队列</strong>，其实就是一个缓冲地带，就是<strong>缓冲区</strong>。（队列的作用：解耦，缓冲）</p>
<h5 id="2、争抢"><a href="#2、争抢" class="headerlink" title="2、争抢"></a>2、争抢</h5><p>通过争抢，当一个抢到时就会触发一种类似<strong>锁机制</strong>，抢到资源就上锁，排他性的锁。这也是一种高并发解决方案，但是这样就有可能会有些会很长时间都抢不到。</p>
<h5 id="3、预处理"><a href="#3、预处理" class="headerlink" title="3、预处理"></a>3、预处理</h5><p>一种提前加载用户需要的数据的思路，预处理思想，缓存常用。（要考虑到冷、热数据的问题，经常访问的数据可以先预加载）</p>
<h5 id="4、并行"><a href="#4、并行" class="headerlink" title="4、并行"></a>4、并行</h5><p>一般日常可以通过购买服务器，或多开进程、线程实现并行处理，来解决并发问题。注意：这些都是<strong>水平拓展</strong>的思想。</p>
<p>注：<br>如果线程在单CPU上处理，就不是并行了。<br>但是多数服务器都是多CPU的，服务的部署往往是多机的、分布式的，这都是并行处理。</p>
<h5 id="5、提速"><a href="#5、提速" class="headerlink" title="5、提速"></a>5、提速</h5><p>提高单个CPU性能，或单个服务器安装更多的CPU。<br>这是一种<strong>垂直扩展</strong>思想。</p>
<h5 id="6、消息中间件"><a href="#6、消息中间件" class="headerlink" title="6、消息中间件"></a>6、消息中间件</h5><p>一般就是在程序之前实现的技术。</p>
<p>常见的消息中间件有RabbitMQ、ActiveMQ（Apache）、RocketMQ（阿里Apache）、kafka（Apache）等</p>
<p>总结：一般来说不同的并发场景使用不同的策略，而策略可能是多种方式的优化组合。</p>
<hr>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>在实现了线程的操作系统中，<strong>线程</strong>是操作系统能够进行<strong>运算调度</strong>的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个程序的执行实例就是一个进程。<br><strong>进程</strong>（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行<strong>资源分配和调度</strong>的基本单位，是操作系统结构的基础。</p>
<p>进程和程序的关系<br>程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据（资源），它也是线程的容器。</p>
<p>Linux进程有父进程、子进程，Windows的进程是平等关系。</p>
<p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。<br>一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。<br>在许多系统中，创建一个线程比创建一个进程快10-100倍。</p>
<p>进程、线程的理解<br>现代操作系统提出进程的概念，每一个进程都认为自己独占所有的计算机硬件资源。<br>进程就是独立的王国，进程间不可以随便的共享数据。<br>线程就是省份，同一个进程内的线程可以共享进程的资源，每一个线程拥有自己独立的<strong>堆栈</strong>。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>就绪(Ready)</td>
<td>线程能够运行，但在等待被调度。可能线程刚刚创建启动，或刚刚从阻塞中恢复，或者被其他线程抢占</td>
</tr>
<tr>
<td>运行(Running)</td>
<td>线程正在运行</td>
</tr>
<tr>
<td>阻塞(Blocked)</td>
<td>线程等待外部事件发生而无法运行，如I/O操作</td>
</tr>
<tr>
<td>终止(Terminated)</td>
<td>线程完成，或退出，或被取消</td>
</tr>
</tbody>
</table>
<h3 id="Python中的进程和线程"><a href="#Python中的进程和线程" class="headerlink" title="Python中的进程和线程"></a>Python中的进程和线程</h3><hr>
<p>进程会启动一个解释器进程，线程共享一个解释器进程</p>
<h3 id="Python的线程开发"><a href="#Python的线程开发" class="headerlink" title="Python的线程开发"></a>Python的线程开发</h3><hr>
<p>Python的线程开发使用标准库threading</p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#签名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group=None, target=None, name=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 args=<span class="params">()</span>, kwargs=None, *, daemon=None)</span>:</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>线程调用的对象，就是目标函数</td>
</tr>
<tr>
<td>name</td>
<td>为线程起的名字</td>
</tr>
<tr>
<td>args</td>
<td>为目标函数传递实参，元组</td>
</tr>
<tr>
<td>kwargs</td>
<td>为目标函数关键字传参，字典</td>
</tr>
</tbody>
</table>
<h4 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最简单的线程程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'm working"</span>)</span><br><span class="line">    print(<span class="string">'Fineshed'</span>)</span><br><span class="line"> </span><br><span class="line">t = threading.Thread(target=worker, name=<span class="string">'worker'</span>) <span class="comment"># 线程对象</span></span><br><span class="line">t.start() <span class="comment">#  启动</span></span><br></pre></td></tr></table></figure>
<p>通过threading.Thread创建一个线程对象，target是目标函数，name可以指定名称。<br>但是线程没有启动，需要调用start方法。<br>线程之所以执行函数，是因为线程中就是执行代码的，而最简单的封装就是函数，所以其实还是函数调用，当函数执行完，线程就退出，当主线程结束后，程序也就执行完毕。</p>
<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><p>Python没有提供线程退出的方法，线程在下面情况时退出。</p>
<p>1、线程函数内语句执行完毕<br>2、线程函数中抛出未处理的异常</p>
<p>Python的线程没有优先级，没有线程组的概念，也不能被销毁、停止、挂起、那也没有恢复、中断了。</p>
<h4 id="threading的属性和方法"><a href="#threading的属性和方法" class="headerlink" title="threading的属性和方法"></a>threading的属性和方法</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>current_thread()</td>
<td>返回当前线程对象</td>
</tr>
<tr>
<td>main_thread()</td>
<td>返回主线程对象</td>
</tr>
<tr>
<td>active_count()</td>
<td>当前处于alive状态的线程个数</td>
</tr>
<tr>
<td>enumerate()</td>
<td>返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程</td>
</tr>
<tr>
<td>get_ident()</td>
<td>返回当前线程的ID,非0整数</td>
</tr>
</tbody>
</table>
<p>active_count、enumerate方法返回的值还包括主线程。</p>
<h4 id="Thread实例的属性和方法"><a href="#Thread实例的属性和方法" class="headerlink" title="Thread实例的属性和方法"></a>Thread实例的属性和方法</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>只是一个名字，只是一个标识，名称可以重名。getName(),setName()，获取设置这个名词</td>
</tr>
<tr>
<td>ident</td>
<td>线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用</td>
</tr>
<tr>
<td>is_alive()</td>
<td>返回线程是否活着</td>
</tr>
</tbody>
</table>
<p>注意：线程的name这是一个名称，可以重复；ID必须唯一，但可以在线程退出后再利用。</p>
<h4 id="start方法和run方法"><a href="#start方法和run方法" class="headerlink" title="start方法和run方法"></a>start方法和run方法</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>启动线程。每一个线程必须且只能执行该方法一次</td>
</tr>
<tr>
<td>run()</td>
<td>运行线程函数</td>
</tr>
</tbody>
</table>
<p>虽然说，start()方法会调用run()方法，而run()方法可以运行函数。<br>但是在使用start()方法启动线程，是启动了一个新的线程，而使用run方法只是在主线程中调用了一个普通的函数而已，并没有启动新的线程。</p>
<hr>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>一个进程中如果有多个线程，就是多线程，实现一种并发。</p>
<p>当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p>
<p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个主线程。<br>其他线程称为工作线程。</p>
<hr>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全，就是线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。</p>
<p>当在线程中使用print函数的时候，可以让它不打印换行，这样就可以避免print函数线程不安全；还可以使用标准库中的logging模块，日志处理模块，线程安全的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        logging.warning(<span class="string">"&#123;&#125; is running"</span>.format(threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    name = <span class="string">"worker-&#123;&#125;"</span>.format(x)</span><br><span class="line">    t = threading.Thread(target=worker, name=name)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="daemon线程和non-daemon线程"><a href="#daemon线程和non-daemon线程" class="headerlink" title="daemon线程和non-daemon线程"></a>daemon线程和non-daemon线程</h3><p>进程靠线程执行代码，至少有一个主线程，其它线程是工作线程。</p>
<p>主线程是第一个启动的线程。</p>
<p>父线程：如果线程A中启动了一个线程B，A就是B的父线程。</p>
<p>子线程：B就是A的子线程。</p>
<p>python中，构造线程的时候，可以设置daemon属性，这个属性必须在start方法前设置好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码Thread的__init__方法中</span></span><br><span class="line"><span class="keyword">if</span> daemon <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">	self._daemonic = daemon <span class="comment"># 用户设定bool值</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self._daemonic = current_thread().daemon</span><br><span class="line">self._ident = <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>线程daemon属性，如果设定就是用户的设置，否则就取当前线程的daemon值。<br>主线程是non-daemon线程，即daemon = False。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>daemon属性</td>
<td>表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常</td>
</tr>
<tr>
<td>isDaemon()</td>
<td>是否是daemon线程</td>
</tr>
<tr>
<td>setDaemon</td>
<td>设置为daemon线程，必须在start方法之前设置</td>
</tr>
</tbody>
</table>
<p>总结：线程具有daemon属性，可以显示设置为True或False，也可以不设置，则取默认值None<br>如果不设置daemon，就取当前线程的daemon来设置它。</p>
<p>主线程是non-daemon线程，即daemon = False。<br>从主线程创建的所有线程的不设置daemon属性，则默认都是daemon = False，也就是non-daemon线程。</p>
<p>Python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。</p>
<p>如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束，如果还有daemon线程，主线程需要退出，会结束所有daemon线程，退出。</p>
<hr>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>join(timeout=None)，是线程的标准方法之一。<br>一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。<br>一个线程可以被join多次。<br>timeout参数指定调用者等待多久，没有设置超时，就一直等到被调用线程结束。<br>一个线程调用谁的join方法，就是join谁，就要等谁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(i)</span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=foo, args=(<span class="number">10</span>,), daemon=<span class="keyword">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Main Thread Exiting"</span>)</span><br></pre></td></tr></table></figure>
<p>使用了join方法后，daemon线程执行完了，主线程才退出。</p>
<hr>
<h3 id="daemon线程的应用场景"><a href="#daemon线程的应用场景" class="headerlink" title="daemon线程的应用场景"></a>daemon线程的应用场景</h3><p>这个概念唯一的作用就是，当你把一个线程设置为 daemon，它会随主线程的退出而退出。</p>
<p>主要应用场景有：</p>
<p>1、后台任务。如发送心跳包、监控，这种场景最多。</p>
<p>2、主线程工作才有用的线程。如主线程中维护这公共的资源，主线程已经清理了，准备退出，而工作线程使用这些资源工作也没有意义了，一起退出最合适。</p>
<p>3、随时可以被终止的线程</p>
<p>如果主线程退出，想所有其它工作线程一起退出，就使用daemon=True来创建工作线程。</p>
<p>比如，开启一个线程定时判断WEB服务是否正常工作，主线程退出，工作线程也没有必须存在了，应该随着主线程退出一起退出。这种daemon线程一旦创建，就可以忘记它了，只用关心主线程什么时候退出就行了。<br>daemon线程，简化了程序员手动关闭线程的工作。</p>
<p>如果在non-daemon线程A中，对另一个daemon线程B使用了join方法，这个线程B设置成daemon就没有什么意义了，因为non-daemon线程A总是要等待B。</p>
<p>如果在一个daemon线程C中，对另一个daemon线程D使用了join方法，只能说明C要等待D，主线程退出，C和D不管是否结束，也不管它们谁等谁，都要被杀掉。</p>
<hr>
<h3 id="threading-local类"><a href="#threading-local类" class="headerlink" title="threading.local类"></a>threading.local类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 局部变量实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    	time.sleep(<span class="number">0.0001</span>)</span><br><span class="line">   		x += <span class="number">1</span></span><br><span class="line">	print(threading.current_thread(), x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	threading.Thread(target=worker).start()</span><br></pre></td></tr></table></figure>
<p>当想保证线程安全，可以使用局部变量来进行运算，避免错误。</p>
<p>当然如果想使用全局变量，那就可以使用threading下的local类，将这个类实例化得到一个全局变量，但是不同的线程使用这个对象存储的数据，其他线程看不见。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">global_date = threading.local()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    global_date.x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line">        global_date.x += <span class="number">1</span></span><br><span class="line">    print(threading.current_thread(), global_date.x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    threading.Thread(target=worker).start()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#&lt;Thread(Thread-3, started 3648)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-4, started 9404)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-1, started 7472)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-5, started 10876)&gt; 100</span></span><br><span class="line"><span class="comment">#&lt;Thread(Thread-2, started 12424)&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>threading.local类构建了一个大字典，存放所有线程相关的字典，定义如下：<br>{ id(thread) -&gt;  (ref(thread), thread-local dict)  }<br>每一线程实例的id为key，元组为value。value中两部分为线程对象引用，每个线程自己的字典。</p>
<blockquote>
<p>本质<br>运行时，threading.local实例处在不同的线程中，就从大字典中找到当前线程相关键值对中的字典，覆盖threading.local实例的 __dict__ 。<br>这样就可以在不同的线程中，安全地使用线程独有的数据，做到了线程间数据隔离，如同本地变量一样安全</p>
</blockquote>
<h3 id="定时器Timer-延时执行"><a href="#定时器Timer-延时执行" class="headerlink" title="定时器Timer/延时执行"></a>定时器Timer/延时执行</h3><hr>
<p>threading.Timer继承自Thread，这个类用来定义延迟多久后执行一个函数。</p>
<p>class.threading.Timer(interval, function, args=None, kwargs=None)<br>start方法执行之后，Timer对象会处于等待状态，等待了interval秒之后，然后开始执行function函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">"%(asctime)s %(threadName)s %(thread)d  %(message)s"</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, format=FORMAT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    logging.info(<span class="string">"in worker"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Timer(<span class="number">4</span>, worker)</span><br><span class="line">t.setName(<span class="string">"timer"</span>)</span><br><span class="line"></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> len(threading.enumerate()) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#打印</span></span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line"><span class="number">2018</span><span class="number">-10</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">24</span>:<span class="number">44</span>,<span class="number">066</span> timer <span class="number">2768</span>  <span class="keyword">in</span> worker</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">10416</span>)&gt;, &lt;Timer(timer, started <span class="number">2768</span>)&gt;]</span><br></pre></td></tr></table></figure>
<p>Timer提供了cancel方法，用来取消一个未执行的函数，如果上面例子中worker函数已经开始执行，cancel就没有任何效果了。</p>
<p>总结<br>Timer是线程Thread的子类，就是线程类，具有线程的能力和特征。<br>它的实例是能够延时执行目标函数的线程，在真正执行目标函数之前，都可以cancel它。<br>cancel方法本质使用Event类实现。这并不是说，线程提供了取消的方法。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>概念：线程同步，线程间协同，通过某种技术，让一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。</p>
<p>不同操作系统实现技术有所不同，有临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件Event等</p>
<h4 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h4><hr>
<p>Event事件，是线程间通信机制中最简单的实现，使用一个内部的标记flag，通过flag的True或False的变化来进行操作。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>set()</td>
<td>标记设置为True</td>
</tr>
<tr>
<td>clear()</td>
<td>标记设置为False</td>
</tr>
<tr>
<td>is_set()</td>
<td>标记是否为True</td>
</tr>
<tr>
<td>wait(timeout=None)</td>
<td>设置等待标记为True的时长，None为无限等待。等到返回True，未等到超时了返回False</td>
</tr>
</tbody>
</table>
<p>需求：</p>
<p>老板雇佣了一个工人，让他生产杯子，老板一直等着这个工人，直到生产了10个杯子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">"%(asctime)s %(threadName)s %(thread)s %(message)s"</span></span><br><span class="line">logging.basicConfig(format=FORMAT, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boss</span><span class="params">(event: Event)</span>:</span></span><br><span class="line">    logging.info(<span class="string">"I'm boss, waitting for U."</span>)</span><br><span class="line">    event.wait()  <span class="comment">#等待</span></span><br><span class="line">    logging.info(<span class="string">"Good Job."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(event: Event, count=<span class="number">10</span>)</span>:</span></span><br><span class="line">    logging.info(<span class="string">"i'm working for U."</span>)</span><br><span class="line">    cups = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        logging.info(<span class="string">"make 1"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        cups.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(cups) &gt;= count:</span><br><span class="line">            event.set()   <span class="comment">#通知</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    logging.info(<span class="string">"I'm finish my job, cups = &#123;&#125;"</span>.format(cups))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line">t1 = Thread(target=boss, name=<span class="string">"bose"</span>, args=(event,)).start()</span><br><span class="line">t2 = Thread(target=worker, name=<span class="string">"worker"</span>, args=(event,)).start()</span><br></pre></td></tr></table></figure>
<p>总结<br>使用同一个Event对象的标记flag。<br>谁wait就是等到flag变为True，或等到超时返回False。不限制等待的个数。</p>
<p>wait的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(event:Event, interval:int)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.wait(interval): <span class="comment"># 条件中使用，返回True或者False</span></span><br><span class="line">        logging.info(<span class="string">'do sth.'</span>)</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line">Thread(target=do, args=(e, <span class="number">3</span>)).start()</span><br><span class="line"></span><br><span class="line">e.wait(<span class="number">10</span>) <span class="comment"># 也可以使用time.sleep(10)</span></span><br><span class="line">e.set()</span><br><span class="line">print(<span class="string">'main exit'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"></span><br><span class="line">INFO:root:do sth.</span><br><span class="line">INFO:root:do sth.</span><br><span class="line">INFO:root:do sth.</span><br><span class="line">main exit</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Event的wait优于time.sleep，它会更快的切换到其它线程，提高并发效率。</p>
<hr>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>锁，凡是存在共享资源争抢的地方都可以使用锁，从而保证只有一个使用者可以使用这个资源。</p>
<p>锁，一旦线程获得锁，其它试图获取锁的线程将被阻塞</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>acquire(blocking=True,timeout=-1)</td>
<td>默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取锁，返回True，否则返回False</td>
</tr>
<tr>
<td>release()</td>
<td>释放锁。可以从任何线程调用释放。已上锁的锁，会被重置为unlocked,未上锁的锁上调用，抛RuntimeError异常。</td>
</tr>
</tbody>
</table>
<h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h4><hr>
<p>一般来说，加锁就需要解锁，但是加锁后解锁前，还要有一些代码执行，就有可能抛异常，一旦出现异常，锁是无法释放，但是当前线程可能因为这个异常被终止了，这就产生了死锁。</p>
<p>加锁、解锁常用语句：<br>1、使用try…finally语句保证锁的释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:            </span><br><span class="line">    self.lock.acquire()            </span><br><span class="line"><span class="keyword">finally</span>:            </span><br><span class="line">    self.lock.release()</span><br></pre></td></tr></table></figure>
<p>2、with上下文管理，锁对象支持上下文管理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.__lock = threading.Lock() </span><br><span class="line"><span class="keyword">with</span> self.__lock:</span><br><span class="line">     ******</span><br></pre></td></tr></table></figure>
<h4 id="锁的应用场景"><a href="#锁的应用场景" class="headerlink" title="锁的应用场景"></a>锁的应用场景</h4><hr>
<p>锁适用于访问和修改同一个共享资源的时候，即读写同一个资源的时候。</p>
<p>如果全部都是读取同一个共享资源需要锁吗？<br>不需要。因为这时可以认为共享资源是不可变的，每一次读取它都是一样的值，所以不用加锁</p>
<p>使用锁的注意事项：</p>
<ul>
<li>少用锁，必要时用锁。使用了锁，多线程访问被锁的资源时，就成了串行，要么排队执行，要么争抢执行<ul>
<li>举例，高速公路上车并行跑，可是到了省界只开放了一个收费口，过了这个口，车辆依然可以在多车道上一起跑。过收费口的时候，如果排队一辆辆过，加不加锁一样效率相当，但是一旦出现争抢，就必须加锁,一辆辆过。</li>
</ul>
</li>
<li>加锁时间越短越好，不需要就立即释放锁</li>
<li>一定要避免死锁</li>
</ul>
<h4 id="可重入锁RLOCK"><a href="#可重入锁RLOCK" class="headerlink" title="可重入锁RLOCK"></a>可重入锁RLOCK</h4><hr>
<p>可重入锁，是<strong>线程相关</strong>的锁。<br>线程A获得可重复锁，并可以在同一线程中多次成功获取，<strong>不会阻塞</strong>。最后要在线程A中做和acquire次数相同的release。release多了会报错。有个count在计数。属主owner会记录当前是谁在使用锁。</p>
<p>当锁未释放完，其他线程获得锁就会阻塞，直到当前持有锁的线程释放完锁。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><hr>
<p>构造方法Condition(lock=None)，可以传入一个Lock或Rlock对象，默认是Rlock。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>acquire(*args)</td>
<td>获取锁</td>
</tr>
<tr>
<td>wait(self,timeout = None)</td>
<td>等待或超时</td>
</tr>
<tr>
<td>notify（n =1）</td>
<td>唤醒至多指定指定个数的等待的线程，没有等待的线程就没有任何操作</td>
</tr>
<tr>
<td>notify_all()</td>
<td>唤醒所有等待的线程</td>
</tr>
</tbody>
</table>
<p>Condition用于生产者、消费者模型，为了解决生产者消费者速度匹配的问题。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">https://luoqian67.github.io/blog/</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/blog/2017/12/16/18日志分析步骤/" class="pre-post btn btn-default" title="python-日志分析步骤">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">python-日志分析步骤</span>
        </a>
    
    
        <a href="/blog/2017/11/01/16网络编程/" class="next-post btn btn-default" title="网络编程">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">网络编程</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/blog/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xme1rFxnnyLwK8UFBgckpusw-gzGzoHsz',
            appKey: 'u9MbOVN8LcSmPkewWeQKtEnJ',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发和并行的区别"><span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发的解决"><span class="toc-text">并发的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、队列、缓冲区"><span class="toc-text">1、队列、缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、争抢"><span class="toc-text">2、争抢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、预处理"><span class="toc-text">3、预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、并行"><span class="toc-text">4、并行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、提速"><span class="toc-text">5、提速</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6、消息中间件"><span class="toc-text">6、消息中间件</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态"><span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python中的进程和线程"><span class="toc-text">Python中的进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python的线程开发"><span class="toc-text">Python的线程开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread类"><span class="toc-text">Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程启动"><span class="toc-text">线程启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程退出"><span class="toc-text">线程退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threading的属性和方法"><span class="toc-text">threading的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread实例的属性和方法"><span class="toc-text">Thread实例的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start方法和run方法"><span class="toc-text">start方法和run方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#daemon线程和non-daemon线程"><span class="toc-text">daemon线程和non-daemon线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join方法"><span class="toc-text">join方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#daemon线程的应用场景"><span class="toc-text">daemon线程的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threading-local类"><span class="toc-text">threading.local类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器Timer-延时执行"><span class="toc-text">定时器Timer/延时执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Event事件"><span class="toc-text">Event事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock"><span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加锁和解锁"><span class="toc-text">加锁和解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁的应用场景"><span class="toc-text">锁的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可重入锁RLOCK"><span class="toc-text">可重入锁RLOCK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-text">Condition</span></a></li></ol></li></ol></li>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/blog/js/app.js?rev=@@hash"></script>

</body>
</html>