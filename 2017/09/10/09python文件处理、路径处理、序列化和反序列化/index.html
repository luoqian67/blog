<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="个人博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://luoqian67.github.io/blog">
    <!--SEO-->





<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>python-文件处理、路径处理、序列化和反序列化 | 个人博客</title>


    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/blog/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/blog/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/blog/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Luo Qian">
            <img src="/blog/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/blog/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://luoqian67.github.io/blog">个人博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/Linux/"><i class="fa "></i>Linux</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/python/"><i class="fa "></i>python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/杂项教程/"><i class="fa "></i>杂项</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="python-文件处理、路径处理、序列化和反序列化">
            
	            python-文件处理、路径处理、序列化和反序列化
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/python" title="python">
                        python
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/09/10</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h4 id="文件IO常用操作"><a href="#文件IO常用操作" class="headerlink" title="文件IO常用操作"></a>文件IO常用操作</h4><p>一般说IO操作，指的是文件IO。</p>
<p>把文件存储到磁盘上的这个过程，叫做落地。</p>
<table>
<thead>
<tr>
<th style="text-align:center">column</th>
<th style="text-align:center">column</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">open</td>
<td style="text-align:center">打开</td>
</tr>
<tr>
<td style="text-align:center">read</td>
<td style="text-align:center">读取</td>
</tr>
<tr>
<td style="text-align:center">write</td>
<td style="text-align:center">写入</td>
</tr>
<tr>
<td style="text-align:center">close</td>
<td style="text-align:center">关闭</td>
</tr>
<tr>
<td style="text-align:center">readline</td>
<td style="text-align:center">行读取</td>
</tr>
<tr>
<td style="text-align:center">readlines</td>
<td style="text-align:center">多行读取</td>
</tr>
<tr>
<td style="text-align:center">seek</td>
<td style="text-align:center">文件指针操作</td>
</tr>
<tr>
<td style="text-align:center">tell</td>
<td style="text-align:center">指针位置</td>
</tr>
</tbody>
</table>
<h5 id="open打开操作"><a href="#open打开操作" class="headerlink" title="open打开操作"></a>open打开操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>,opener=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"file名字"</span>)   <span class="comment">#文件对象</span></span><br><span class="line">print(f.read())		<span class="comment">#读取文件</span></span><br><span class="line">f.close()		<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure>
<p>打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。<br>基本使用： 创建一个文件test，然后打开它，用完关闭。</p>
<p>文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。</p>
<blockquote>
<p>注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。</p>
</blockquote>
<h5 id="mode模式"><a href="#mode模式" class="headerlink" title="mode模式"></a>mode模式</h5><table>
<thead>
<tr>
<th>描述字符</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>缺省的，表示只读打开</td>
</tr>
<tr>
<td>w</td>
<td>只写打开，有的话就清除重新写</td>
</tr>
<tr>
<td>x</td>
<td>创建并写入一个新文件</td>
</tr>
<tr>
<td>a</td>
<td>写入打开，如果文件存在，则追加</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式</td>
</tr>
<tr>
<td>t</td>
<td>缺省的，文本模式</td>
</tr>
<tr>
<td>+</td>
<td>读写打开一个文件，给原来只读、只写的增加缺失的功能</td>
</tr>
</tbody>
</table>
<p>open默认是只读模式r打开已经存在的文件。</p>
<ul>
<li><p>r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。</p>
</li>
<li><p>w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。</p>
</li>
<li><p>x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。</p>
</li>
<li><p>a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容</p>
</li>
<li><p>r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。</p>
</li>
<li><p>+为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。</p>
</li>
</ul>
<p>t和b：</p>
<ul>
<li><p>文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。</p>
</li>
<li><p>二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。</p>
</li>
</ul>
<p>t/b不能单独存在，要和a/w/x/r配合使用。</p>
<h5 id="seek文件指针"><a href="#seek文件指针" class="headerlink" title="seek文件指针"></a>seek文件指针</h5><p>文件指针，指向当前字节位置。</p>
<p>mode = r，指针起始在0  ，mode  =  a  指针起始在EOF。</p>
<p>tell（）：显示指针当前位置。</p>
<p>seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。</p>
<ul>
<li><p>文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本模式</span></span><br><span class="line">f = open(<span class="string">'test4'</span>,<span class="string">'r+'</span>)</span><br><span class="line">f.tell() <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.tell() <span class="comment"># EOF</span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># offset必须为0</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># offset必须为0</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二进制模式</span></span><br><span class="line">f = open(<span class="string">'test4'</span>,<span class="string">'rb+'</span>)</span><br><span class="line">f.tell() <span class="comment"># 起始</span></span><br><span class="line">f.read()</span><br><span class="line">f.tell() <span class="comment"># EOF</span></span><br><span class="line">f.write(<span class="string">b'abc'</span>)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># 从当前指针开始，向后2</span></span><br><span class="line">f.read()</span><br><span class="line"> </span><br><span class="line">f.seek(<span class="number">-2</span>,<span class="number">2</span>) <span class="comment"># 从EOF开始，向前2</span></span><br><span class="line">f.read()</span><br><span class="line">f.seek(<span class="number">-20</span>,<span class="number">2</span>) <span class="comment"># OSError</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。</p>
</li>
</ul>
<h5 id="buffering缓冲区"><a href="#buffering缓冲区" class="headerlink" title="buffering缓冲区"></a>buffering缓冲区</h5><p>-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是<font color="red">4096或者8192</font>。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。</p>
<ul>
<li>0 只在二进制模式使用，表示关buffer</li>
<li>1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush</li>
<li>大于1 用于指定buffer的大小</li>
</ul>
<p>buffer 缓冲区 </p>
<p>缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。</p>
<p>flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。</p>
<p>io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。</p>
<table>
<thead>
<tr>
<th>buffering</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffering = -1</td>
<td>t和b，都是io.DEFAULT_BUFFER_SIZE</td>
</tr>
<tr>
<td>buffering = 0</td>
<td>b 关闭缓冲区 <br>t 不支持</td>
</tr>
<tr>
<td>buffering = 1</td>
<td>b 就一个字节<br>t 行缓冲，遇到换行符才flush</td>
</tr>
<tr>
<td>buffering &gt; 1</td>
<td>b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。</td>
</tr>
</tbody>
</table>
<p>t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘 |</p>
<p>一般来说：</p>
<ol>
<li>文本模式，一般都用默认缓冲区大小</li>
<li>二进制模式，是一个个字节的操作，可以指定buffer的大小</li>
<li>一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它</li>
<li>一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候</li>
</ol>
<h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h5><p>编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A）</p>
<p>errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略</p>
<p>newline：文本模式中，换行的转换。可以为None、’’ 空串、’\r’、’\n’、’\r\n’ 。</p>
<ul>
<li>None表示’\r’、’\n’、’\r\n’都被转换为’\n’；</li>
<li>‘’  表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。</li>
<li>‘\n’或’’表示’\n’不替换；其它合法字符表示’\n’会被替换为指定的字符</li>
</ul>
<p>closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。</p>
<p><strong>文件描述符</strong>：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。</p>
<p>对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。<br>IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 </p>
<p>一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。</p>
<h5 id="read（）"><a href="#read（）" class="headerlink" title="read（）"></a>read（）</h5><p>read(size=-1)<br>size表示读取的多少个字符或字节；负数或者None表示读取到EOF</p>
<p>readline(size=-1)<br>一行行读取文件内容。size设置一次能读取行内几个字符或字节。</p>
<p>readlines(hint=-1)<br>读取所有行的列表。指定hint则返回指定的行数。</p>
<h5 id="write（）"><a href="#write（）" class="headerlink" title="write（）"></a>write（）</h5><p>write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。</p>
<h5 id="close（）"><a href="#close（）" class="headerlink" title="close（）"></a>close（）</h5><p>flush并关闭文件对象。<br>文件已经关闭，再次关闭没有任何效果。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>seekable（）</td>
<td>是否可seek</td>
</tr>
<tr>
<td>readable（）</td>
<td>是否可读</td>
</tr>
<tr>
<td>writeable（）</td>
<td>是否可写</td>
</tr>
<tr>
<td>closed（）</td>
<td>是否已经关闭</td>
</tr>
</tbody>
</table>
<h5 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h5><p>1、异常处理<br>当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">"abc"</span>) <span class="comment"># 文件只读，写入失败</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close() <span class="comment"># 这样才行</span></span><br></pre></td></tr></table></figure>
<p>使用finally可以保证打开的文件可以被关闭。</p>
<p>上下文管理</p>
<ol>
<li><p>使用with … as 关键字</p>
</li>
<li><p>上下文管理的语句块并不会开启新的作用域</p>
</li>
<li><p>with语句块执行完的时候，会自动关闭文件对象</p>
</li>
</ol>
<h4 id="StringIO操作"><a href="#StringIO操作" class="headerlink" title="StringIO操作"></a>StringIO操作</h4><p>io模块中的类</p>
<pre><code>from io import StringIO
</code></pre><p>内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它</p>
<p>当close方法被调用的时候，这个buffer会被释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="comment"># 内存中构建</span></span><br><span class="line">sio = StringIO() <span class="comment"># 像文件对象一样操作</span></span><br><span class="line">print(sio.readable(), sio.writable(), sio.seekable())<span class="comment"># True True True</span></span><br><span class="line">sio.write(<span class="string">"luo\nPython"</span>)</span><br><span class="line">sio.seek(<span class="number">0</span>)  </span><br><span class="line">print(sio.readline())  <span class="comment">#magedu</span></span><br><span class="line">print(sio.getvalue()) <span class="comment"># 无视指针，输出全部内容  magedu   Python</span></span><br><span class="line">sio.close()</span><br></pre></td></tr></table></figure>
<p>好处</p>
<pre><code>一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。
</code></pre><h4 id="BytesIO操作"><a href="#BytesIO操作" class="headerlink" title="BytesIO操作"></a>BytesIO操作</h4><p>io模块中的类</p>
<pre><code>from io import BytesIO
</code></pre><p>内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它</p>
<p>当close方法被调用的时候，这个buffer会被释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO <span class="comment"># 内存中构建</span></span><br><span class="line">bio = BytesIO()</span><br><span class="line">print(bio.readable(), bio.writable(), bio.seekable()) <span class="comment">#True True True</span></span><br><span class="line">bio.write(<span class="string">b"luo\nPython"</span>)</span><br><span class="line">bio.seek(<span class="number">0</span>)</span><br><span class="line">print(bio.readline())  <span class="comment"># b'magedu\n'</span></span><br><span class="line">print(bio.getvalue()) <span class="comment"># 无视指针，输出全部内容   b'magedu\nPython'</span></span><br><span class="line">bio.close()</span><br></pre></td></tr></table></figure>
<h4 id="file-like对象"><a href="#file-like对象" class="headerlink" title="file-like对象"></a>file-like对象</h4><p>类文件对象，可以像文件对象一样操作。</p>
<p>socket对象，输入输出对象（stdin、stdout）都是类文件对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdout, stderr</span><br><span class="line">f = stdout</span><br><span class="line">print(type(f))  <span class="comment">#&lt;class 'ipykernel.iostream.OutStream'&gt;</span></span><br><span class="line">f.write(<span class="string">'magedu.com'</span>)  <span class="comment">#magedu.com</span></span><br></pre></td></tr></table></figure>
<h4 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h4><h5 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h5><p>3.4版本之前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line">p = path.join(<span class="string">'d:/'</span>,<span class="string">'tmp'</span>)</span><br><span class="line">print(type(p), p)               <span class="comment">#&lt;class 'str'&gt; d:/tmp</span></span><br><span class="line">print(path.exists(p))     <span class="comment">#判断是否存在该路径  True</span></span><br><span class="line">print(path.split(p)) <span class="comment"># (head,tail)     ('d:/', 'tmp')</span></span><br><span class="line">print(path.abspath(<span class="string">'.'</span>))   <span class="comment"># 打印当前的绝对路径      C:\Users\vampire\python</span></span><br><span class="line">p = path.join(<span class="string">'D:/'</span>, p, <span class="string">'test.txt'</span>)   <span class="comment">#  'd:/tmp\\test.txt'</span></span><br><span class="line">print(path.dirname(p)) <span class="comment"># 目录名</span></span><br><span class="line">print(path.basename(p)) <span class="comment">#基名，就是文件名</span></span><br><span class="line">print(path.splitdrive(p)) <span class="comment">#二元组  ('d:', '/tmp\\test.txt'）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p1 = path.abspath(<span class="string">"."</span>)  <span class="comment">#“文件路径”</span></span><br><span class="line">print(p1, path.basename(p1))</span><br><span class="line"><span class="keyword">while</span> p1 != path.dirname(p1):</span><br><span class="line">    p1 = path.dirname(p1)</span><br><span class="line">    print(p1, path.basename(p1))</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>C:\Users\vampire\python python<br>C:\Users\vampire vampire<br>C:\Users Users<br>C:\<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">##### pathlib模块</span><br><span class="line"></span><br><span class="line">提供Path对象来操作。包括目录和文件。</span><br><span class="line"></span><br><span class="line">导入模块：from pathlib import Path</span><br><span class="line"></span><br><span class="line">**目录操作初始化**：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">p = Path() # 当前目录    WindowsPath(&apos;.&apos;)</span><br><span class="line">p.absolute()#   WindowsPath(&apos;C:/Users/vampire/python&apos;)</span><br><span class="line">p = Path(&apos;a&apos;,&apos;b&apos;,&apos;c/d&apos;) # 当前目录下的 WindowsPath(&apos;C:/Users/vampire/python/a/b/c/d&apos;)</span><br><span class="line">p = Path(&apos;/etc&apos;) # 根下的etc目录</span><br></pre></td></tr></table></figure></p>
<p><strong>路径拼接和分解</strong></p>
<h6 id="操作符"><a href="#操作符" class="headerlink" title="操作符/"></a>操作符/</h6><p>Path对象 / Path对象<br>Path对象 / 字符串 或者 字符串 / Path对象 </p>
<h6 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h6><p>parts属性，可以返回路径中的每一个部分 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3.absolute()   <span class="comment">#WindowsPath('C:/Users/vampire/python/c/a')</span></span><br><span class="line">p3.absolute().parts   <span class="comment">#('C:\\', 'Users', 'vampire', 'python', 'c', 'a')</span></span><br></pre></td></tr></table></figure>
<h6 id="joinpath"><a href="#joinpath" class="headerlink" title="joinpath"></a>joinpath</h6><p>joinpath(*other) 连接多个字符串到Path对象中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = Path()   <span class="comment">#   WindowsPath('.')</span></span><br><span class="line">p = p / <span class="string">'a'</span>   <span class="comment">#  WindowsPath('a')</span></span><br><span class="line">p.absolute()  <span class="comment">#   WindowsPath('C:/Users/vampire/python/a')</span></span><br><span class="line">p1 = <span class="string">'b'</span> / p  <span class="comment">#   WindowsPath('C:/Users/vampire/python/b/a')</span></span><br><span class="line">p2 = Path(<span class="string">'c'</span>) <span class="comment">#  WindowsPath('C:/Users/vampire/python/c')</span></span><br><span class="line">p2.absolute()  <span class="comment">#   WindowsPath('C:/Users/vampire/python/c')</span></span><br><span class="line">p3 = p2 / p1  <span class="comment">#  WindowsPath('c/b/a')</span></span><br><span class="line">p3.absolute()  <span class="comment">#  WindowsPath('C:/Users/vampire/python/c/b/a')</span></span><br><span class="line">print(p3.parts)   <span class="comment">#</span></span><br><span class="line">p3.absolute().parts <span class="comment"># ('C:\\', 'Users', 'vampire', 'python', 'c', 'b', 'a')</span></span><br><span class="line">p3.joinpath(<span class="string">'etc'</span>,<span class="string">'init.d'</span>,Path(<span class="string">'httpd'</span>))</span><br></pre></td></tr></table></figure>
<h6 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h6><p>str 获取路径字符串 </p>
<p>bytes 获取路径字符串的bytes </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">'/etc'</span>)</span><br><span class="line">print(str(p), bytes(p))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  \etc   b'\\etc'</span></span><br></pre></td></tr></table></figure>
<h6 id="父目录"><a href="#父目录" class="headerlink" title="父目录"></a>父目录</h6><p>parent 目录的逻辑父目录 </p>
<p>parents 父目录序列，索引0是直接的父 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">'/a/b/c/d'</span>)</span><br><span class="line">print(p.absolute())   <span class="comment">#C:\a\b\c\d</span></span><br><span class="line">print(p.parent.parent)  <span class="comment">#\a\b</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> p.parents:</span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#\a\b\c</span></span><br><span class="line"><span class="comment">#\a\b</span></span><br><span class="line"><span class="comment">#\a</span></span><br><span class="line"><span class="comment">#\</span></span><br></pre></td></tr></table></figure>
<h6 id="目录的组合部分"><a href="#目录的组合部分" class="headerlink" title="目录的组合部分"></a>目录的组合部分</h6><p>name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) </p>
<p>name 目录的最后一个部分 </p>
<p>suffix 目录中最后一个部分的扩展名 </p>
<p>stem 目录最后一个部分，没有后缀 </p>
<p>suffixes 返回多个扩展名列表 </p>
<p>with_suffix(suffix) 有扩展名则替换，无则补充扩展名 </p>
<p>with_name(name) 替换目录最后一个部分并返回一个新的路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">'mysqlinstall/mysql.tar.gz'</span>)</span><br><span class="line">print(p.name)   <span class="comment">#mysql.tar.gz</span></span><br><span class="line">print(p.suffix)  <span class="comment">#.gz</span></span><br><span class="line">print(p.suffixes)  <span class="comment"># ['.tar', '.gz']</span></span><br><span class="line">print(p.stem)   <span class="comment"># mysql.tar</span></span><br><span class="line">print(p.with_name(<span class="string">'mysql-5.tgz'</span>))   <span class="comment">#\mysqlinstall\mysql-5.tgz</span></span><br><span class="line">print(p.with_suffix(<span class="string">'.png'</span>))   <span class="comment">#\mysqlinstall\mysql.tar.png</span></span><br><span class="line">p = Path(<span class="string">'README'</span>)  <span class="comment">#  README</span></span><br><span class="line">print(p.with_suffix(<span class="string">'.txt'</span>))   <span class="comment">#  README.txt</span></span><br></pre></td></tr></table></figure>
<h6 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h6><p><code>is_dir()</code> 是否是目录，目录存在返回True </p>
<p><code>is_file()</code> 是否是普通文件，文件存在返回True </p>
<p><code>is_symlink()</code> 是否是软链接 </p>
<p><code>is_socket()</code>是否是socket文件 </p>
<p><code>is_block_device()</code>是否是块设备 </p>
<p><code>is_char_device()</code> 是否是字符设备 </p>
<p><code>is_absolute()</code>是否是绝对路径</p>
<p><code>resolve()</code>返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 </p>
<p><code>absolute()</code> 获取绝对路径</p>
<p><code>exists()</code>目录或文件是否存在 </p>
<p><code>rmdir()</code>删除空目录。没有提供判断目录为空的方法 </p>
<p><code>touch(mode=0o666, exist_ok=True)</code> 创建一个文件 </p>
<p><code>as_uri()</code> 将路径返回成URI，例如’file:///etc/passwd’</p>
<p><code>mkdir(mode=0o777, parents=False, exist_ok=False)</code></p>
<ul>
<li><p>parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError </p>
</li>
<li><p>exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略</p>
</li>
</ul>
<p><code>iterdir()</code>迭代当前目录</p>
<h6 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h6><p>match（pattern）</p>
<p>模式匹配，成功返回True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path(<span class="string">'a/b.py'</span>).match(<span class="string">'*.py'</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'b/*.py'</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'a/*.py'</span>) <span class="comment"># False</span></span><br><span class="line">Path(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'a/*/*.py'</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'a/**/*.py'</span>) <span class="comment"># True</span></span><br><span class="line">Path(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'**/*.py'</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>stat()  相当于stat命令  ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息</p>
<h6 id="pathlib模块下的文件操作"><a href="#pathlib模块下的文件操作" class="headerlink" title="pathlib模块下的文件操作"></a>pathlib模块下的文件操作</h6><p><code>Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None)</code></p>
<p>使用的方法类似内建函数open，返回一个文件对象。</p>
<p>3.5增加的新函数 </p>
<p><code>Path.read_bytes()</code></p>
<p>以’rb’读取路径对应文件，并返回二进制流。看源码</p>
<p><code>Path.read_text(encoding=None, errors=None)</code></p>
<p>以’rt’方式读取路径对应文件，返回文本。</p>
<p><code>Path.write_bytes(data)</code></p>
<p>以’wb’方式写入数据到路径对应文件。</p>
<p><code>Path.write_text(data, encoding=None, errors=None)</code></p>
<p>以’wt’方式写入字符串到路径对应文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p = Path(<span class="string">'my_binary_file'</span>)</span><br><span class="line">p.write_bytes(<span class="string">b'Binary file contents'</span>)</span><br><span class="line">p.read_bytes() <span class="comment"># b'Binary file contents'</span></span><br><span class="line"> </span><br><span class="line">p = Path(<span class="string">'my_text_file'</span>)</span><br><span class="line">p.write_text(<span class="string">'Text file contents'</span>)</span><br><span class="line">p.read_text() <span class="comment"># 'Text file contents'</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">p = Path(<span class="string">'o:/test.py'</span>)</span><br><span class="line">p.write_text(<span class="string">'hello python'</span>)</span><br><span class="line">print(p.read_text())</span><br><span class="line"><span class="keyword">with</span> p.open() <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h4 id="csv文件"><a href="#csv文件" class="headerlink" title="csv文件"></a>csv文件</h4><p>逗号分隔值Comma-Separated Values。 </p>
<p>CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 </p>
<p>CSV 不指定字符编码。</p>
<p>行分隔符为\r\n，最后一行可以没有换行符 </p>
<p>列分隔符常为逗号或者制表符。 </p>
<p>每一行称为一条记录record </p>
<p>字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。</p>
<p>表头可选，和字段列对齐就行了。</p>
<p>手动生成csv文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">p = Path(<span class="string">'D:/tmp/test.csv'</span>)</span><br><span class="line">parent = p.parent</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> parent.exists():</span><br><span class="line">    parent.mkdir(parents=<span class="keyword">True</span>,exist_ok =<span class="keyword">True</span>) <span class="comment">#exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。</span></span><br><span class="line">csv_body = <span class="string">'''\</span></span><br><span class="line"><span class="string">id,name,age,comment</span></span><br><span class="line"><span class="string">1,zs,18,"I'm 18"</span></span><br><span class="line"><span class="string">2,ls,20,"this is a ""test"" string."</span></span><br><span class="line"><span class="string">3,ww,23,"你好</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">计算机</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">p.write_text(csv_body)</span><br></pre></td></tr></table></figure>
<h5 id="csv模块"><a href="#csv模块" class="headerlink" title="csv模块"></a>csv模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(iterable, dialect=<span class="string">'excel'</span>, *args, **kwargs)</span></span></span><br></pre></td></tr></table></figure>
<p>返回一个reader对象，是一个行迭代器</p>
<p>默认使用excel方言，如下：</p>
<ul>
<li><p>delimiter 列分隔符,逗号</p>
</li>
<li><p>lineterminator 行分隔符\r\n</p>
</li>
<li><p>quotechar 字段的引用符号，缺省为”双引号</p>
</li>
<li><p>双引号的处理</p>
<ul>
<li>doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。</li>
<li>escapechar 一个转义字符，默认为None</li>
<li>writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符</li>
</ul>
</li>
<li><p>quoting 指定双引号的规则</p>
<ul>
<li><p>QUOTE_ALL 所有字段</p>
</li>
<li><p>QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则</p>
</li>
<li><p>QUOTE_NONNUMERIC非数字字段</p>
</li>
<li><p>QUOTE_NONE都不使用引号。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(fileobj, dialect=<span class="string">'excel'</span>, *args, **kwargs)</span></span></span><br></pre></td></tr></table></figure>
<p>返回DictWriter实例，主要的方法有writerow，writerows。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"> </span><br><span class="line">p = Path(<span class="string">'d://tmp/tesr.csv'</span>)</span><br><span class="line"><span class="keyword">with</span> open(str(p)) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)    <span class="comment">#返回一个迭代对象</span></span><br><span class="line">    print(next(reader))     <span class="comment">#不回头</span></span><br><span class="line">    print(next(reader))     </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">        print(line)</span><br><span class="line"> </span><br><span class="line">rows = [</span><br><span class="line">    [<span class="number">4</span>,<span class="string">'tom'</span>,<span class="number">22</span>,<span class="string">'tom'</span>],</span><br><span class="line">    (<span class="number">5</span>,<span class="string">'jerry'</span>,<span class="number">24</span>,<span class="string">'jerry'</span>),</span><br><span class="line">    (<span class="number">6</span>,<span class="string">'justin'</span>,<span class="number">22</span>,<span class="string">'just\t"in'</span>),</span><br><span class="line">    <span class="string">"abcdefghi"</span>,</span><br><span class="line">    ((<span class="number">1</span>,),(<span class="number">2</span>,))</span><br><span class="line">]</span><br><span class="line">row = rows[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(str(p), <span class="string">'a'</span>,newline=<span class="string">""</span>) <span class="keyword">as</span> f:  <span class="comment">#newline为了不换行</span></span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    writer.writerow(row)   <span class="comment">#一次写一条</span></span><br><span class="line">    writer.writerows(rows)    <span class="comment">#将所有的一次写入</span></span><br></pre></td></tr></table></figure>
<h4 id="ini文件"><a href="#ini文件" class="headerlink" title="ini文件"></a>ini文件</h4><p>一般作为配置文件。</p>
<p>ini文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">a</span> = test</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">datadir</span> =/dbserver/data</span><br><span class="line"><span class="attr">port</span> = <span class="number">33060</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>
<p>中括号里面的部分称为section，译作节、区、段。 </p>
<p>每一个section内，都是key=value形成的键值对，key称为option选项。</p>
<p>这里的DEFAULT是缺省section的名字，必须大写。</p>
<h5 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a>configparser模块</h5><p>configparser模块的ConfigParser类就是用来操作。</p>
<p>可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">read(filenames, encoding=<span class="keyword">None</span>) </span><br><span class="line"><span class="comment">#读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。</span></span><br><span class="line">sections()  <span class="comment">#返回section列表。缺省section不包括在内。 </span></span><br><span class="line">add_section(section_name)   <span class="comment">#增加一个section。 </span></span><br><span class="line"></span><br><span class="line">has_section(section_name)   <span class="comment">#判断section是否存在 </span></span><br><span class="line">options(section)   <span class="comment">#返回section的所有option，会追加缺省section的option </span></span><br><span class="line"></span><br><span class="line">has_option(section, option)  <span class="comment">#判断section是否存在这个option</span></span><br><span class="line">get(section, option, *, raw=<span class="keyword">False</span>, vars=<span class="keyword">None</span>[, fallback]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。</span></span><br><span class="line"></span><br><span class="line">getint(section, option, *, raw=<span class="keyword">False</span>, vars=<span class="keyword">None</span>[, fallback]) </span><br><span class="line">getfloat(section, option, *, raw=<span class="keyword">False</span>, vars=<span class="keyword">None</span>[, fallback]) </span><br><span class="line">getboolean(section, option, *, raw=<span class="keyword">False</span>, vars=<span class="keyword">None</span>[, fallback]) </span><br><span class="line"><span class="comment">#上面3个方法和get一样，返回指定类型数据。</span></span><br><span class="line"></span><br><span class="line">items(raw=<span class="keyword">False</span>, vars=<span class="keyword">None</span>) </span><br><span class="line">items(section, raw=<span class="keyword">False</span>, vars=<span class="keyword">None</span>) </span><br><span class="line"><span class="comment">#没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。</span></span><br><span class="line"></span><br><span class="line">set(section, option, value) </span><br><span class="line"><span class="comment">#section存在的情况下，写入option=value，要求option、value必须是字符串。</span></span><br><span class="line"></span><br><span class="line">remove_section(section) </span><br><span class="line"><span class="comment">#移除section及其所有option </span></span><br><span class="line"></span><br><span class="line">remove_option(section, option) </span><br><span class="line"><span class="comment">#移除section下的option。</span></span><br><span class="line"></span><br><span class="line">write(fileobject, space_around_delimiters=<span class="keyword">True</span>) </span><br><span class="line"><span class="comment">#将当前config的所有内容写入fileobject中，一般open函数使用w模式。</span></span><br></pre></td></tr></table></figure>
<p>代码示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> configparser <span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">filename = Path(<span class="string">"d://tmp/mysql.ini"</span>)</span><br><span class="line">newfilename = Path(<span class="string">"d://tmp/mysql111.ini"</span>)</span><br><span class="line"></span><br><span class="line">cfg = ConfigParser()</span><br><span class="line">read_ok = cfg.read(str(filename))</span><br><span class="line">print(read_ok)</span><br><span class="line">print(cfg.sections())</span><br><span class="line">print(cfg.has_section(<span class="string">"mysql"</span>))</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg.items():   <span class="comment">#未指定section</span></span><br><span class="line">    print(k,type(k))</span><br><span class="line">    print(v,type(v))</span><br><span class="line">    print(cfg.items(k))</span><br><span class="line">    print(<span class="string">"~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg.items(<span class="string">"mysqld"</span>):  <span class="comment">#指定section</span></span><br><span class="line">    print(k,type(k))</span><br><span class="line">    print(v,type(v))</span><br><span class="line">    print(<span class="string">"~~~~~~~~~~"</span>)</span><br><span class="line"></span><br><span class="line">tmp = cfg.get(<span class="string">"mysqld"</span>,<span class="string">"port"</span>)</span><br><span class="line">print(tmp, type(tmp))</span><br><span class="line">print(cfg.get(<span class="string">"mysqld"</span>, <span class="string">"a"</span>))</span><br><span class="line">print(cfg.get(<span class="string">"mysqld"</span>, <span class="string">"python"</span> , fallback= <span class="string">"linux"</span>))  <span class="comment">#按照类型，fallbac：给与缺省值</span></span><br><span class="line"></span><br><span class="line">tmp = cfg.getint(<span class="string">"mysqld"</span>, <span class="string">"port"</span>)</span><br><span class="line">print(type(tmp), tmp)</span><br><span class="line"></span><br><span class="line">cfg.add_section(<span class="string">"test"</span>)</span><br><span class="line">cfg.set(<span class="string">"test"</span>,<span class="string">"test1"</span>,<span class="string">"1"</span>)</span><br><span class="line">cfg.set(<span class="string">"test"</span>,<span class="string">"test2"</span>,<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">with</span> open(newfilename,<span class="string">"w+"</span>,newline=<span class="string">""</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cfg.write(f)</span><br><span class="line"></span><br><span class="line">print(cfg.getint(<span class="string">"test"</span> , <span class="string">"test1"</span>))</span><br><span class="line"></span><br><span class="line">cfg.remove_option(<span class="string">"test"</span>, <span class="string">"test1"</span>)</span><br><span class="line"><span class="comment"># cfg.remove_section("test")</span></span><br><span class="line"><span class="comment"># print("x" in cfg["test2"])</span></span><br><span class="line"><span class="comment">#字典操作</span></span><br><span class="line">cfg[<span class="string">"test3"</span>] = &#123;<span class="string">"c"</span>:<span class="string">"1000"</span>&#125;   <span class="comment">#没有落地，在内存中修改</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"x"</span> <span class="keyword">in</span> cfg[<span class="string">"test"</span>])</span><br><span class="line">print(<span class="string">"c"</span> <span class="keyword">in</span> cfg[<span class="string">"test3"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他内部方式</span></span><br><span class="line">print(cfg._dict)  <span class="comment"># 返回默认的字典类型，默认使用有序字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> cfg._sections.items():</span><br><span class="line">    print(k, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> cfg._sections[<span class="string">'mysqld'</span>].items():</span><br><span class="line">    print(k,v)</span><br><span class="line"><span class="comment">#重新写入文件</span></span><br><span class="line"><span class="keyword">with</span> open(newfilename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cfg.write(f)</span><br></pre></td></tr></table></figure></p>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><pre><code>要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。
</code></pre><ol>
<li><p>serialization：序列化<br>将内存中对象存储下来，变成一个个字节 –&gt;  二进制</p>
</li>
<li><p>deseiralization：反序列化<br>将文件中的一个个字节恢复成内存中对象   &lt;–二进制</p>
</li>
</ol>
<p>序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。</p>
<h5 id="pickle库"><a href="#pickle库" class="headerlink" title="pickle库"></a>pickle库</h5><p>python中的序列化，反序列化模块。</p>
<p>dumps  对象序列化为bytes对象      dump   对象序列化到文件对象，就是存入文件</p>
<p>loads 从bytes对象反序列化     load  对象反序列化，从文件读取数据</p>
<h5 id="序列化的应用"><a href="#序列化的应用" class="headerlink" title="序列化的应用"></a>序列化的应用</h5><p>一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 </p>
<p>将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 </p>
<p>但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。</p>
<p>现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。</p>
<p>但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。</p>
<p>不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。</p>
<h5 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h5><pre><code>Json(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/
</code></pre><p>Json的数据类型</p>
<p>值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 </p>
<p>字符串：有正负，有整数，浮点数。</p>
<p>对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。</p>
<p>数组：有序的值的集合  格式[val1，，，，valn]</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"person"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"tom"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"jerry"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"total"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Json模块</p>
<p>Python支持少量内建数据类型到Json类型的转换</p>
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Json类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>list</td>
<td>array</td>
</tr>
<tr>
<td>dict</td>
<td>object</td>
</tr>
</tbody>
</table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Json类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>dumps</td>
<td>Json编码</td>
</tr>
<tr>
<td>dump</td>
<td>Json编码并存入文件</td>
</tr>
<tr>
<td>loads</td>
<td>Json解码</td>
</tr>
<tr>
<td>load</td>
<td>Json解码，从文件读取数据</td>
</tr>
</tbody>
</table>
<p>一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。</p>
<h5 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h5><p>MessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 </p>
<p>它可以像JSON那样，在许多种语言之间交换结构对象。 </p>
<p>兼容 json和pickle。</p>
<p>MessagePack简单易用，高效压缩，支持语言丰富。 </p>
<p>所以，用它序列化也是一种很好的选择。</p>
<p>安装：$pip install msgpack-python</p>
<p>常用方法：</p>
<p>packb 序列化对象。提供了dumps来兼容pickle和json。 </p>
<p>unpackb 反序列化对象。提供了loads来兼容。</p>
<p>pack 序列化对象保存到文件对象。提供了dump来兼容。</p>
<p>unpack 反序列化对象保存到文件对象。提供了load来兼容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> msgpack</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">"person"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"tom"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"jerry"</span>,<span class="string">"age"</span>:<span class="number">16</span>&#125;],<span class="string">"total"</span>:<span class="number">2</span>&#125;</span><br><span class="line">j = json.dumps(d)</span><br><span class="line">print(j, type(j), len(j)) <span class="comment"># 请注意引号的变化</span></span><br><span class="line">print(len(j.replace(<span class="string">' '</span>,<span class="string">''</span>))) <span class="comment"># 72 bytes 注意这样替换的压缩是不对的</span></span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">30</span>)</span><br><span class="line">p = pickle.dumps(d)</span><br><span class="line">print(p)</span><br><span class="line">print(len(p))  <span class="comment"># 101 bytes</span></span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">30</span>)</span><br><span class="line">m = msgpack.dumps(d)</span><br><span class="line">print(m)</span><br><span class="line">print(len(m)) <span class="comment"># 48 bytes</span></span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">30</span>)</span><br><span class="line">u = msgpack.unpackb(m)</span><br><span class="line">print(type(u), u)</span><br><span class="line">u = msgpack.loads(m, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(u), u)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &apos;str&apos;&gt; 82</span><br><span class="line">72</span><br><span class="line">------------------------------</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x06\x00\x00\x00personq\x01]q\x02(&#125;q\x03(X\x04\x00\x00\x00nameq\x04X\x03\x00\x00\x00tomq\x05X\x03\x00\x00\x00ageq\x06K\x12u&#125;q\x07(h\x04X\x05\x00\x00\x00jerryq\x08h\x06K\x10ueX\x05\x00\x00\x00totalq\tK\x02u.&apos;</span><br><span class="line">101</span><br><span class="line">------------------------------</span><br><span class="line">b&apos;\x82\xa6person\x92\x82\xa4name\xa3tom\xa3age\x12\x82\xa4name\xa5jerry\xa3age\x10\xa5total\x02&apos;</span><br><span class="line">48</span><br><span class="line">------------------------------</span><br><span class="line">&lt;class &apos;dict&apos;&gt; &#123;b&apos;person&apos;: [&#123;b&apos;name&apos;: b&apos;tom&apos;, b&apos;age&apos;: 18&#125;, &#123;b&apos;name&apos;: b&apos;jerry&apos;, b&apos;age&apos;: 16&#125;], b&apos;total&apos;: 2&#125;</span><br><span class="line">&lt;class &apos;dict&apos;&gt; &#123;&apos;person&apos;: [&#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18&#125;, &#123;&apos;name&apos;: &apos;jerry&apos;, &apos;age&apos;: 16&#125;], &apos;total&apos;: 2&#125;</span><br></pre></td></tr></table></figure>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">https://luoqian67.github.io/blog/</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/blog/2017/09/22/11python异常处理、模块化/" class="pre-post btn btn-default" title="python-异常处理、模块化">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">python-异常处理、模块化</span>
        </a>
    
    
        <a href="/blog/2017/09/10/10python文件处理、路径处理、序列化和反序列化/" class="next-post btn btn-default" title="python-文件处理、路径处理、序列化和反序列化">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">python-文件处理、路径处理、序列化和反序列化</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/blog/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xme1rFxnnyLwK8UFBgckpusw-gzGzoHsz',
            appKey: 'u9MbOVN8LcSmPkewWeQKtEnJ',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件IO常用操作"><span class="toc-text">文件IO常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#open打开操作"><span class="toc-text">open打开操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mode模式"><span class="toc-text">mode模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#seek文件指针"><span class="toc-text">seek文件指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#buffering缓冲区"><span class="toc-text">buffering缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其他参数"><span class="toc-text">其他参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#read（）"><span class="toc-text">read（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#write（）"><span class="toc-text">write（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#close（）"><span class="toc-text">close（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#上下文管理"><span class="toc-text">上下文管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringIO操作"><span class="toc-text">StringIO操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BytesIO操作"><span class="toc-text">BytesIO操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#file-like对象"><span class="toc-text">file-like对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路径操作"><span class="toc-text">路径操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#os-path模块"><span class="toc-text">os.path模块</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#操作符"><span class="toc-text">操作符/</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#分解"><span class="toc-text">分解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#joinpath"><span class="toc-text">joinpath</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#获取路径"><span class="toc-text">获取路径</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#父目录"><span class="toc-text">父目录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#目录的组合部分"><span class="toc-text">目录的组合部分</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#判断方法"><span class="toc-text">判断方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#匹配"><span class="toc-text">匹配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pathlib模块下的文件操作"><span class="toc-text">pathlib模块下的文件操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csv文件"><span class="toc-text">csv文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#csv模块"><span class="toc-text">csv模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ini文件"><span class="toc-text">ini文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#configparser模块"><span class="toc-text">configparser模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化和反序列化"><span class="toc-text">序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pickle库"><span class="toc-text">pickle库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#序列化的应用"><span class="toc-text">序列化的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Json"><span class="toc-text">Json</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MessagePack"><span class="toc-text">MessagePack</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/blog/js/app.js?rev=@@hash"></script>

</body>
</html>