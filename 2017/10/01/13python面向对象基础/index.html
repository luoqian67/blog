<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="个人博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://luoqian67.github.io/blog">
    <!--SEO-->





<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>python-面向对象 | 个人博客</title>


    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/blog/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/blog/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/blog/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Luo Qian">
            <img src="/blog/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/blog/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://luoqian67.github.io/blog">个人博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/Linux/"><i class="fa "></i>Linux</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/python/"><i class="fa "></i>python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/杂项教程/"><i class="fa "></i>杂项</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="python-面向对象">
            
	            python-面向对象
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/python" title="python">
                        python
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/10/01</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><hr>
<p>一种认识世界，分析世界的方法论。将万事万物抽象为类</p>
<p>类class</p>
<p>类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。用计算机语言来描述就是<strong>属性</strong>和<strong>方法</strong>的集合（封装）。</p>
<p>对象instance、object，对象是类的具象，是一个实体，类也是对象。</p>
<p>属性，它是对象状态的抽象，用数据结构来描述。</p>
<p>操作，是对对象行为的抽象，用操作名和实现该操作的方法来描述。</p>
<p><strong>哲学</strong></p>
<p>一切皆对象</p>
<p>对象是数据和操作的封装</p>
<p>对象是独立的，但是对象之间可以相互作用</p>
<p>目前OOP是最接近人类认知的编程范式</p>
<h4 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h4><font color="red"><strong>封装</strong></font>：将属性和方法组装到一起，隐藏数据，对外只暴露一些接口用于连接。<br><br><font color="red"><strong>继承</strong></font>：目的：多复用，继承来的就不用自己写了；多继承少修改（开闭原则），OCP(open_closed principle)，使用继承来改变。作用：就是为了修改不一样的属性。<br><br><font color="red"><strong>多态</strong></font>：面向对象编程最灵活的地方，多种表现，动态绑定。<br><br>#### Python的类<br><br>定义：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>：</span></span><br><span class="line"><span class="class">	语句块</span></span><br></pre></td></tr></table></figure><br><br><strong>要求：</strong><br><br>1. 必须使用class关键字<br><br>2. 类名必须使用大驼峰命名<br><br>3. 类定义完成后会产生一个类对象，会绑定到ClassName这个标识符上面。<br><br>#### 类对象和类属性<br><br><font color="red"><strong>类对象</strong></font>，类的定义就会生成一个类对象<br><br><font color="red"><strong>类的属性</strong></font>，类定义中的变量和类中定义的方法都是类的属性<br><br><font color="red"><strong>类变量</strong></font>，定义在类中的变量<br><br>#### 实例化<br><br>在类对象名称后面加上一个括号，就调用类的实例化方法，完成实例化，实例化就真正创建一个该类的对象（实例）。<br><br>每一次实例化，只能生成该类的一个具体实例，生成的是不同的实例。即使通过相同的参数实例化，得到的对象也不相同。<br><br>python类实例化后，会自动调用<code>__init__</code>方法，可以不定义，如果没有定义会在实例化后<strong>隐式</strong>调用，初始化函数可以有多个参数，第一参数必须留给self，init方法不能有返回值，也就是只能有return None<br><br>作用：对实例进行<font color="red"><strong>初始化</strong></font>

<p>类里面的函数叫做方法对象method，不是普通的函数对象function，一般至少要有一个参数，第一个参数可以是self（一般习惯上用self），这个参数位置指代的就是当前这个实例本身。</p>
<h4 id="实例对象instance"><a href="#实例对象instance" class="headerlink" title="实例对象instance"></a>实例对象instance</h4><p>类实例化后一定会获得一个对象，就是<font color="red"><strong>实例对象</strong></font>。init方法的第一个参数self就是指代某一个实例。</p>
<h4 id="实例变量和类变量"><a href="#实例变量和类变量" class="headerlink" title="实例变量和类变量"></a>实例变量和类变量</h4><p>实例变量是每个实例自己的变量，是自己独有的；列变量是类的变量，是类的所有实例共享的属性和方法。</p>
<table>
<thead>
<tr>
<th>特殊属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>__name__</td>
<td>对象名</td>
</tr>
<tr>
<td>__class__</td>
<td>对象的类型</td>
</tr>
<tr>
<td>__dict__</td>
<td>对象的属性的字典</td>
</tr>
<tr>
<td>__qualname__</td>
<td>类的限定名</td>
</tr>
</tbody>
</table>
<p>类属性保存在类的dict中，实例属性保存在实例的dict中，如果从实例访问类的属性，就要借助class找到所属的类。</p>
<p>类有类名字，实例没有实体名。</p>
<p>python中每一种对象都拥有不同的属性。函数、类都是对象，类的实例也是对象。</p>
<p>类不可以访问实例的属性，实例可以访问类的属性。（是类的，也是这个类所有实例的，其实例都可以访问到；是实例的，就是这个实例自己的，通过类访问不到。）</p>
<p>对象（实例或类）可以动态的给自己增加一个属性，实例.__dict__[变量名]可以访问到，实例的同名变量会隐藏掉类变量，或者说是覆盖了这个类的变量。</p>
<p>一般来说，属性使用字典保存是为了提升查找效率，必须用空间换时间，但是也有个问题，如果数百万个对象，那么字典占的比较大，所以可以使用__slots__方法。</p>
<p>slots告诉解释器，实例的属性都叫什么，一般来说，既然要节省内存，那就最好还是使用元组。</p>
<p>一旦类提供了slots，就阻止实例产生dict来保存实例的属性。子类不会继承slots</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'z'</span>,<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.X,self.y)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.show()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"A"</span>,A.__dict__.keys())</span><br><span class="line"><span class="comment"># print("obj",a.__dict__.keys())</span></span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>实例属性的查找顺序 </strong></font><br>指的是实例使用.点号来访问属性，会先找实例自己的_<em>dict\</em>_，如果没有，然后通过属性__class__找到自己的类，再去类的__dict__中找类属性中没找到就往类继承的父类中去查找，最终找到根基类object，没找到则抛出异常 。<br>注意，如果实例使用__dict__[变量名]访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的key查找，不是属性查找。<br>一般来说，类变量可使用全大写来命名。</p>
<h4 id="装饰一个类"><a href="#装饰一个类" class="headerlink" title="装饰一个类"></a>装饰一个类</h4><p>为一个类通过装饰，添加一些类属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加类变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adda_name</span><span class="params">(name,cls)</span>:</span></span><br><span class="line">    cls.NAME = name  <span class="comment">#动态增加类属性</span></span><br><span class="line"><span class="comment">#改进成装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_name</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.NAME = name</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@add_name("jerry")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span>  <span class="comment">#Person =  add_name("jerry")(Person) = wrapper(person) =  Person</span></span><br><span class="line">    AGE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># adda_name(Person ,"tom")</span></span><br><span class="line">	</span><br><span class="line">print(Person.__dict__)</span><br><span class="line">print(Person.NAME)</span><br></pre></td></tr></table></figure>
<p>之所以能够装饰，本质上是为类对象动态的添加了一个属性，而Person这个标识符指向这个类对象。</p>
<hr>
<h4 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h4><p>类方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span><span class="params">(cls)</span>:</span> <span class="comment"># cls是什么</span></span><br><span class="line">        print(<span class="string">'class = &#123;0.__name__&#125; (&#123;0&#125;)'</span>.format(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"> </span><br><span class="line">Person.class_method()</span><br><span class="line">print(Person.__dict__)</span><br></pre></td></tr></table></figure>
<p>类方法</p>
<ol>
<li>在类定义中，使用@classmethod装饰器修饰的方法，不管使用实例还是类来调用，调用的都是类的方法，传入当前类自身。</li>
<li>必须至少有一个参数，且第一个参数留给了cls，cls指代调用者即<font color="red"><strong>类对象自身</strong></font></li>
<li><p>cls这个标识符可以是任意合法名称，但是为了易读，请不要修改</p>
</li>
<li><p>通过cls可以直接操作类的属性</p>
</li>
</ol>
<p>静态方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self,name)</span>： #普通方法</span></span><br><span class="line"><span class="function">    	<span class="title">print</span><span class="params">(self)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    @<span class="title">classmethod</span>   #类方法</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">class_method</span><span class="params">(cls ， age)</span>:</span>  <span class="comment"># cls是什么  是当前类</span></span><br><span class="line">        print(<span class="string">'class = &#123;0.__name__&#125; (&#123;0&#125;)'</span>.format(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  #静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_methd</span><span class="params">(a)</span>:</span></span><br><span class="line">        print(Person.HEIGHT , a)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Person.method(Person(),<span class="string">"ken"</span>)  <span class="comment">#第一参数不会自动传入，自己传Person（）</span></span><br><span class="line">Person().method(<span class="string">"tom"</span>)  <span class="comment">#第一参数自动传入Person（）</span></span><br><span class="line"></span><br><span class="line">Person.class_method(<span class="number">20</span>)  <span class="comment">#第一参数cls自动传入</span></span><br><span class="line">Person().method(<span class="number">18</span>)  <span class="comment">#第一参数cls自动传入</span></span><br><span class="line"></span><br><span class="line">Person.static_methd()   <span class="comment">#第一参数不用传</span></span><br><span class="line">Person().static_method()  <span class="comment">#第一参数不用传</span></span><br><span class="line"></span><br><span class="line">print(Person.__dict__)</span><br></pre></td></tr></table></figure>
<p>静态方法</p>
<ol>
<li>在类定义中，使用@staticmethod装饰器修饰的方法</li>
<li>调用时，不管是实例还是类调用，不会隐式的传入参数 。<br> 静态方法，只是表明这个方法属于这个名词空间。函数归在一起，方便组织管理。</li>
</ol>
<p>总结：<br>类除了普通方法都可以调用，普通方法需要对象的实例作为第一参数。<br>实例可以调用所有类中定义的方法（包括类方法、静态方法），普通方法传入实例自身，静态方法和类方法需要找到实例的类。</p>
<p>实例方法</p>
<p>如果用实例，第一参数则传入self，则叫做绑定。如果使用类调用，则没有绑定（未绑定行为）。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h5 id="私有-Private-属性"><a href="#私有-Private-属性" class="headerlink" title="私有(Private)属性"></a>私有(Private)属性</h5><p>使用双下划线开头的属性名，就是私有属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span><span class="params">(self, i=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>: <span class="comment"># 控制逻辑</span></span><br><span class="line">            self.__age += i</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"> </span><br><span class="line">print(Person(<span class="string">'tom'</span>).getage())</span><br></pre></td></tr></table></figure></p>
<p>私有变量的本质：<br>类定义的时候，如果声明一个实例变量的时候，使用双下划线，Python解释器会将其改名，转换名称为<strong>_类名__变量名</strong>的名称，所以用原来的名字访问不到了。</p>
<h5 id="保护变量"><a href="#保护变量" class="headerlink" title="保护变量"></a>保护变量</h5><p>在变量名前使用一个下划线，称为保护变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"> </span><br><span class="line">tom = Person(<span class="string">'Tom'</span>)</span><br><span class="line">print(tom._age)</span><br><span class="line">print(tom.__dict__)</span><br></pre></td></tr></table></figure>
<p>可以看出，这个_age属性根本就没有改变名称，和普通的属性一样，解释器不做任何特殊处理。 这只是开发者共同的约定，看见这种变量，就如同私有变量，不要直接使用。</p>
<h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><p>参照保护变量、私有变量，使用单下划线、双下划线命名方法。</p>
<p>私有方法的本质 </p>
<p>单下划线的方法只是开发者之间的约定，解释器不做任何改变。 </p>
<p>双下划线的方法，是私有方法，解释器会改名，改名策略和私有变量相同，<strong>_类名__方法名 </strong>。<br>方法变量都在类的<strong>__dict__</strong>中可以找到。</p>
<p>私有成员的总结 :</p>
<p>在Python中使用<em>单下划线或者 \</em>_ 双下划线来标识一个成员被保护或者被私有化隐藏起来。<br>但是，不管使用什么样的访问控制，都不能真正的阻止用户修改类的成员。Python中没有绝对的安全的保护成员或者私有成员。<br>因此，前导的下划线只是一种警告或者提醒，请遵守这个约定。除非真有必要，不要修改或者使用保护成员或者私有成员，更不要修改它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getname</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"> </span><br><span class="line">tom = Person(<span class="string">'Tom'</span>)</span><br><span class="line">print(tom._getname()) <span class="comment"># 没改名</span></span><br><span class="line">print(tom.__getage()) <span class="comment"># 无此属性</span></span><br><span class="line">print(tom.__dict__)</span><br><span class="line">print(tom.__class__.__dict__)</span><br><span class="line">print(tom._Person__getage()) <span class="comment"># 改名了</span></span><br></pre></td></tr></table></figure>
<h4 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h4><p>可以通过修改或者替换类的成员。使用者调用的方式没有改变，但是，类提供的功能可能已经改变了。</p>
<p>猴子补丁（Monkey Patch）：<br>在运行时，对属性、方法、函数等进行动态替换。<br>其目的往往是为了通过替换、修改来增强、扩展原有代码的能力。<br>黑魔法，慎用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> Person</span><br><span class="line"><span class="keyword">from</span> test3 <span class="keyword">import</span> get_score</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monkeypatch4Person</span><span class="params">()</span>:</span></span><br><span class="line">    Person.get_score = get_score</span><br><span class="line"> </span><br><span class="line">monkeypatch4Person() <span class="comment"># 打补丁</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(Person().get_score())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># connect to mysql</span></span><br><span class="line">        ret = &#123;<span class="string">'English'</span>:<span class="number">78</span>, <span class="string">'Chinese'</span>:<span class="number">86</span>, <span class="string">'History'</span>:<span class="number">82</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test3.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> dict(name=self.__class__.__name__,English=<span class="number">88</span>, Chinese=<span class="number">90</span>, History=<span class="number">85</span>)</span><br></pre></td></tr></table></figure>
<p>上例中，假设Person类get_score方法是从数据库拿数据，但是测试的时候，不方便。<br>为了测试时方便，使用猴子补丁，替换了get_score方法，返回模拟的数据。</p>
<h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><p>一般好的设计是：把实例的属性保护起来，不让外部直接访问，外部使用getter读取属性和setter方法设置属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># del self.__age</span></span><br><span class="line">        print(<span class="string">'del'</span>)</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">'Tom'</span>)</span><br><span class="line">print(tom.age)</span><br><span class="line">tom.age = <span class="number">20</span></span><br><span class="line">print(tom.age)</span><br><span class="line"><span class="keyword">del</span> tom.age</span><br></pre></td></tr></table></figure>
<p>特别注意：使用property装饰器的时候这三个方法<strong>同名</strong><br>property装饰器<br>后面跟的函数名就是以后的属性名。它就是getter。这个必须有，有了它至少是只读属性</p>
<p>setter装饰器<br>与属性名同名，且接收2个参数，第一个是self，第二个是将要赋值的值。有了它，属性可写</p>
<p>deleter装饰器<br>可以控制是否删除属性。很少用</p>
<p>property装饰器必须在前，setter、deleter装饰器在后。<br>property装饰器能通过简单的方式，把对方法的操作变成对属性的访问，并起到了一定隐藏效果.</p>
<h4 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h4><p>类中可以定义 __del__ 方法，称为析构函数（方法）。</p>
<p>作用：销毁类的实例的时候调用，以释放占用的资源。其中就放些清理资源的代码，比如释放连接。</p>
<p>注意这个方法不能引起对象的真正销毁，只是对象销毁的时候会自动调用它。</p>
<p>使用del语句删除实例，引用计数减1。当引用计数为0时，会自动调用__del__ 方法。<br>由于Python实现了垃圾回收机制，不能确定对象何时执行垃圾回收。</p>
<p>由于垃圾回收对象销毁时，才会真正清理对象，还会在回收对象之前自动调用__del__ 方法，除非你明确知道自己的目的，建议不要手动调用这个方法。</p>
<h4 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h4><p>其他面向对象的高级语言中，会有重载的概念。<br>所谓重载，就是同一个方法名，但是参数数量、类型不一样，就是同一个方法的重载。</p>
<p>Python没有重载！<br>Python不需要重载！<br>Python中，方法（函数）定义中，形参非常灵活，不需要指定类型（就算指定了也只是一个说明而非约束），参数个数也不固定（可变参数）。一个函数的定义可以实现很多种不同形式实参的调用。所以Python不需要方法的重载。</p>
<p>或者说Python本身就实现了其它语言的重载。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>面向对象的三要素之一，封装Encapsulation</p>
<p>将数据和操作组织到类中，即属性和方法 </p>
<p>将数据隐藏起来，给使用者提供操作（方法）。使用者通过操作就可以获取或者修改数据。getter和setter。 </p>
<p>通过访问控制，暴露适当的数据和操作给用户，该隐藏的隐藏起来，例如保护成员或私有成员。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">https://luoqian67.github.io/blog/</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/blog/2017/10/11/14python面向对象-特殊属性、查看属性、魔术方法/" class="pre-post btn btn-default" title="python面向对象-特殊属性、查看属性、魔术方法">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">python面向对象-特殊属性、查看属性、魔术方法</span>
        </a>
    
    
        <a href="/blog/2017/09/30/12python直接赋值、深拷贝和浅拷贝/" class="next-post btn btn-default" title="python直接赋值、深拷贝和浅拷贝">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">python直接赋值、深拷贝和浅拷贝</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/blog/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xme1rFxnnyLwK8UFBgckpusw-gzGzoHsz',
            appKey: 'u9MbOVN8LcSmPkewWeQKtEnJ',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象三要素"><span class="toc-text">面向对象三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例对象instance"><span class="toc-text">实例对象instance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例变量和类变量"><span class="toc-text">实例变量和类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰一个类"><span class="toc-text">装饰一个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类方法和静态方法"><span class="toc-text">类方法和静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问控制"><span class="toc-text">访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#私有-Private-属性"><span class="toc-text">私有(Private)属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#保护变量"><span class="toc-text">保护变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#私有方法"><span class="toc-text">私有方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#补丁"><span class="toc-text">补丁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性装饰器"><span class="toc-text">属性装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的销毁"><span class="toc-text">对象的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法重载-overload"><span class="toc-text">方法重载(overload)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>






    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/blog/js/app.js?rev=@@hash"></script>

</body>
</html>