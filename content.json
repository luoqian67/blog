{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"Luo Qian","url":"http://luoqian67.github.io/blog"},"pages":[],"posts":[{"title":"python-反射、描述器","slug":"15python反射、描述器","date":"2017-10-18T16:00:00.000Z","updated":"2018-12-11T12:46:16.937Z","comments":true,"path":"2017/10/19/15python反射、描述器/","link":"","permalink":"http://luoqian67.github.io/blog/2017/10/19/15python反射、描述器/","excerpt":"","text":"反射概述运行时，区别于编译时，指的是程序被加载到内存中执行的时候。反射，reflection，指的是运行时获取类型定义信息。简单说，在Python中，能够通过一个对象，找出其type、class、attribute或method的能力，称为反射或者自省。具有反射能力的函数有：type()、isinstance()、callable()、dir()、getattr() 内建函数 意义 getattr(object, name[, default]) 通过name返回object的属性值。当属性不存在，将使用default返回，如果没有default，则抛出AttributeError。name必须为字符串 setattr(object, name, value) object的属性存在，则覆盖，不存在，新增 hasattr(object, name) 判断对象是否有这个名字的属性，name必须为字符串 给一个实例用setattr添加一个方法，不做绑定，不会绑定到类中，此时不能用类调用，然而类使用setattr方法，会把那个方法绑定到类的字典上。 思考这种动态增加属性的方式和装饰器修饰一个类、Mixin方式的差异？ 这种动态增删属性的方式是运行时改变类或者实例的方式，但是装饰器或Mixin都是定义时就决定了，因此反射能力具有更大的灵活性。 反射相关的魔术方法__getattr__()、__setattr__()、__delattr__()这三个魔术方法。 魔术方法 意义 __getattr__() 当通过搜索实例、实例的类及祖先类查不到属性，就会调用此方法 __setattr__() 通过.访问实例属性，进行增加、修改都要调用它 __delattr__() 当通过实例来删除属性时调用此方法 __getattribute__() 实例所有的属性调用都从这个方法开始 一个类的属性会按照继承关系找，如果找不到，就会执行__getattr__() 方法，如果没有这个方法，就会抛出AttributeError异常表示找不到属性。查找属性顺序为：实例调用__getattribute__() –&gt;instance.__dict__ –&gt;instance.__class__.__dict__ –&gt; 继承的祖先类（直到object）的__dict__—找不到–&gt; 调用__getattr__() 123456789101112131415class Point(Base): z = 6 def __init__(self, x, y): self.x = x self.y = y def show(self): print(self.x, self.y) def __getattr__(self, item): return \"missing &#123;&#125;\".format(item) def __setattr__(self, key, value): print(\"setattr &#123;&#125;=&#123;&#125;\".format(key,value)) self.__dict__[key] = value __setattr__()方法，可以拦截对实例属性的增加、修改操作，如果要设置生效，需要自己操作实例的__dict__。 __getattribute__方法 实例的所有的属性访问，第一个都会调用__getattribute__方法，它阻止了属性的查找，该方法应该返回（计算后的）值或者抛出一个AttributeError异常。 它的return值将作为属性查找的结果。 如果抛出AttributeError异常，则会直接调用__getattr__方法，因为表示属性没有找到。 __getattribute__方法中为了避免在该方法中无限的递归，它的实现应该永远调用基类的同名方法以访问需要的任何属性，例如object.__getattribute__(self, name)。注意，除非你明确地知道__getattribute__方法用来做什么，否则不要使用它。 描述器描述器的表现用到3个魔术方法:__get__()、__set__()、__delete__()方法签名如下object.__get__(self, instance, owner)object.__set__(self, instance, value)object.__delete__(self, instance)self 指代当前实例，调用者instance 是owner的实例owner 是属性的所属的类 描述器定义Python中，一个类实现了__get__、__set__、__delete__三个方法中的任何一个方法，就是描述器。如果仅实现了__get__，就是非数据描述符 non-data descriptor；同时实现了__get__、__set__就是数据描述符 data descriptor 如果一个类的类属性设置为描述器实例，那么它被称为owner属主。 属性查找顺序实例的__dict__ 优先于非数据描述器数据描述器优先于实例的__dict____delete__方法有同样的效果，有了这个方法，也是数据描述器。 Python中的描述器 Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖方法。这允许单个实例获取与同一类的其他实例不同的行为。 property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。 123456789101112131415161718192021222324252627class A: @classmethod # 非数据描述器 def foo(cls): pass @staticmethod # 非数据描述器 def bar(): pass @property # 数据描述器 def z(self): return 5 def getfoo(self): # 非数据描述器 return self.foo def __init__(self): # 非数据描述器 self.foo = 100 self.bar = 200 #self.z = 300 a = A()print(a.__dict__)print(A.__dict__)#foo、bar都可以在实例中覆盖，但是z不可以。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python面向对象-特殊属性、查看属性、魔术方法","slug":"14python面向对象-特殊属性、查看属性、魔术方法","date":"2017-10-10T16:00:00.000Z","updated":"2018-12-11T11:04:23.152Z","comments":true,"path":"2017/10/11/14python面向对象-特殊属性、查看属性、魔术方法/","link":"","permalink":"http://luoqian67.github.io/blog/2017/10/11/14python面向对象-特殊属性、查看属性、魔术方法/","excerpt":"","text":"特殊属性 属性 含义 __name_ 类、函数、方法等的名字 __module_ 类定义所在的模块名 __class_ 对象或者类所属的类 __bases__ 类的基类的元组，顺序为它们在基类列表中出现的顺序 __doc__ 类、函数的文档字符串，如果没有定义则为None __mro__ 类的mro，class.mro()返回的结果保存在__mro__中 __dict__ 类的实例的属性，可写的字典 查看属性 方法 意义 __dir__ 返回类或者对象的所有成员名称列表。dir()函数就是调用__dir__()。 使用实例调用时，如果提供__dir__()，则返回其返回值，要求是可迭代对象。 如果没有提供__dir__()，则会从实例和类及祖先类中收集信息（尽可能多的） 如果dir([obj])参数obj包含方法__dir__()，该方法将被调用。如果参数obj不包含__dir__()，该方法将最大限度地收集属性信息。 dir(obj)对于不同类型的对象obj具有不同的行为： 如果对象是模块对象，返回的列表包含模块的属性名和变量名。 如果对象是类或者类对象，返回的列表包含类的属性名，及它的基类的属性名。 如果obj不写，返回列表包含内容不同 在模块中，返回模块的属性和变量名 在函数中，返回本地作用域的变量名 在方法中，返回本地作用域的变量名 魔术方法 分类： 创建、初始化和销毁 __new__和__init__和__del__ hash bool 可视化 运算符重载 容器和大小 可调用对象 上下文管理 反射 描述器 其他 实例化 方法 意义 __new__ 实例化一个对象该方法需要返回一个值(本类型的实例)，如果该值不是cls的实例，则不会调用__init__该方法永远都是静态 __new__方法很少使用，即使创建了该方法，也会使用return super().__new__(cls)得到实例化对象，或者基类object的__new__方法来创建实例并返回。 hash 方法 意义 __hash__ 内建函数hash()调用的返回值，返回一个整数。如果定义这个方法该类的实例就可hash。 __eq__ 对应==操作符，判断2个对象是否相等，返回bool值 1234567891011121314151617class A: def __init__(self, name, age=18): self.name = name def __hash__(self): return 1 def __eq__(self, other): return self.name == other.name def __repr__(self): return self.name print(hash(A('tom')))print((A('tom'), A('tom')))print([A('tom'), A('tom')])print(&#123;('tom',), ('tom',)&#125;) hash(x) ,x都一样，求得的hash应该是不变的，这是幂等性的缘故，一般来说，x不一样，hash应该不一样。 不同的hash算法，不同的x求得同样的hash值，这就是hash冲突。 __hash__方法只是返回一个hash值作为set的key，但是去重，还需要__eq__（等效==，就是内容相等）来判断2个对象是否相等，is判断的是内存地址，is相等的话就肯定是同一个元素。hash值相等，只是hash冲突，不能说明两个对象是相等的。因此，一般来说提供__hash__方法是为了作为set或者dict的key，所以去重要同时提供__eq__方法。 不可hash对象isinstance(p1, collections.Hashable)一定为False。去重需要提供__eq__方法。 list类实例为什么不可hash 源码中有一句__hash__ = None，也就是如果调用__hash__()相当于None()，一定报错。所有类都继承object，而这个类是具有__hash__()方法的，如果一个类不能被hash，就把__hash__设置为None。 bool 方法 意义 __bool__ 内建函数bool()，或者对象放在逻辑表达式的位置，调用这个函数返回布尔值。 定义__bool__()，这个函数的返回值必须要是bool类型。没有定义__bool__()，就找__len__()返回长度，非0为真。 如果__len__()也没有定义，那么所有实例都返回真。 两个对象（类和实例）可以当作True理解。 等效Fals的本质是：对于四大皆空：空串，空元组。空列表，空字典，先找bool，如果没有bool就看长度，当长度为0就恒为假。 可视化 方法 意义 __repr__ 内建函数repr()对一个对象获取字符串表达。 调用__repr__方法返回字符串表达，如果__repr__也没有定义，就直接返回object的定义，就是显示内存地址信息。 __str__ str()函数、format()函数、print()函数调用，需要返回对象的字符串表达。如果没有定义，就去调用__repr__方法返回字符串表达，如果__repr__没有定义，就直接返回对象的内存地址信息。 __bytes__ bytes()函数调用，返回一个对象的bytes表达，即返回bytes对象 123456789101112131415161718192021class A: def __init__(self, name, age=18): self.name = name self.age = age def __repr__(self): return 'repr: &#123;&#125;,&#123;&#125;'.format(self.name, self.age) def __str__(self): return 'str: &#123;&#125;,&#123;&#125;'.format(self.name, self.age) def __bytes__(self): #return \"&#123;&#125; is &#123;&#125;\".format(self.name, self.age).encode() import json return json.dumps(self.__dict__).encode() print(A('tom')) # print函数使用__str__print([A('tom')]) # []使用__str__，但其内部使用__repr__print([str(A('tom'))]) # []使用__str__，其中的元素使用str()函数也调用__str__print(bytes(A('tom'))) 总结：一般首先找的是repr，当repr没有就找str，都没有就去object中去寻找。bytes方法转成二进制只是一种序列化的表达，和序列化还是有差别的，序列化是一种通用的二进制格式或者通用的中间格式，序列化是一种交互，转化成文本传输的，而这里的转换只是一种表达，给人展示用的。 注意不能通过判断是否带引号来判断输出值的类型，类型判断要使用type或isinstance 运算符重载 operator模块提供了以下特殊方法，可以将类的实例使用下面的操作符来操作 运算符 特殊方法 含义 &lt;, &lt;=, ==, &gt;, &gt;=, != __lt__, __le__, __eq__, __gt__, __ge__, __ne__ 比较运算符 +, -, *, /, %, //,**, divmod __add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__ 算数运算符 +=, -=, *=, /=, %=, //=, **= __iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__,__ipow__ @functools.total_ordering 装饰器__lt__, __le__, __eq__, __gt__, __ge__是比较大小必须实现的方法，但是全部写完太麻烦，使用@functools.total_ordering 装饰器就可以大大简化代码。 但是要求__eq__必须实现，其它方法__lt__, __le__, __gt__, __ge__ 实现其一。 但是： __eq__等于可以推断不等于__gt__大于可以推断小于__ge__大于等于可以推断小于等于也就是用3个方法，就可以把所有比较解决了，所以total_ordering可以不使用 容器相关方法 方法 意义 __len__ 内建函数len()，返回对象的长度（&gt;=0的整数），如果把对象当做容器类型看，就如同list或者dict。bool()函数调用的时候，如果没有__bool__()方法，则会看__len__()方法是否存在，存在返回非0为真。 __iter__ 迭代容器时，调用，返回一个新的迭代器对象 __contains__ in 成员运算符，没有实现，就调用__iter__方法遍历 __getitem__ 实现self[key]访问。序列对象，key接受整数为索引，或者切片。对于set和dict，key为hashable。key不存在引发KeyError异常 __setitem__ 和__getitem__的访问类似，是设置值的方法 __missing__ 字典或其子类使用__getitem__()调用时，key不存在执行该方法 1234567class A(dict): def __missing__(self, key): print('Missing key : ', key) return 0 a = A()print(a['k']) 可调用对象 123456def foo(): print(foo.__module__, foo.__name__) foo()# 等价于foo.__call__() 函数即对象，对象foo加上()，就是调用此函数对象的__call__()方法。 可调用对象 方法 意义 __call__ 类中定义一个方法，实例就可以像函数一样调用 1234567891011121314151617181920212223242526272829class Point: def __init__(self, x, y): self.x = x self.y = y def __call__(self, *args, **kwargs): return \"&lt;Point &#123;&#125;:&#123;&#125;&gt;\".format(self.x, self.y) p = Point(4, 5)print(p)print(p()) class Adder: def __call__(self, *args): ret = 0 for x in args: ret += x self.ret = ret return ret adder = Adder()print(adder(4, 5, 6))print(adder.ret)#&lt;__main__.Point object at 0x000002D5F04C2198&gt;#&lt;Point 4:5&gt;#15#15 练习: 定义一个斐波那契数列的类，方便调用，计算第n项 123456789101112131415class Fib: def __init__(self): self.items = [0, 1, 1] def __call__(self, index): if index &lt; 0: raise IndexError('Wrong Index') if index &lt; len(self.items): return self.items[index] for i in range(3, index+1): self.items.append(self.items[i-1] + self.items[i-2]) return self.items[index] print(Fib()(100)) 上例中，增加迭代的方法、返回容器长度、支持索引的方法 1234567891011121314151617181920212223242526272829303132333435363738class Fib: def __init__(self): self.items = [0, 1, 1] def __call__(self, index): return self[index] def __iter__(self): return iter(self.items) def __len__(self): return len(self.items) def __getitem__(self, index): if index &lt; 0: raise IndexError(\"Wrong Index\") if index &lt; len(self.items): return self.items[index] for i in range(len(self), index + 1): self.items.append(self.items[i - 1] + self.items[i - 2]) return self.items[index] def __str__(self): return str(self.items) __repr__ = __str__fib = Fib()print(fib(5), len(fib)) # 全部计算print(fib(10), len(fib)) # 部分计算print(\"------\")for x in fib: print(x, end=\" \")print()print(fib[5], fib[9]) # 索引访问，不计算 上下文管理对象 当一个对象同时实现了__enter__（）和__exit__（）方法，它就属于上下文管理的对象。 方法 意义 __enter__ 进入与此对象相关的上下文。如果存在该方法，with语法会把该方法的返回值作为绑定到as子句中指定的变量上 __exit__ 退出与此对象相关的上下文。 12345678910111213141516class Point: def __init__(self): print(\"init\") def __enter__(self): print(\"enter\") def __exit__(self, exc_type, exc_val, exc_tb): print(\"exit\")with Point() as f: print(\"-\" * 30) raise Exception('error')print(\"=====end=======\") 实例化对象的时候，并不会调用enter，进入with语句块调用__enter__方法，然后执行语句体，最后离开with语句块的时候，调用__exit__方法。 with可以开启一个上下文运行环境，在执行前做一些准备工作，执行后做一些收尾工作。注意，with并不开启一个新的作用域。 上下文管理很安全，不管是碰到异常都还是会正常执行 __enter__方法返回值就是上下文中使用的对象，with语法会把它的返回值赋给as子句的变量。 方法的参数 __enter__方法 没有其他参数。__exit__方法有3个参数：__exit__(self, exc_type, exc_value, traceback)这三个参数都与异常有关。如果该上下文退出时没有异常，这3个参数都为None。如果有异常，参数意义如下exc_type，异常类型exc_value，异常的值traceback，异常的追踪信息__exit__方法返回一个等效True的值，则压制异常；否则，继续抛出异常 上下文应用场景 增强功能 在代码执行的前后增加代码，以增强其功能。类似装饰器的功能。 资源管理 打开了资源需要关闭，例如文件对象、网络连接、数据库连接等 权限验证 在执行代码之前，做权限的验证，在__enter__中处理 contextlib.contextmanager contextlib.contextmanager它是一个装饰器实现上下文管理，装饰一个函数，而不用像类一样实现__enter__和__exit__方法。对下面的函数有要求，必须有yield，也就是这个函数必须返回一个生成器，且只有yield一个值。也就是这个装饰器接收一个生成器对象作为参数。 1234567891011121314151617181920212223242526import contextlib@contextlib.contextmanagerdef sub(x, y): # 为生成器函数增加了上下文管理 print(\"enter\") start = datetime.datetime.now() try: yield x - y # yield的值只能有一个，作为__enter__方法的返回值 finally: detla = (datetime.datetime.now() - start).total_seconds() print(detla) print(\"exit\")with sub(6, 2) as f: time.sleep(2) print(\"------------\") print(f) print(\"~~~~~~~~~~\") #输出enter------------4~~~~~~~~~~2.000654exit 当yield发生处为生成器函数增加了上下文管理。这是为函数增加上下文机制的方式。 把yield之前的当做__enter__方法执行 把yield之后的当做__exit__方法执行 把yield的值作为__enter__的返回值 总结 :如果业务逻辑简单可以使用函数加contextlib.contextmanager装饰器方式，如果业务复杂，用类的方式加__enter__和__exit__方法方便。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-面向对象","slug":"13python面向对象基础","date":"2017-09-30T16:00:00.000Z","updated":"2018-12-07T14:22:31.538Z","comments":true,"path":"2017/10/01/13python面向对象基础/","link":"","permalink":"http://luoqian67.github.io/blog/2017/10/01/13python面向对象基础/","excerpt":"","text":"面向对象 一种认识世界，分析世界的方法论。将万事万物抽象为类 类class 类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。用计算机语言来描述就是属性和方法的集合（封装）。 对象instance、object，对象是类的具象，是一个实体，类也是对象。 属性，它是对象状态的抽象，用数据结构来描述。 操作，是对对象行为的抽象，用操作名和实现该操作的方法来描述。 哲学 一切皆对象 对象是数据和操作的封装 对象是独立的，但是对象之间可以相互作用 目前OOP是最接近人类认知的编程范式 面向对象三要素封装：将属性和方法组装到一起，隐藏数据，对外只暴露一些接口用于连接。继承：目的：多复用，继承来的就不用自己写了；多继承少修改（开闭原则），OCP(open_closed principle)，使用继承来改变。作用：就是为了修改不一样的属性。多态：面向对象编程最灵活的地方，多种表现，动态绑定。#### Python的类定义：12class ClassName： 语句块要求：1. 必须使用class关键字2. 类名必须使用大驼峰命名3. 类定义完成后会产生一个类对象，会绑定到ClassName这个标识符上面。#### 类对象和类属性类对象，类的定义就会生成一个类对象类的属性，类定义中的变量和类中定义的方法都是类的属性类变量，定义在类中的变量#### 实例化在类对象名称后面加上一个括号，就调用类的实例化方法，完成实例化，实例化就真正创建一个该类的对象（实例）。每一次实例化，只能生成该类的一个具体实例，生成的是不同的实例。即使通过相同的参数实例化，得到的对象也不相同。python类实例化后，会自动调用__init__方法，可以不定义，如果没有定义会在实例化后隐式调用，初始化函数可以有多个参数，第一参数必须留给self，init方法不能有返回值，也就是只能有return None作用：对实例进行初始化 类里面的函数叫做方法对象method，不是普通的函数对象function，一般至少要有一个参数，第一个参数可以是self（一般习惯上用self），这个参数位置指代的就是当前这个实例本身。 实例对象instance类实例化后一定会获得一个对象，就是实例对象。init方法的第一个参数self就是指代某一个实例。 实例变量和类变量实例变量是每个实例自己的变量，是自己独有的；列变量是类的变量，是类的所有实例共享的属性和方法。 特殊属性 含义 __name__ 对象名 __class__ 对象的类型 __dict__ 对象的属性的字典 __qualname__ 类的限定名 类属性保存在类的dict中，实例属性保存在实例的dict中，如果从实例访问类的属性，就要借助class找到所属的类。 类有类名字，实例没有实体名。 python中每一种对象都拥有不同的属性。函数、类都是对象，类的实例也是对象。 类不可以访问实例的属性，实例可以访问类的属性。（是类的，也是这个类所有实例的，其实例都可以访问到；是实例的，就是这个实例自己的，通过类访问不到。） 对象（实例或类）可以动态的给自己增加一个属性，实例.__dict__[变量名]可以访问到，实例的同名变量会隐藏掉类变量，或者说是覆盖了这个类的变量。 一般来说，属性使用字典保存是为了提升查找效率，必须用空间换时间，但是也有个问题，如果数百万个对象，那么字典占的比较大，所以可以使用__slots__方法。 slots告诉解释器，实例的属性都叫什么，一般来说，既然要节省内存，那就最好还是使用元组。 一旦类提供了slots，就阻止实例产生dict来保存实例的属性。子类不会继承slots 12345678910111213141516class A: X = 1 __slots__ = ('z','y') def __init__(self): self.y = 5 def show(self): print(self.X,self.y)a = A()a.show()print(\"A\",A.__dict__.keys())# print(\"obj\",a.__dict__.keys()) 实例属性的查找顺序 指的是实例使用.点号来访问属性，会先找实例自己的_dict\\_，如果没有，然后通过属性__class__找到自己的类，再去类的__dict__中找类属性中没找到就往类继承的父类中去查找，最终找到根基类object，没找到则抛出异常 。注意，如果实例使用__dict__[变量名]访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的key查找，不是属性查找。一般来说，类变量可使用全大写来命名。 装饰一个类为一个类通过装饰，添加一些类属性。 1234567891011121314151617#增加类变量def adda_name(name,cls): cls.NAME = name #动态增加类属性#改进成装饰器def add_name(name): def wrapper(cls): cls.NAME = name return cls return wrapper@add_name(\"jerry\")class Person(): #Person = add_name(\"jerry\")(Person) = wrapper(person) = Person AGE = 3# adda_name(Person ,\"tom\") print(Person.__dict__)print(Person.NAME) 之所以能够装饰，本质上是为类对象动态的添加了一个属性，而Person这个标识符指向这个类对象。 类方法和静态方法类方法 12345678class Person: @classmethod def class_method(cls): # cls是什么 print('class = &#123;0.__name__&#125; (&#123;0&#125;)'.format(cls)) cls.HEIGHT = 170 Person.class_method()print(Person.__dict__) 类方法 在类定义中，使用@classmethod装饰器修饰的方法，不管使用实例还是类来调用，调用的都是类的方法，传入当前类自身。 必须至少有一个参数，且第一个参数留给了cls，cls指代调用者即类对象自身 cls这个标识符可以是任意合法名称，但是为了易读，请不要修改 通过cls可以直接操作类的属性 静态方法 123456789101112131415161718192021222324class Person: def method(self,name)： #普通方法 print(self) @classmethod #类方法 def class_method(cls ， age): # cls是什么 是当前类 print('class = &#123;0.__name__&#125; (&#123;0&#125;)'.format(cls)) cls.HEIGHT = 170 @staticmethod #静态方法 def static_methd(a): print(Person.HEIGHT , a) Person.method(Person(),\"ken\") #第一参数不会自动传入，自己传Person（）Person().method(\"tom\") #第一参数自动传入Person（）Person.class_method(20) #第一参数cls自动传入Person().method(18) #第一参数cls自动传入Person.static_methd() #第一参数不用传Person().static_method() #第一参数不用传print(Person.__dict__) 静态方法 在类定义中，使用@staticmethod装饰器修饰的方法 调用时，不管是实例还是类调用，不会隐式的传入参数 。 静态方法，只是表明这个方法属于这个名词空间。函数归在一起，方便组织管理。 总结：类除了普通方法都可以调用，普通方法需要对象的实例作为第一参数。实例可以调用所有类中定义的方法（包括类方法、静态方法），普通方法传入实例自身，静态方法和类方法需要找到实例的类。 实例方法 如果用实例，第一参数则传入self，则叫做绑定。如果使用类调用，则没有绑定（未绑定行为）。 访问控制私有(Private)属性使用双下划线开头的属性名，就是私有属性12345678910111213class Person: def __init__(self, name, age=18): self.name = name self.__age = age def growup(self, i=1): if i &gt; 0 and i &lt; 150: # 控制逻辑 self.__age += i def getage(self): return self.__age print(Person('tom').getage()) 私有变量的本质：类定义的时候，如果声明一个实例变量的时候，使用双下划线，Python解释器会将其改名，转换名称为_类名__变量名的名称，所以用原来的名字访问不到了。 保护变量在变量名前使用一个下划线，称为保护变量。 12345678class Person: def __init__(self, name, age=18): self.name = name self._age = age tom = Person('Tom')print(tom._age)print(tom.__dict__) 可以看出，这个_age属性根本就没有改变名称，和普通的属性一样，解释器不做任何特殊处理。 这只是开发者共同的约定，看见这种变量，就如同私有变量，不要直接使用。 私有方法参照保护变量、私有变量，使用单下划线、双下划线命名方法。 私有方法的本质 单下划线的方法只是开发者之间的约定，解释器不做任何改变。 双下划线的方法，是私有方法，解释器会改名，改名策略和私有变量相同，_类名__方法名 。方法变量都在类的__dict__中可以找到。 私有成员的总结 : 在Python中使用单下划线或者 \\_ 双下划线来标识一个成员被保护或者被私有化隐藏起来。但是，不管使用什么样的访问控制，都不能真正的阻止用户修改类的成员。Python中没有绝对的安全的保护成员或者私有成员。因此，前导的下划线只是一种警告或者提醒，请遵守这个约定。除非真有必要，不要修改或者使用保护成员或者私有成员，更不要修改它们。 1234567891011121314151617class Person: def __init__(self, name, age=18): self.name = name self._age = age def _getname(self): return self.name def __getage(self): return self._age tom = Person('Tom')print(tom._getname()) # 没改名print(tom.__getage()) # 无此属性print(tom.__dict__)print(tom.__class__.__dict__)print(tom._Person__getage()) # 改名了 补丁可以通过修改或者替换类的成员。使用者调用的方式没有改变，但是，类提供的功能可能已经改变了。 猴子补丁（Monkey Patch）：在运行时，对属性、方法、函数等进行动态替换。其目的往往是为了通过替换、修改来增强、扩展原有代码的能力。黑魔法，慎用。 1234567891011# test1.pyfrom test2 import Personfrom test3 import get_score def monkeypatch4Person(): Person.get_score = get_score monkeypatch4Person() # 打补丁 if __name__ == \"__main__\": print(Person().get_score()) 123456# test2.pyclass Person: def get_score(self): # connect to mysql ret = &#123;'English':78, 'Chinese':86, 'History':82&#125; return ret 123# test3.pydef get_score(self): return dict(name=self.__class__.__name__,English=88, Chinese=90, History=85) 上例中，假设Person类get_score方法是从数据库拿数据，但是测试的时候，不方便。为了测试时方便，使用猴子补丁，替换了get_score方法，返回模拟的数据。 属性装饰器一般好的设计是：把实例的属性保护起来，不让外部直接访问，外部使用getter读取属性和setter方法设置属性。 1234567891011121314151617181920212223class Person: def __init__(self, name, age=18): self.name = name self.__age = age @property def age(self): return self.__age @age.setter def age(self, age): self.__age = age @age.deleter def age(self): # del self.__age print('del')tom = Person('Tom')print(tom.age)tom.age = 20print(tom.age)del tom.age 特别注意：使用property装饰器的时候这三个方法同名property装饰器后面跟的函数名就是以后的属性名。它就是getter。这个必须有，有了它至少是只读属性 setter装饰器与属性名同名，且接收2个参数，第一个是self，第二个是将要赋值的值。有了它，属性可写 deleter装饰器可以控制是否删除属性。很少用 property装饰器必须在前，setter、deleter装饰器在后。property装饰器能通过简单的方式，把对方法的操作变成对属性的访问，并起到了一定隐藏效果. 对象的销毁类中可以定义 __del__ 方法，称为析构函数（方法）。 作用：销毁类的实例的时候调用，以释放占用的资源。其中就放些清理资源的代码，比如释放连接。 注意这个方法不能引起对象的真正销毁，只是对象销毁的时候会自动调用它。 使用del语句删除实例，引用计数减1。当引用计数为0时，会自动调用__del__ 方法。由于Python实现了垃圾回收机制，不能确定对象何时执行垃圾回收。 由于垃圾回收对象销毁时，才会真正清理对象，还会在回收对象之前自动调用__del__ 方法，除非你明确知道自己的目的，建议不要手动调用这个方法。 方法重载(overload)其他面向对象的高级语言中，会有重载的概念。所谓重载，就是同一个方法名，但是参数数量、类型不一样，就是同一个方法的重载。 Python没有重载！Python不需要重载！Python中，方法（函数）定义中，形参非常灵活，不需要指定类型（就算指定了也只是一个说明而非约束），参数个数也不固定（可变参数）。一个函数的定义可以实现很多种不同形式实参的调用。所以Python不需要方法的重载。 或者说Python本身就实现了其它语言的重载。 封装面向对象的三要素之一，封装Encapsulation 将数据和操作组织到类中，即属性和方法 将数据隐藏起来，给使用者提供操作（方法）。使用者通过操作就可以获取或者修改数据。getter和setter。 通过访问控制，暴露适当的数据和操作给用户，该隐藏的隐藏起来，例如保护成员或私有成员。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python直接赋值、深拷贝和浅拷贝","slug":"12python直接赋值、深拷贝和浅拷贝","date":"2017-09-30T12:15:17.000Z","updated":"2018-12-07T13:34:13.559Z","comments":true,"path":"2017/09/30/12python直接赋值、深拷贝和浅拷贝/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/30/12python直接赋值、深拷贝和浅拷贝/","excerpt":"","text":"python中，对象赋值实际上是对象的引用。当创建一个对象，将其赋值给另一个变量，python并没有拷贝这个对象，而是拷贝了这个对象的引用。 所以如果从单纯的赋值语句来实现clone对象的话， 那可能bug出现的也会莫名其妙. Python中可以使用copy模块来复制对象. copy.copy 为浅拷贝, 只copy父对象， 不会拷贝对象内部的子对象 copy.deepcopy 深拷贝, 拷贝对象及其子对象 1234567891011121314151617&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3,4,['a','b']]&gt;&gt;&gt; b = a # 赋值拷贝&gt;&gt;&gt; c = copy.copy(a) # 浅拷贝, 只拷贝了a的引用, 内部元素没有拷贝.&gt;&gt;&gt; d = copy.deepcopy(a) # 深拷贝, 完全拷贝&gt;&gt;&gt;&gt;&gt;&gt; a.append(5) &gt;&gt;&gt; a[4].append('c')&gt;&gt;&gt;&gt;&gt;&gt; print 'a=',aa= [1, 2, 3, 4, ['a', 'b', 'c'], 5]&gt;&gt;&gt; print 'b=',bb= [1, 2, 3, 4, ['a', 'b', 'c'], 5] #赋值拷贝, 内存地址指向一样的。 相当于一个人的两个名字而已.&gt;&gt;&gt; print 'c=',cc= [1, 2, 3, 4, ['a', 'b', 'c']] #浅拷贝, 子元素c[4]引用的地址和a[4]是一样的. 所以改变a[4]相当于改了c[4].&gt;&gt;&gt; print 'd=',dd= [1, 2, 3, 4, ['a', 'b']] #深拷贝完全拷贝. a和d完全改变了.","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-异常处理、模块化","slug":"11python异常处理、模块化","date":"2017-09-21T16:00:00.000Z","updated":"2018-12-11T08:36:37.710Z","comments":true,"path":"2017/09/22/11python异常处理、模块化/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/22/11python异常处理、模块化/","excerpt":"","text":"异常处理异常Exception 错误 Error ：错误是可以避免的逻辑错误：算法写错了，加法写成了减法笔误：变量名写错了，语法错误函数或类使用错误，其实这也属于逻辑错误 异常 Exception ：异常不可能避免本意就是意外情况这有个前提，没有出现上面说的错误，也就是说程序写的没有问题，但是在某些情况下，会出现一些意外，导致程序无法正常的执行下去。例如open函数操作一个文件，文件不存在，或者创建一个文件时已经存在了，或者访问一个网络文件，突然断网了，这就是异常，是个意外的情况。 错误和异常在高级编程语言中，一般都有错误和异常的概念，异常是可以捕获，并被处理的，但是错误是不能被捕获的。 产生异常 产生： raise 语句显式的抛出异常 Python解释器自己检测到异常并引发它 程序会在异常抛出的地方中断执行，如果不捕获，就会提前结束程序（其实是终止当前线程的执行） raise语句raise后什么都没有，表示抛出最近一个被激活的异常，如果没有，则抛类型异常。这种方式很少用 。 raise后要求应该是BaseException类的子类或实例，如果是类，将被无参实例化。 异常类及继承层次 12345678910111213141516171819202122232425262728293031323334353637# Python异常的继承 BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- RuntimeError | +-- RecursionError +-- MemoryError +-- NameError +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- LookupError | +-- IndexError | +-- KeyError +-- SyntaxError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError BaseException及子类 BaseException所有内建异常类的基类是BaseException SystemExitsys.exit(n)函数引发的异常，异常不捕获处理，就直接交给Python解释器，解释器退出。n=0,正常退出，n=1异常退出。 如果except语句捕获了该异常，则继续向后面执行，如果没有捕获住该异常SystemExit，解释器直接退出程序。 1234567891011121314import sys print('before')sys.exit(1)print('SysExit')print('outer') # 不执行# 捕获这个异常import systry: sys.exit(1)except SystemExit: # 换成Exception print('SysExit')print('outer') # 执行 KeyboardInterrupt对应的捕获用户中断行为Ctrl + C 12345678try: import time while True: time.sleep(0.5) passexcept KeyboardInterrupt: print('ctl + c')print('outer') Exception及子类Exception是所有内建的、非系统退出的异常的基类，自定义异常应该继承自它 SyntaxError 语法错误Python将这种错误也归到异常类下面的Exception下的子类，但是这种错误是不可捕获的 ArithmeticError 所有算术计算引发的异常，其子类有除零异常等 LookupError使用映射的键或序列的索引无效时引发的异常的基类：IndexError, KeyError 自定义异常从Exception继承的类 1234567class MyException(Exception): passtry: raise MyException()except MyException: # 捕获自定义异常 print('catch the exception') 未实现和未实现异常12345print(type(NotImplemented))print(type(NotImplementedError))#&lt;class 'NotImplementedType'&gt;#&lt;class 'type'&gt; NotImplemented是个值，单值，是NotImplementedType的实例 NotImplementedError是类型，是异常，返回type 异常的捕获 1234try: 待捕获异常的代码块except [异常类型]: 异常的处理代码块 使用了try…except语句块捕捉到了这个异常，异常生成位置之后语句将不再执行，转而执行对应的except部分的语句，最后执行try…except语句块之外的语句。 except 后接异常类型，用来捕获指定类型的异常，except可以捕获多个异常。 捕获规则捕获是从上到下依次比较，如果匹配，则执行匹配的except语句块如果被一个except语句捕获，其他except语句就不会再次捕获了如果没有任何一个except语句捕获到这个异常，则该异常向外抛出 捕获的原则从小到大，从具体到宽泛 被抛出的异常，应该是异常的实例，使用as子句接收这个抛出的异常。 finally子句 finally最终，即最后一定要执行的，try…finally语句块中，不管是否发生了异常，都要执行finally的部分 finally中一般放置资源的清理、释放工作的语句，也可以在finally中再次捕捉异常。 异常的传递 123456789def foo1():​ return 1/0def foo2():​ print('foo2 start')​ foo1()​ print('foo2 stop')foo2() foo2调用了foo1，foo1产生的异常，传递到了foo2中。异常总是向外层抛出，如果外层没有处理这个异常，就会继续向外抛出如果内层捕获并处理了异常，外部就不能捕获到了如果到了最外层还是没有被处理，就会中断异常所在的线程的执行。注意整个程序结束的状态返回值。 123456789101112131415161718192021222324# 线程中测试异常import threadingimport time def foo1(): return 1/0 def foo2(): time.sleep(3) # 3秒后抛出异常 print('foo2 start') foo1() print('foo2 stop') t = threading.Thread(target=foo2)t.start() while True: time.sleep(1) print('Everything OK') if t.is_alive(): print('alive') else: print('dead') try嵌套 内部捕获不到异常，会向外层传递异常但是如果内层有finally且其中有return、break语句，则异常就不会继续向外抛出：异常被压制。 12345678910111213141516try: try: ret = 1 / 0 except KeyError as e: print(e) finally: print('inner fin')except: print('outer catch')finally: print('outer fin')#输出 #inner fin#outer catch#outer fin 异常的捕获的时机1.立即捕获 需要立即返回一个明确的结果 1234567def parse_int(s): try: return int(s) except: return 0 print(parse_int('s')) 2.边界捕获 封装产生了边界 例如，写了一个模块，用户调用这个模块的时候捕获异常，模块内部不需要捕获、处理异常，一旦内部处理了，外部调用者就无法感知了。例如，open函数，出现的异常交给调用者处理，文件存在了，就不用再创建了，看是否修改还是删除例如，自己写了一个类，使用了open函数，但是出现了异常不知道如何处理，就继续向外层抛出，一般来说最外层也是边界，必须处理这个异常了，否则线程退出 else子句12345678try: ret = 1 * 0except ArithmeticError as e: print(e)else: print('OK')finally: print('fin') else子句没有任何异常发生，则执行 总结 12345678910try: &lt;语句&gt; #运行别的代码except &lt;异常类&gt;： &lt;语句&gt; # 捕获某种类型的异常except &lt;异常类&gt; as &lt;变量名&gt;: &lt;语句&gt; # 捕获某种类型的异常并获得对象else: &lt;语句&gt; #如果没有异常发生finally: &lt;语句&gt; #退出try时总会执行 try的工作原理 1、如果try中语句执行时发生异常，搜索except子句，并执行第一个匹配该异常的except子句2、如果try中语句执行时发生异常，却没有匹配的except子句，异常将被递交到外层的try，如果外层不处理这个异常，异常将继续向外层传递。如果都不处理该异常，则会传递到最外层，如果还没有处理，就终止异常所在的线程3、如果在try执行时没有发生异常，将执行else子句中的语句4、无论try中是否发生异常，finally子句最终都会执行。 模块化Python中只有一种模块对象类型，但是为了模块化组织模块的便利，提供了“包”的概念。模块module，指的是Python的源代码文件。 包package，指的是模块组织在一起的和包名同名的目录及其相关文件。 导入语句 语句 含义 import 模块1，[模块2….] 完全导入 import….as….. 模块别名 import语句 1、找到指定的模块，加载和初始化它，生成模块对象。找不到，抛出ImportError 2、在import所在的作用域的局部命名空间中，增加名称和上一步创建的对象关联。 总结 导入顶级模块，其名称会加入到本地名词空间中，并绑定到其模块对象。 导入非顶层模块，只将其顶级模块名称加入到本地名称空间中。导入的模块必须使用完全限定名称来访问。 如果使用了as，as后的名称直接绑定到导入的模块对象，并将该名称加入到本地名词空间中。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-文件处理、路径处理、序列化和反序列化","slug":"10python文件处理、路径处理、序列化和反序列化","date":"2017-09-09T16:00:00.000Z","updated":"2018-12-07T12:29:31.884Z","comments":true,"path":"2017/09/10/10python文件处理、路径处理、序列化和反序列化/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/10/10python文件处理、路径处理、序列化和反序列化/","excerpt":"","text":"文件IO常用操作一般说IO操作，指的是文件IO。 把文件存储到磁盘上的这个过程，叫做落地。 column column open 打开 read 读取 write 写入 close 关闭 readline 行读取 readlines 多行读取 seek 文件指针操作 tell 指针位置 open打开操作12345open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True,opener=None)f = open(\"file名字\") #文件对象print(f.read()) #读取文件f.close() #关闭文件 打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。基本使用： 创建一个文件test，然后打开它，用完关闭。 文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。 注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。 mode模式 描述字符 r 缺省的，表示只读打开 w 只写打开，有的话就清除重新写 x 创建并写入一个新文件 a 写入打开，如果文件存在，则追加 b 二进制模式 t 缺省的，文本模式 + 读写打开一个文件，给原来只读、只写的增加缺失的功能 open默认是只读模式r打开已经存在的文件。 r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。 w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。 x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。 a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容 r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。 +为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。 t和b： 文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。 二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。 t/b不能单独存在，要和a/w/x/r配合使用。 seek文件指针文件指针，指向当前字节位置。 mode = r，指针起始在0 ，mode = a 指针起始在EOF。 tell（）：显示指针当前位置。 seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。 文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0 12345678910111213# 文本模式f = open('test4','r+')f.tell() # 起始f.read()f.tell() # EOFf.seek(0) # 起始f.read()f.seek(2,0)f.read()f.seek(2,0)f.seek(2,1) # offset必须为0f.seek(2,2) # offset必须为0f.close() 二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。 1234567891011121314# 二进制模式f = open('test4','rb+')f.tell() # 起始f.read()f.tell() # EOFf.write(b'abc')f.seek(0) # 起始f.seek(2,1) # 从当前指针开始，向后2f.read() f.seek(-2,2) # 从EOF开始，向前2f.read()f.seek(-20,2) # OSErrorf.close() 二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。 buffering缓冲区-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是4096或者8192。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。 0 只在二进制模式使用，表示关buffer 1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush 大于1 用于指定buffer的大小 buffer 缓冲区 缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。 flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。 io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。 buffering 说明 buffering = -1 t和b，都是io.DEFAULT_BUFFER_SIZE buffering = 0 b 关闭缓冲区 t 不支持 buffering = 1 b 就一个字节t 行缓冲，遇到换行符才flush buffering &gt; 1 b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。 t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘 | 一般来说： 文本模式，一般都用默认缓冲区大小 二进制模式，是一个个字节的操作，可以指定buffer的大小 一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它 一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候 其他参数编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A） errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略 newline：文本模式中，换行的转换。可以为None、’’ 空串、’\\r’、’\\n’、’\\r\\n’ 。 None表示’\\r’、’\\n’、’\\r\\n’都被转换为’\\n’； ‘’ 表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。 ‘\\n’或’’表示’\\n’不替换；其它合法字符表示’\\n’会被替换为指定的字符 closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。 文件描述符：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。 对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。 read（）read(size=-1)size表示读取的多少个字符或字节；负数或者None表示读取到EOF readline(size=-1)一行行读取文件内容。size设置一次能读取行内几个字符或字节。 readlines(hint=-1)读取所有行的列表。指定hint则返回指定的行数。 write（）write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。 close（）flush并关闭文件对象。文件已经关闭，再次关闭没有任何效果。 其他 名称 说明 seekable（） 是否可seek readable（） 是否可读 writeable（） 是否可写 closed（） 是否已经关闭 上下文管理1、异常处理当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。 12345f = open('test')try: f.write(\"abc\") # 文件只读，写入失败finally: f.close() # 这样才行 使用finally可以保证打开的文件可以被关闭。 上下文管理 使用with … as 关键字 上下文管理的语句块并不会开启新的作用域 with语句块执行完的时候，会自动关闭文件对象 StringIO操作io模块中的类 from io import StringIO 内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 123456789from io import StringIO# 内存中构建sio = StringIO() # 像文件对象一样操作print(sio.readable(), sio.writable(), sio.seekable())# True True Truesio.write(\"luo\\nPython\")sio.seek(0) print(sio.readline()) #mageduprint(sio.getvalue()) # 无视指针，输出全部内容 magedu Pythonsio.close() 好处 一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。 BytesIO操作io模块中的类 from io import BytesIO 内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 12345678from io import BytesIO # 内存中构建bio = BytesIO()print(bio.readable(), bio.writable(), bio.seekable()) #True True Truebio.write(b\"luo\\nPython\")bio.seek(0)print(bio.readline()) # b'magedu\\n'print(bio.getvalue()) # 无视指针，输出全部内容 b'magedu\\nPython'bio.close() file-like对象类文件对象，可以像文件对象一样操作。 socket对象，输入输出对象（stdin、stdout）都是类文件对象 1234from sys import stdout, stderrf = stdoutprint(type(f)) #&lt;class 'ipykernel.iostream.OutStream'&gt;f.write('magedu.com') #magedu.com 路径操作os.path模块3.4版本之前 12345678910from os import pathp = path.join('d:/','tmp')print(type(p), p) #&lt;class 'str'&gt; d:/tmpprint(path.exists(p)) #判断是否存在该路径 Trueprint(path.split(p)) # (head,tail) ('d:/', 'tmp')print(path.abspath('.')) # 打印当前的绝对路径 C:\\Users\\vampire\\pythonp = path.join('D:/', p, 'test.txt') # 'd:/tmp\\\\test.txt'print(path.dirname(p)) # 目录名print(path.basename(p)) #基名，就是文件名print(path.splitdrive(p)) #二元组 ('d:', '/tmp\\\\test.txt'） 1234567p1 = path.abspath(\".\") #“文件路径”print(p1, path.basename(p1))while p1 != path.dirname(p1): p1 = path.dirname(p1) print(p1, path.basename(p1))​ C:\\Users\\vampire\\python pythonC:\\Users\\vampire vampireC:\\Users UsersC:\\​123456789101112131415```##### pathlib模块提供Path对象来操作。包括目录和文件。导入模块：from pathlib import Path**目录操作初始化**：```pythonp = Path() # 当前目录 WindowsPath(&apos;.&apos;)p.absolute()# WindowsPath(&apos;C:/Users/vampire/python&apos;)p = Path(&apos;a&apos;,&apos;b&apos;,&apos;c/d&apos;) # 当前目录下的 WindowsPath(&apos;C:/Users/vampire/python/a/b/c/d&apos;)p = Path(&apos;/etc&apos;) # 根下的etc目录 路径拼接和分解 操作符/Path对象 / Path对象Path对象 / 字符串 或者 字符串 / Path对象 分解parts属性，可以返回路径中的每一个部分 12p3.absolute() #WindowsPath('C:/Users/vampire/python/c/a')p3.absolute().parts #('C:\\\\', 'Users', 'vampire', 'python', 'c', 'a') joinpathjoinpath(*other) 连接多个字符串到Path对象中 1234567891011p = Path() # WindowsPath('.')p = p / 'a' # WindowsPath('a')p.absolute() # WindowsPath('C:/Users/vampire/python/a')p1 = 'b' / p # WindowsPath('C:/Users/vampire/python/b/a')p2 = Path('c') # WindowsPath('C:/Users/vampire/python/c')p2.absolute() # WindowsPath('C:/Users/vampire/python/c')p3 = p2 / p1 # WindowsPath('c/b/a')p3.absolute() # WindowsPath('C:/Users/vampire/python/c/b/a')print(p3.parts) #p3.absolute().parts # ('C:\\\\', 'Users', 'vampire', 'python', 'c', 'b', 'a')p3.joinpath('etc','init.d',Path('httpd')) 获取路径str 获取路径字符串 bytes 获取路径字符串的bytes 1234p = Path('/etc')print(str(p), bytes(p))# \\etc b'\\\\etc' 父目录parent 目录的逻辑父目录 parents 父目录序列，索引0是直接的父 12345678910p = Path('/a/b/c/d')print(p.absolute()) #C:\\a\\b\\c\\dprint(p.parent.parent) #\\a\\bfor x in p.parents: print(x) #\\a\\b\\c#\\a\\b#\\a#\\ 目录的组合部分name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) name 目录的最后一个部分 suffix 目录中最后一个部分的扩展名 stem 目录最后一个部分，没有后缀 suffixes 返回多个扩展名列表 with_suffix(suffix) 有扩展名则替换，无则补充扩展名 with_name(name) 替换目录最后一个部分并返回一个新的路径 123456789p = Path('mysqlinstall/mysql.tar.gz')print(p.name) #mysql.tar.gzprint(p.suffix) #.gzprint(p.suffixes) # ['.tar', '.gz']print(p.stem) # mysql.tarprint(p.with_name('mysql-5.tgz')) #\\mysqlinstall\\mysql-5.tgzprint(p.with_suffix('.png')) #\\mysqlinstall\\mysql.tar.pngp = Path('README') # READMEprint(p.with_suffix('.txt')) # README.txt 判断方法is_dir() 是否是目录，目录存在返回True is_file() 是否是普通文件，文件存在返回True is_symlink() 是否是软链接 is_socket()是否是socket文件 is_block_device()是否是块设备 is_char_device() 是否是字符设备 is_absolute()是否是绝对路径 resolve()返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 absolute() 获取绝对路径 exists()目录或文件是否存在 rmdir()删除空目录。没有提供判断目录为空的方法 touch(mode=0o666, exist_ok=True) 创建一个文件 as_uri() 将路径返回成URI，例如’file:///etc/passwd’ mkdir(mode=0o777, parents=False, exist_ok=False) parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略 iterdir()迭代当前目录 匹配match（pattern） 模式匹配，成功返回True。 123456Path('a/b.py').match('*.py') # TruePath('/a/b/c.py').match('b/*.py') # TruePath('/a/b/c.py').match('a/*.py') # FalsePath('/a/b/c.py').match('a/*/*.py') # TruePath('/a/b/c.py').match('a/**/*.py') # TruePath('/a/b/c.py').match('**/*.py') # True stat() 相当于stat命令 ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息 pathlib模块下的文件操作Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None) 使用的方法类似内建函数open，返回一个文件对象。 3.5增加的新函数 Path.read_bytes() 以’rb’读取路径对应文件，并返回二进制流。看源码 Path.read_text(encoding=None, errors=None) 以’rt’方式读取路径对应文件，返回文本。 Path.write_bytes(data) 以’wb’方式写入数据到路径对应文件。 Path.write_text(data, encoding=None, errors=None) 以’wt’方式写入字符串到路径对应文件。 123456789101112131415p = Path('my_binary_file')p.write_bytes(b'Binary file contents')p.read_bytes() # b'Binary file contents' p = Path('my_text_file')p.write_text('Text file contents')p.read_text() # 'Text file contents' from pathlib import Pathp = Path('o:/test.py')p.write_text('hello python')print(p.read_text())with p.open() as f: print(f.read(5)) csv文件逗号分隔值Comma-Separated Values。 CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 CSV 不指定字符编码。 行分隔符为\\r\\n，最后一行可以没有换行符 列分隔符常为逗号或者制表符。 每一行称为一条记录record 字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。 表头可选，和字段列对齐就行了。 手动生成csv文件 12345678910111213141516from pathlib import Pathp = Path('D:/tmp/test.csv')parent = p.parentif not parent.exists(): parent.mkdir(parents=True,exist_ok =True) #exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。csv_body = '''\\id,name,age,comment1,zs,18,\"I'm 18\"2,ls,20,\"this is a \"\"test\"\" string.\"3,ww,23,\"你好计算机\"'''p.write_text(csv_body) csv模块1def reader(iterable, dialect='excel', *args, **kwargs) 返回一个reader对象，是一个行迭代器 默认使用excel方言，如下： delimiter 列分隔符,逗号 lineterminator 行分隔符\\r\\n quotechar 字段的引用符号，缺省为”双引号 双引号的处理 doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。 escapechar 一个转义字符，默认为None writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符 quoting 指定双引号的规则 QUOTE_ALL 所有字段 QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则 QUOTE_NONNUMERIC非数字字段 QUOTE_NONE都不使用引号。 1def writer(fileobj, dialect='excel', *args, **kwargs) 返回DictWriter实例，主要的方法有writerow，writerows。 1234567891011121314151617181920212223import csv p = Path('d://tmp/tesr.csv')with open(str(p)) as f: reader = csv.reader(f) #返回一个迭代对象 print(next(reader)) #不回头 print(next(reader)) for line in reader: print(line) rows = [ [4,'tom',22,'tom'], (5,'jerry',24,'jerry'), (6,'justin',22,'just\\t\"in'), \"abcdefghi\", ((1,),(2,))]row = rows[0] with open(str(p), 'a',newline=\"\") as f: #newline为了不换行 writer = csv.writer(f) writer.writerow(row) #一次写一条 writer.writerows(rows) #将所有的一次写入 ini文件一般作为配置文件。 ini文件： 1234567891011[DEFAULT]a = test [mysql]default-character-set=utf8 [mysqld]datadir =/dbserver/dataport = 33060character-set-server=utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 中括号里面的部分称为section，译作节、区、段。 每一个section内，都是key=value形成的键值对，key称为option选项。 这里的DEFAULT是缺省section的名字，必须大写。 configparser模块configparser模块的ConfigParser类就是用来操作。 可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。 123456789101112131415161718192021222324252627282930313233read(filenames, encoding=None) #读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。sections() #返回section列表。缺省section不包括在内。 add_section(section_name) #增加一个section。 has_section(section_name) #判断section是否存在 options(section) #返回section的所有option，会追加缺省section的option has_option(section, option) #判断section是否存在这个optionget(section, option, *, raw=False, vars=None[, fallback]) #从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。getint(section, option, *, raw=False, vars=None[, fallback]) getfloat(section, option, *, raw=False, vars=None[, fallback]) getboolean(section, option, *, raw=False, vars=None[, fallback]) #上面3个方法和get一样，返回指定类型数据。items(raw=False, vars=None) items(section, raw=False, vars=None) #没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。set(section, option, value) #section存在的情况下，写入option=value，要求option、value必须是字符串。remove_section(section) #移除section及其所有option remove_option(section, option) #移除section下的option。write(fileobject, space_around_delimiters=True) #将当前config的所有内容写入fileobject中，一般open函数使用w模式。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from configparser import ConfigParserfrom pathlib import Pathfilename = Path(\"d://tmp/mysql.ini\")newfilename = Path(\"d://tmp/mysql111.ini\")cfg = ConfigParser()read_ok = cfg.read(str(filename))print(read_ok)print(cfg.sections())print(cfg.has_section(\"mysql\"))print(\"-\"*30)for k,v in cfg.items(): #未指定section print(k,type(k)) print(v,type(v)) print(cfg.items(k)) print(\"~~~~~~~~~~~~~~~~~~\")print(\"-\"*30)for k,v in cfg.items(\"mysqld\"): #指定section print(k,type(k)) print(v,type(v)) print(\"~~~~~~~~~~\")tmp = cfg.get(\"mysqld\",\"port\")print(tmp, type(tmp))print(cfg.get(\"mysqld\", \"a\"))print(cfg.get(\"mysqld\", \"python\" , fallback= \"linux\")) #按照类型，fallbac：给与缺省值tmp = cfg.getint(\"mysqld\", \"port\")print(type(tmp), tmp)cfg.add_section(\"test\")cfg.set(\"test\",\"test1\",\"1\")cfg.set(\"test\",\"test2\",\"2\")with open(newfilename,\"w+\",newline=\"\") as f: cfg.write(f)print(cfg.getint(\"test\" , \"test1\"))cfg.remove_option(\"test\", \"test1\")# cfg.remove_section(\"test\")# print(\"x\" in cfg[\"test2\"])#字典操作cfg[\"test3\"] = &#123;\"c\":\"1000\"&#125; #没有落地，在内存中修改print(\"x\" in cfg[\"test\"])print(\"c\" in cfg[\"test3\"])# 其他内部方式print(cfg._dict) # 返回默认的字典类型，默认使用有序字典for k, v in cfg._sections.items(): print(k, v)for k,v in cfg._sections['mysqld'].items(): print(k,v)#重新写入文件with open(newfilename, 'w') as f: cfg.write(f) 序列化和反序列化要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。 serialization：序列化将内存中对象存储下来，变成一个个字节 –&gt; 二进制 deseiralization：反序列化将文件中的一个个字节恢复成内存中对象 &lt;–二进制 序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。 pickle库python中的序列化，反序列化模块。 dumps 对象序列化为bytes对象 dump 对象序列化到文件对象，就是存入文件 loads 从bytes对象反序列化 load 对象反序列化，从文件读取数据 序列化的应用一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。 现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。 但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。 不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。 JsonJson(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/ Json的数据类型 值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 字符串：有正负，有整数，浮点数。 对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。 数组：有序的值的集合 格式[val1，，，，valn] 12345678910111213&#123; \"person\": [ &#123; \"name\": \"tom\", \"age\": 18 &#125;, &#123; \"name\": \"jerry\", \"age\": 16 &#125; ], \"total\": 2&#125; Json模块 Python支持少量内建数据类型到Json类型的转换 Python类型 Json类型 True true False false None null str string int integer float float list array dict object 常用方法 Python类型 Json类型 dumps Json编码 dump Json编码并存入文件 loads Json解码 load Json解码，从文件读取数据 一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。 MessagePackMessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 它可以像JSON那样，在许多种语言之间交换结构对象。 兼容 json和pickle。 MessagePack简单易用，高效压缩，支持语言丰富。 所以，用它序列化也是一种很好的选择。 安装：$pip install msgpack-python 常用方法： packb 序列化对象。提供了dumps来兼容pickle和json。 unpackb 反序列化对象。提供了loads来兼容。 pack 序列化对象保存到文件对象。提供了dump来兼容。 unpack 反序列化对象保存到文件对象。提供了load来兼容。 123456789101112131415161718192021import pickleimport jsonimport msgpackd = &#123;\"person\":[&#123;\"name\":\"tom\",\"age\":18&#125;,&#123;\"name\":\"jerry\",\"age\":16&#125;],\"total\":2&#125;j = json.dumps(d)print(j, type(j), len(j)) # 请注意引号的变化print(len(j.replace(' ',''))) # 72 bytes 注意这样替换的压缩是不对的print(\"-\"*30)p = pickle.dumps(d)print(p)print(len(p)) # 101 bytesprint(\"-\"*30)m = msgpack.dumps(d)print(m)print(len(m)) # 48 bytesprint(\"-\"*30)u = msgpack.unpackb(m)print(type(u), u)u = msgpack.loads(m, encoding='utf-8')print(type(u), u) 1234567891011&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &apos;str&apos;&gt; 8272------------------------------b&apos;\\x80\\x03&#125;q\\x00(X\\x06\\x00\\x00\\x00personq\\x01]q\\x02(&#125;q\\x03(X\\x04\\x00\\x00\\x00nameq\\x04X\\x03\\x00\\x00\\x00tomq\\x05X\\x03\\x00\\x00\\x00ageq\\x06K\\x12u&#125;q\\x07(h\\x04X\\x05\\x00\\x00\\x00jerryq\\x08h\\x06K\\x10ueX\\x05\\x00\\x00\\x00totalq\\tK\\x02u.&apos;101------------------------------b&apos;\\x82\\xa6person\\x92\\x82\\xa4name\\xa3tom\\xa3age\\x12\\x82\\xa4name\\xa5jerry\\xa3age\\x10\\xa5total\\x02&apos;48------------------------------&lt;class &apos;dict&apos;&gt; &#123;b&apos;person&apos;: [&#123;b&apos;name&apos;: b&apos;tom&apos;, b&apos;age&apos;: 18&#125;, &#123;b&apos;name&apos;: b&apos;jerry&apos;, b&apos;age&apos;: 16&#125;], b&apos;total&apos;: 2&#125;&lt;class &apos;dict&apos;&gt; &#123;&apos;person&apos;: [&#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18&#125;, &#123;&apos;name&apos;: &apos;jerry&apos;, &apos;age&apos;: 16&#125;], &apos;total&apos;: 2&#125;","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-文件处理、路径处理、序列化和反序列化","slug":"09python文件处理、路径处理、序列化和反序列化","date":"2017-09-09T16:00:00.000Z","updated":"2018-12-07T12:29:31.884Z","comments":true,"path":"2017/09/10/09python文件处理、路径处理、序列化和反序列化/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/10/09python文件处理、路径处理、序列化和反序列化/","excerpt":"","text":"文件IO常用操作一般说IO操作，指的是文件IO。 把文件存储到磁盘上的这个过程，叫做落地。 column column open 打开 read 读取 write 写入 close 关闭 readline 行读取 readlines 多行读取 seek 文件指针操作 tell 指针位置 open打开操作12345open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True,opener=None)f = open(\"file名字\") #文件对象print(f.read()) #读取文件f.close() #关闭文件 打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。基本使用： 创建一个文件test，然后打开它，用完关闭。 文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。 注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。 mode模式 描述字符 r 缺省的，表示只读打开 w 只写打开，有的话就清除重新写 x 创建并写入一个新文件 a 写入打开，如果文件存在，则追加 b 二进制模式 t 缺省的，文本模式 + 读写打开一个文件，给原来只读、只写的增加缺失的功能 open默认是只读模式r打开已经存在的文件。 r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。 w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。 x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。 a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容 r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。 +为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。 t和b： 文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。 二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。 t/b不能单独存在，要和a/w/x/r配合使用。 seek文件指针文件指针，指向当前字节位置。 mode = r，指针起始在0 ，mode = a 指针起始在EOF。 tell（）：显示指针当前位置。 seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。 文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0 12345678910111213# 文本模式f = open('test4','r+')f.tell() # 起始f.read()f.tell() # EOFf.seek(0) # 起始f.read()f.seek(2,0)f.read()f.seek(2,0)f.seek(2,1) # offset必须为0f.seek(2,2) # offset必须为0f.close() 二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。 1234567891011121314# 二进制模式f = open('test4','rb+')f.tell() # 起始f.read()f.tell() # EOFf.write(b'abc')f.seek(0) # 起始f.seek(2,1) # 从当前指针开始，向后2f.read() f.seek(-2,2) # 从EOF开始，向前2f.read()f.seek(-20,2) # OSErrorf.close() 二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。 buffering缓冲区-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是4096或者8192。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。 0 只在二进制模式使用，表示关buffer 1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush 大于1 用于指定buffer的大小 buffer 缓冲区 缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。 flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。 io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。 buffering 说明 buffering = -1 t和b，都是io.DEFAULT_BUFFER_SIZE buffering = 0 b 关闭缓冲区 t 不支持 buffering = 1 b 就一个字节t 行缓冲，遇到换行符才flush buffering &gt; 1 b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。 t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘 | 一般来说： 文本模式，一般都用默认缓冲区大小 二进制模式，是一个个字节的操作，可以指定buffer的大小 一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它 一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候 其他参数编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A） errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略 newline：文本模式中，换行的转换。可以为None、’’ 空串、’\\r’、’\\n’、’\\r\\n’ 。 None表示’\\r’、’\\n’、’\\r\\n’都被转换为’\\n’； ‘’ 表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。 ‘\\n’或’’表示’\\n’不替换；其它合法字符表示’\\n’会被替换为指定的字符 closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。 文件描述符：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。 对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。 read（）read(size=-1)size表示读取的多少个字符或字节；负数或者None表示读取到EOF readline(size=-1)一行行读取文件内容。size设置一次能读取行内几个字符或字节。 readlines(hint=-1)读取所有行的列表。指定hint则返回指定的行数。 write（）write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。 close（）flush并关闭文件对象。文件已经关闭，再次关闭没有任何效果。 其他 名称 说明 seekable（） 是否可seek readable（） 是否可读 writeable（） 是否可写 closed（） 是否已经关闭 上下文管理1、异常处理当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。 12345f = open('test')try: f.write(\"abc\") # 文件只读，写入失败finally: f.close() # 这样才行 使用finally可以保证打开的文件可以被关闭。 上下文管理 使用with … as 关键字 上下文管理的语句块并不会开启新的作用域 with语句块执行完的时候，会自动关闭文件对象 StringIO操作io模块中的类 from io import StringIO 内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 123456789from io import StringIO# 内存中构建sio = StringIO() # 像文件对象一样操作print(sio.readable(), sio.writable(), sio.seekable())# True True Truesio.write(\"luo\\nPython\")sio.seek(0) print(sio.readline()) #mageduprint(sio.getvalue()) # 无视指针，输出全部内容 magedu Pythonsio.close() 好处 一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。 BytesIO操作io模块中的类 from io import BytesIO 内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 12345678from io import BytesIO # 内存中构建bio = BytesIO()print(bio.readable(), bio.writable(), bio.seekable()) #True True Truebio.write(b\"luo\\nPython\")bio.seek(0)print(bio.readline()) # b'magedu\\n'print(bio.getvalue()) # 无视指针，输出全部内容 b'magedu\\nPython'bio.close() file-like对象类文件对象，可以像文件对象一样操作。 socket对象，输入输出对象（stdin、stdout）都是类文件对象 1234from sys import stdout, stderrf = stdoutprint(type(f)) #&lt;class 'ipykernel.iostream.OutStream'&gt;f.write('magedu.com') #magedu.com 路径操作os.path模块3.4版本之前 12345678910from os import pathp = path.join('d:/','tmp')print(type(p), p) #&lt;class 'str'&gt; d:/tmpprint(path.exists(p)) #判断是否存在该路径 Trueprint(path.split(p)) # (head,tail) ('d:/', 'tmp')print(path.abspath('.')) # 打印当前的绝对路径 C:\\Users\\vampire\\pythonp = path.join('D:/', p, 'test.txt') # 'd:/tmp\\\\test.txt'print(path.dirname(p)) # 目录名print(path.basename(p)) #基名，就是文件名print(path.splitdrive(p)) #二元组 ('d:', '/tmp\\\\test.txt'） 1234567p1 = path.abspath(\".\") #“文件路径”print(p1, path.basename(p1))while p1 != path.dirname(p1): p1 = path.dirname(p1) print(p1, path.basename(p1))​ C:\\Users\\vampire\\python pythonC:\\Users\\vampire vampireC:\\Users UsersC:\\​123456789101112131415```##### pathlib模块提供Path对象来操作。包括目录和文件。导入模块：from pathlib import Path**目录操作初始化**：```pythonp = Path() # 当前目录 WindowsPath(&apos;.&apos;)p.absolute()# WindowsPath(&apos;C:/Users/vampire/python&apos;)p = Path(&apos;a&apos;,&apos;b&apos;,&apos;c/d&apos;) # 当前目录下的 WindowsPath(&apos;C:/Users/vampire/python/a/b/c/d&apos;)p = Path(&apos;/etc&apos;) # 根下的etc目录 路径拼接和分解 操作符/Path对象 / Path对象Path对象 / 字符串 或者 字符串 / Path对象 分解parts属性，可以返回路径中的每一个部分 12p3.absolute() #WindowsPath('C:/Users/vampire/python/c/a')p3.absolute().parts #('C:\\\\', 'Users', 'vampire', 'python', 'c', 'a') joinpathjoinpath(*other) 连接多个字符串到Path对象中 1234567891011p = Path() # WindowsPath('.')p = p / 'a' # WindowsPath('a')p.absolute() # WindowsPath('C:/Users/vampire/python/a')p1 = 'b' / p # WindowsPath('C:/Users/vampire/python/b/a')p2 = Path('c') # WindowsPath('C:/Users/vampire/python/c')p2.absolute() # WindowsPath('C:/Users/vampire/python/c')p3 = p2 / p1 # WindowsPath('c/b/a')p3.absolute() # WindowsPath('C:/Users/vampire/python/c/b/a')print(p3.parts) #p3.absolute().parts # ('C:\\\\', 'Users', 'vampire', 'python', 'c', 'b', 'a')p3.joinpath('etc','init.d',Path('httpd')) 获取路径str 获取路径字符串 bytes 获取路径字符串的bytes 1234p = Path('/etc')print(str(p), bytes(p))# \\etc b'\\\\etc' 父目录parent 目录的逻辑父目录 parents 父目录序列，索引0是直接的父 12345678910p = Path('/a/b/c/d')print(p.absolute()) #C:\\a\\b\\c\\dprint(p.parent.parent) #\\a\\bfor x in p.parents: print(x) #\\a\\b\\c#\\a\\b#\\a#\\ 目录的组合部分name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) name 目录的最后一个部分 suffix 目录中最后一个部分的扩展名 stem 目录最后一个部分，没有后缀 suffixes 返回多个扩展名列表 with_suffix(suffix) 有扩展名则替换，无则补充扩展名 with_name(name) 替换目录最后一个部分并返回一个新的路径 123456789p = Path('mysqlinstall/mysql.tar.gz')print(p.name) #mysql.tar.gzprint(p.suffix) #.gzprint(p.suffixes) # ['.tar', '.gz']print(p.stem) # mysql.tarprint(p.with_name('mysql-5.tgz')) #\\mysqlinstall\\mysql-5.tgzprint(p.with_suffix('.png')) #\\mysqlinstall\\mysql.tar.pngp = Path('README') # READMEprint(p.with_suffix('.txt')) # README.txt 判断方法is_dir() 是否是目录，目录存在返回True is_file() 是否是普通文件，文件存在返回True is_symlink() 是否是软链接 is_socket()是否是socket文件 is_block_device()是否是块设备 is_char_device() 是否是字符设备 is_absolute()是否是绝对路径 resolve()返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 absolute() 获取绝对路径 exists()目录或文件是否存在 rmdir()删除空目录。没有提供判断目录为空的方法 touch(mode=0o666, exist_ok=True) 创建一个文件 as_uri() 将路径返回成URI，例如’file:///etc/passwd’ mkdir(mode=0o777, parents=False, exist_ok=False) parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略 iterdir()迭代当前目录 匹配match（pattern） 模式匹配，成功返回True。 123456Path('a/b.py').match('*.py') # TruePath('/a/b/c.py').match('b/*.py') # TruePath('/a/b/c.py').match('a/*.py') # FalsePath('/a/b/c.py').match('a/*/*.py') # TruePath('/a/b/c.py').match('a/**/*.py') # TruePath('/a/b/c.py').match('**/*.py') # True stat() 相当于stat命令 ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息 pathlib模块下的文件操作Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None) 使用的方法类似内建函数open，返回一个文件对象。 3.5增加的新函数 Path.read_bytes() 以’rb’读取路径对应文件，并返回二进制流。看源码 Path.read_text(encoding=None, errors=None) 以’rt’方式读取路径对应文件，返回文本。 Path.write_bytes(data) 以’wb’方式写入数据到路径对应文件。 Path.write_text(data, encoding=None, errors=None) 以’wt’方式写入字符串到路径对应文件。 123456789101112131415p = Path('my_binary_file')p.write_bytes(b'Binary file contents')p.read_bytes() # b'Binary file contents' p = Path('my_text_file')p.write_text('Text file contents')p.read_text() # 'Text file contents' from pathlib import Pathp = Path('o:/test.py')p.write_text('hello python')print(p.read_text())with p.open() as f: print(f.read(5)) csv文件逗号分隔值Comma-Separated Values。 CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 CSV 不指定字符编码。 行分隔符为\\r\\n，最后一行可以没有换行符 列分隔符常为逗号或者制表符。 每一行称为一条记录record 字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。 表头可选，和字段列对齐就行了。 手动生成csv文件 12345678910111213141516from pathlib import Pathp = Path('D:/tmp/test.csv')parent = p.parentif not parent.exists(): parent.mkdir(parents=True,exist_ok =True) #exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。csv_body = '''\\id,name,age,comment1,zs,18,\"I'm 18\"2,ls,20,\"this is a \"\"test\"\" string.\"3,ww,23,\"你好计算机\"'''p.write_text(csv_body) csv模块1def reader(iterable, dialect='excel', *args, **kwargs) 返回一个reader对象，是一个行迭代器 默认使用excel方言，如下： delimiter 列分隔符,逗号 lineterminator 行分隔符\\r\\n quotechar 字段的引用符号，缺省为”双引号 双引号的处理 doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。 escapechar 一个转义字符，默认为None writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符 quoting 指定双引号的规则 QUOTE_ALL 所有字段 QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则 QUOTE_NONNUMERIC非数字字段 QUOTE_NONE都不使用引号。 1def writer(fileobj, dialect='excel', *args, **kwargs) 返回DictWriter实例，主要的方法有writerow，writerows。 1234567891011121314151617181920212223import csv p = Path('d://tmp/tesr.csv')with open(str(p)) as f: reader = csv.reader(f) #返回一个迭代对象 print(next(reader)) #不回头 print(next(reader)) for line in reader: print(line) rows = [ [4,'tom',22,'tom'], (5,'jerry',24,'jerry'), (6,'justin',22,'just\\t\"in'), \"abcdefghi\", ((1,),(2,))]row = rows[0] with open(str(p), 'a',newline=\"\") as f: #newline为了不换行 writer = csv.writer(f) writer.writerow(row) #一次写一条 writer.writerows(rows) #将所有的一次写入 ini文件一般作为配置文件。 ini文件： 1234567891011[DEFAULT]a = test [mysql]default-character-set=utf8 [mysqld]datadir =/dbserver/dataport = 33060character-set-server=utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 中括号里面的部分称为section，译作节、区、段。 每一个section内，都是key=value形成的键值对，key称为option选项。 这里的DEFAULT是缺省section的名字，必须大写。 configparser模块configparser模块的ConfigParser类就是用来操作。 可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。 123456789101112131415161718192021222324252627282930313233read(filenames, encoding=None) #读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。sections() #返回section列表。缺省section不包括在内。 add_section(section_name) #增加一个section。 has_section(section_name) #判断section是否存在 options(section) #返回section的所有option，会追加缺省section的option has_option(section, option) #判断section是否存在这个optionget(section, option, *, raw=False, vars=None[, fallback]) #从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。getint(section, option, *, raw=False, vars=None[, fallback]) getfloat(section, option, *, raw=False, vars=None[, fallback]) getboolean(section, option, *, raw=False, vars=None[, fallback]) #上面3个方法和get一样，返回指定类型数据。items(raw=False, vars=None) items(section, raw=False, vars=None) #没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。set(section, option, value) #section存在的情况下，写入option=value，要求option、value必须是字符串。remove_section(section) #移除section及其所有option remove_option(section, option) #移除section下的option。write(fileobject, space_around_delimiters=True) #将当前config的所有内容写入fileobject中，一般open函数使用w模式。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from configparser import ConfigParserfrom pathlib import Pathfilename = Path(\"d://tmp/mysql.ini\")newfilename = Path(\"d://tmp/mysql111.ini\")cfg = ConfigParser()read_ok = cfg.read(str(filename))print(read_ok)print(cfg.sections())print(cfg.has_section(\"mysql\"))print(\"-\"*30)for k,v in cfg.items(): #未指定section print(k,type(k)) print(v,type(v)) print(cfg.items(k)) print(\"~~~~~~~~~~~~~~~~~~\")print(\"-\"*30)for k,v in cfg.items(\"mysqld\"): #指定section print(k,type(k)) print(v,type(v)) print(\"~~~~~~~~~~\")tmp = cfg.get(\"mysqld\",\"port\")print(tmp, type(tmp))print(cfg.get(\"mysqld\", \"a\"))print(cfg.get(\"mysqld\", \"python\" , fallback= \"linux\")) #按照类型，fallbac：给与缺省值tmp = cfg.getint(\"mysqld\", \"port\")print(type(tmp), tmp)cfg.add_section(\"test\")cfg.set(\"test\",\"test1\",\"1\")cfg.set(\"test\",\"test2\",\"2\")with open(newfilename,\"w+\",newline=\"\") as f: cfg.write(f)print(cfg.getint(\"test\" , \"test1\"))cfg.remove_option(\"test\", \"test1\")# cfg.remove_section(\"test\")# print(\"x\" in cfg[\"test2\"])#字典操作cfg[\"test3\"] = &#123;\"c\":\"1000\"&#125; #没有落地，在内存中修改print(\"x\" in cfg[\"test\"])print(\"c\" in cfg[\"test3\"])# 其他内部方式print(cfg._dict) # 返回默认的字典类型，默认使用有序字典for k, v in cfg._sections.items(): print(k, v)for k,v in cfg._sections['mysqld'].items(): print(k,v)#重新写入文件with open(newfilename, 'w') as f: cfg.write(f) 序列化和反序列化要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。 serialization：序列化将内存中对象存储下来，变成一个个字节 –&gt; 二进制 deseiralization：反序列化将文件中的一个个字节恢复成内存中对象 &lt;–二进制 序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。 pickle库python中的序列化，反序列化模块。 dumps 对象序列化为bytes对象 dump 对象序列化到文件对象，就是存入文件 loads 从bytes对象反序列化 load 对象反序列化，从文件读取数据 序列化的应用一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。 现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。 但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。 不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。 JsonJson(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/ Json的数据类型 值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 字符串：有正负，有整数，浮点数。 对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。 数组：有序的值的集合 格式[val1，，，，valn] 12345678910111213&#123; \"person\": [ &#123; \"name\": \"tom\", \"age\": 18 &#125;, &#123; \"name\": \"jerry\", \"age\": 16 &#125; ], \"total\": 2&#125; Json模块 Python支持少量内建数据类型到Json类型的转换 Python类型 Json类型 True true False false None null str string int integer float float list array dict object 常用方法 Python类型 Json类型 dumps Json编码 dump Json编码并存入文件 loads Json解码 load Json解码，从文件读取数据 一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。 MessagePackMessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 它可以像JSON那样，在许多种语言之间交换结构对象。 兼容 json和pickle。 MessagePack简单易用，高效压缩，支持语言丰富。 所以，用它序列化也是一种很好的选择。 安装：$pip install msgpack-python 常用方法： packb 序列化对象。提供了dumps来兼容pickle和json。 unpackb 反序列化对象。提供了loads来兼容。 pack 序列化对象保存到文件对象。提供了dump来兼容。 unpack 反序列化对象保存到文件对象。提供了load来兼容。 123456789101112131415161718192021import pickleimport jsonimport msgpackd = &#123;\"person\":[&#123;\"name\":\"tom\",\"age\":18&#125;,&#123;\"name\":\"jerry\",\"age\":16&#125;],\"total\":2&#125;j = json.dumps(d)print(j, type(j), len(j)) # 请注意引号的变化print(len(j.replace(' ',''))) # 72 bytes 注意这样替换的压缩是不对的print(\"-\"*30)p = pickle.dumps(d)print(p)print(len(p)) # 101 bytesprint(\"-\"*30)m = msgpack.dumps(d)print(m)print(len(m)) # 48 bytesprint(\"-\"*30)u = msgpack.unpackb(m)print(type(u), u)u = msgpack.loads(m, encoding='utf-8')print(type(u), u) 1234567891011&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &apos;str&apos;&gt; 8272------------------------------b&apos;\\x80\\x03&#125;q\\x00(X\\x06\\x00\\x00\\x00personq\\x01]q\\x02(&#125;q\\x03(X\\x04\\x00\\x00\\x00nameq\\x04X\\x03\\x00\\x00\\x00tomq\\x05X\\x03\\x00\\x00\\x00ageq\\x06K\\x12u&#125;q\\x07(h\\x04X\\x05\\x00\\x00\\x00jerryq\\x08h\\x06K\\x10ueX\\x05\\x00\\x00\\x00totalq\\tK\\x02u.&apos;101------------------------------b&apos;\\x82\\xa6person\\x92\\x82\\xa4name\\xa3tom\\xa3age\\x12\\x82\\xa4name\\xa5jerry\\xa3age\\x10\\xa5total\\x02&apos;48------------------------------&lt;class &apos;dict&apos;&gt; &#123;b&apos;person&apos;: [&#123;b&apos;name&apos;: b&apos;tom&apos;, b&apos;age&apos;: 18&#125;, &#123;b&apos;name&apos;: b&apos;jerry&apos;, b&apos;age&apos;: 16&#125;], b&apos;total&apos;: 2&#125;&lt;class &apos;dict&apos;&gt; &#123;&apos;person&apos;: [&#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18&#125;, &#123;&apos;name&apos;: &apos;jerry&apos;, &apos;age&apos;: 16&#125;], &apos;total&apos;: 2&#125;","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-函数、高阶函数、装饰器、参数注解","slug":"08python函数、高阶函数、装饰器、参数注解、缓存","date":"2017-08-20T16:00:00.000Z","updated":"2018-12-07T08:31:10.513Z","comments":true,"path":"2017/08/21/08python函数、高阶函数、装饰器、参数注解、缓存/","link":"","permalink":"http://luoqian67.github.io/blog/2017/08/21/08python函数、高阶函数、装饰器、参数注解、缓存/","excerpt":"","text":"函数 1. 函数的定义 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元。 完成一定的功能。 函数也是对象，python把函数的默认值放在了属性中，这个属性就伴随着这个函数对象的整个生命周期。 2. 函数的作用 结构化编程是对代码的最基本的封装，一般按照功能组织一段代码。 封装的目的是为了复用，减少冗余代码。 代码更加简洁美观，可读易懂。 3. 函数的分类： 内建函数；库函数；自建函数 4. 函数的定义、调用定义 def语句定义函数 def 函数名（参数列表）： 函数体（代码块） [return 返回值] 定义中的参数列表成为形式参数，只是一种符号表达，简称形参。 定义需要在调用前，否则会抛出NameError异常。 调用 函数定义，只是声明了一个函数，它不会被指执行，需要调用。 调用的方式，就是函数名加上小括号，括号内写上参数。 调用时写的参数时实际参数，是实实在在传入的值，简称实参 传参时位置参数要放在关键字参数前面。 参数传递：不可变类型，传递副本给函数，函数内操作不影响原始值 可变类型，传递的是地址引用，函数内操作可能影响原始值 定义形参和传递实参时候的注意事项 参数调用时传入的参数要和定义的个数相匹配，可变参数例外 定义时，缺省参数要放在非缺省参数前。 定义时加* ：可变位置参数：可以收集位置参数传入的所有参数，收集多个实参为一个tuple。可变位置参数不能用关键字传参。 形参加**：可变关键字参数，只能用关键字传参。可变关键字参数，收集的实参名称和值组成一个字典，所以可修改。 函数名也是标识符，返回值也是值，函数是可调用的对象，callable(函数名) -&gt; True。 混合使用参数的时候，可变参数要放到参数列表的最后，普通参数要放到参数列表的最前面，可变位置参数发要放在可变关键字参数的前面。 keyword-only参数：如果在一个可变位置参数后面，出现了普通参数，此时这个普通参数已经变成了一个keyword-only参数 参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数。 参数解构： 给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参。 非字典类型使用*解构成位置参数 字典类型使用**解构成关键字参数 提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配。 5.函数的返回值python函数使用return语句返回“返回值”。 所有函数都有返回值。如果没有return语句，隐式调用return None。 return语句并不一定是函数的语句块的最后一条语句 return语句只能执行一次，执行完，函数结束，当前return后面的语句就不会再运行了。所以函数一次只能返回一个值，不能返回多个值，但是可以返回容器，容器里面包含多个值。（return [1,3,5]是指明返回一个列表，是一个列表对象；return 1,3,5看似返回多个值，隐式的被python封装成一个元组） 作用：结束函数调用、返回值。 函数的嵌套 函数有可见范围。这就是作用域的概念 外层变量作用域在内层作用域可见 内部函数不能在外部直接使用，会抛NameError异常，因为它不可见。 6. 作用域 一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域。 全局作用域：在整个函数运行环境中都可见。 局部作用域：在函数、类内部可见；局部变量的使用范围不能超过其所在的局部作用域。 例子： 12345678a = 5def foo(): a += 1foo()---------------------------------------------------------------------------UnboundLocalError Traceback (most recent call last)UnboundLocalError: local variable 'a' referenced before assignment 报错原因： a += 1其实就是a = a + 1,a = 5是全局的变量，虽然能在内部函数foo中可见，但是在foo函数内部出现了 a = ，出现等号就是即赋值即重新定义，那么=的右边作为赋值的内容 ：a+1,但在函数中，此时的a已经算是重新定义了一个局部变量，而不是用外面的全局变量，但是此时a还没有完成赋值就被拿来进行加1操作，所以才会报错。 解决办法： 在这条语句前增加x=0之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义 默认值的作用域 函数名.__defaults__属性：使用元组来保存所有位置参数默认值，它不会因为在函数体中使用了它而发生了变化。 函数名.__kwdefaults__属性：使用字典保存所有keyword-only参数的默认值。 使用可变类型（引用参数）作为默认值，就有可能修改这个默认值。 使用按需修改,例子。12345678910111213141516171819202122232425def foo(xyz=[], u='abc', z=123): xyz = xyz[:] # 影子拷贝 xyz.append(1) print(xyz)foo()print(foo.__defaults__)foo([10])print(foo.__defaults__)foo([10,5])print(foo.__defaults__)# 函数体内，不改变默认值# 使用影子拷贝创建一个新的对象，永远不能改变传入的参数# xyz都是传入参数或者默认参数的副本，如果就想修改原参数，无能为力def foo(xyz=None, u='abc', z=123): if xyz is None: xyz = [] xyz.append(1) print(xyz)# 使用不可变类型默认值# 如果使用缺省值None就创建一个列表# 如果传入一个列表，就修改这个列表 全局变量global使用global关键字的变量，将函数内的定义的局部变量声明成全局变量。 如果函数需要使用外部全局变量，请使用函数的形参传参解决。 尽量不使用 nonlocal关键字nonlocal将变量标记为不再本地作用域定义，而在上一级的某一级局部作用域中定义，但不能是全局作用域中定义。 7.闭包自由变量：未在本地作用域中定义的变量，例如定义在内层函数外的外层函数的作用域中的变量 闭包：是一概念，是嵌套函数中，指的是在内层函数中引用到外层函数的自由变量，就形成了闭包。 8.变量名解析原则LEGB Local，本地作用域、局部作用域的local命名空间。函数调用时创建，调用结束消亡。 Enclosing，Python2.2时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间。 Global，全局作用域，即一个模块的命名空间。模块被import时创建，解释器退出时消亡。 Build-in，内置模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡。例如 print(open)，print和open都是内置的变量。 函数变量作用域：级别：Built_in(内建) &gt; Global(全局) &gt; Enclosing（封装）&gt; local(本地) 9.函数的销毁全局函数销毁 重新定义同名函数 del 语句删除函数对象名称，函数对象的引用计数减1 程序结束时 12345678910def foo(xyz=[], u='abc', z=123): xyz.append(1) return xyzprint(foo(), id(foo), foo.__defaults__)def foo(xyz=[], u='abc', z=123): xyz.append(1) return xyzprint(foo(), id(foo), foo.__defaults__)del fooprint(foo(), id(foo), foo.__defaults__) 局部函数销毁 重新在上级作用域定义同名函数 del 语句删除函数名称，函数对象的引用计数减1 上级作用域销毁时 12345678910111213def foo(xyz=[], u='abc', z=123): xyz.append(1) def inner(a=10): pass print(inner) def inner(a=100): print(xyz) print(inner) return innerbar = foo()print(id(foo),id(bar), foo.__defaults__, bar.__defaults__)del barprint(id(foo),id(bar), foo.__defaults__, bar.__defaults__) 10.递归函数函数是需要压栈的，栈和线程相关。 11.匿名函数没有名字的函数，python借助lamdba表达式构建匿名函数。 参数列表不需要小括号。 冒号是用来区分参数列表和表达式的。 不需要return，表达式的值，就是匿名函数返回值。 lambda表达式（匿名函数）只能写在一行上，被成为单行函数。 用途：在高阶函数传参时，使用lambda表达式，往往能简化代码 格式：lambda 参数列表：表达式 123lambda x : x**2(lambda x : x**2) () #调用 12.高阶函数FIrst Class Object 函数也是对象，可调用对象 函数可以作为普通变量、参数、返回值等等。 高阶函数，至少满足下面的一个条件的函数。 接收一个或者多个函数作为参数，或者函数的输出是一个函数。 13.装饰器装饰器本质上是一个 Python 函数或类。 它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 多装饰器的函数执行顺序，由底向上 14.参数注解文档注解：函数内的最前面，使用三个双引号 函数注解： python3.5引入 对函数的参数进行类型注解 对函数的返回值进行类型注解 只对函数参数做一个辅助的说明，并不对函数参数进行类型检查 提供给第三方工具，做代码分析，发现隐藏的bug 函数注解的信息，保存在__annotations__属性中 变量注解：python3.6引入 函数参数类型检查 思路： 函数参数的检查，一定是在函数外 函数应该作为参数，传入到检查函数中 检查函数拿到函数传入的实际参数，与形参声明对比 __annotations__属性是一个字典，其中包括返回值类型的声明，加入要位置参数的判断，无法和字典中的声明对应，使用inspect模块 inspect模块：提取获取对象信息的函数，可以检查函数和类、类型检查 inspect.isfunction(add) , 是否是函数 inspect.ismethod(add) , 是否是类的方法 inspect.isgenerator(add) , 是否是生成器对象 inspect.isgeneratorfunction(add) , 是否是生成器函数 inspect.isclass(add) ， 是否是类 inspect.ismodule(inspect) , 是否是模块 inspect.isbuiltin(print) , 是否是内建对象 signature(callable)，获取签名（函数签名包含了一个函数的信息，包括函数名，它的参数类型，它的所在的类和名称空间及其他信息） Parameter对象 保存在元组中 输入属性：inspect.signature.parameters.annotation/name/kind/default 返回属性：inspect.signature.return_annotation 当不知道该方法下面有多少属性的时候，可以先用type查看该它的类型，然后通过导入模块，使用参数注解的方式来查看。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-标准库、解析式、生成器","slug":"07python标准库、解析式、生成器","date":"2017-08-14T16:00:00.000Z","updated":"2018-12-07T08:25:51.877Z","comments":true,"path":"2017/08/15/07python标准库、解析式、生成器/","link":"","permalink":"http://luoqian67.github.io/blog/2017/08/15/07python标准库、解析式、生成器/","excerpt":"","text":"标准库datetime模块 对日期、时间、时间戳的处理 datetime类 类方法： today():返回本地时区当前时间的datetime对象 now(tz=None)：返回当前时间的datetime对象，时间到微秒，如果tz为None，返回和today()一样 utcnow()：没有时区的当前时间（国际化的时候建议用这个） fromtimestamp(timestamp , tz = None) 从一个时间戳返回一个datetime对象 datetime对象 timestamp()：返回一个到微秒的时间戳 时间戳：格林威治时间1970年1月1日0点到现在的秒数。 构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043) year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒 weekday() 返回星期的天，周一0，周日6 isoweekday() 返回星期的天，周一1，周日7 date() 返回日期date对象 time() 返回时间time对象 replace() 修改并返回新的时间 isocalendar() 返回一个三元组(年，周数，周的天) 日期格式化 类方法 strptime(date_string, format) ，返回datetime对象 对象方法 strftime(format) ，返回字符串 字符串format函数格式化 1234import datetimedt = datetime.datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")print(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))print(\"&#123;0:%Y&#125;/&#123;0:%m&#125;/&#123;0:%d&#125; &#123;0:%H&#125;::&#123;0:%M&#125;::&#123;0:%S&#125;\".format(dt)) timedelta对象 datetime2 = datetime1 + timedelta datetime2 = datetime1 - timedelta timedelta = datetime1 - datetime2 构造方法 123- datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) - year = datetime.timedelta(days=365) total_seconds() 返回时间差的总秒数 time模块 time.sleep(secs) 将调用线程挂起指定的秒数（发起一个系统调用，让程序暂停） 解析式列表解析式 语法: [返回值 for 元素 in 可迭代对象 if 条件] 使用中括号[]，内部是for循环，if条件语句可选 返回一个新的列表 列表解析式是一种语法糖： 编译器会优化，不会因为简写而影响效率，反而会因优化而提高了效率。 减少了程序员工作量，减少出错。 简化了代码，但可读性增强，不便于可读。 举例： 获取10以内的偶数12345678#普通even = []for x in range(10): if x % 2 == 0: even.append(x) #解析式even = [x for x in range(10) if x%2 == 0] 思考: 有这样的赋值语句 newlist = [print(i) for i in range(10)]打印出来的是什么？print()把所有的i全打印出来，newlist里面则是10个None 获取20以内的偶数，如果同时是3的倍数，把它打印出来 12[i for i in range(20) if not i % 2 and i % 3 == 0][i for i in range(20) if not i % 2 if i % 3 == 0] 获取20以内2的倍数或者3的倍数，把它打印出来[i for i in range(20) if not i % 2 or i % 3 == 0] “0001.abadicddws” 是ID格式，要求ID格式是以点号分割，左边是4位从1开始的整数，右边是10位随机小写英文字母。请依次生成前100个ID的列表 123456789101112import stringimport randomx= string.ascii_lowercase[\"&#123;:&gt;04&#125;.&#123;&#125;\".format(i,\"\".join(random.choices(x,k = 10))) for i in range(1,8)]['0001.rvverptnre', '0002.beqkpbxhfl', '0003.woxvvayzjo', '0004.wrbnnkelcc', '0005.kpsjowcfvz', '0006.pnqwqzlttc', '0007.wehobydqnf'] 字典解析式 语法： {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}就行了 使用key:value形式 立即返回一个字典用法：1234567&#123;x:(x,x+1) for x in range(10)&#125;&#123;x:[x,x+1] for x in range(10)&#125;&#123;(x,):[x,x+1] for x in range(10)&#125;&#123;[x]:[x,x+1] for x in range(10)&#125; #[x]不可哈希，字典的k要求可哈希&#123;chr(0x41+x):x**2 for x in range(10)&#125;&#123;str(x):y for x in range(3) for y in range(4)&#125; # 输出多少个元素？#会覆盖，返回&#123;0：3，1：3，2：3&#125; 集合解析式 语法 {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}就行了 立即返回一个集合用法12&#123;(x,x+1) for x in range(10)&#125;&#123;[x] for x in range(10)&#125; #[x]是个集合，不能哈希，所以放在集合解析式里面会报错 生成器生成器Generator生成器指的是生成器对象，可以由生成器表达式得到，也可以使用yield关键字得到一个生成器函数，调用这个函数得到一个生成器对象。 生成器函数： 函数体内包含yield语句的函数，返回一个生成器对象，生成器函数的函数体不会立即执行。 生成器对象，是一个可迭代对象，是一个迭代器。 生成器对象，是延迟计算，惰性求值。 next(generator)会从函数的当前位置向后执行到之后碰到的第一个yield语句，会弹出值，并暂停函数执行。 再次执行会执行到下一个yield语句，没有多余的yield语句能执行，如果函数没有显式的return语句，继续调用next函数就会抛出StopIteration异常。 return会导致无法继续获取下一个值，抛出StopIteration异常。 生成器函数，它是函数，不过这个函数不像普通的函数调用时能返回一个合法的值，它返回的是一个还没有求过任何值的生成器对象，用next拨一下才会往后执行一下。 生成器提供了一个send方法，该方法可以和生成器方向沟通。调用send方法，就可以把send的实参传递给yield语句做结果，这个结果可以在等式右边被赋值给其他变量。yield和next一样可以推动生成器启动并执行。 123456789101112131415#举例def gen(): print('line 1') yield 1 print('line 2') yield 2 print('line 3') return 3next(gen()) # line 1next(gen()) # line 1g = gen()print(next(g)) # line 1print(next(g)) # line 2print(next(g, 'End')) # 没有元素给个缺省值print(next(g, 'End')) # 没有元素给个缺省值 生成器的应用 12345678910111213141516171819202122232425262728#计数器def inc(): def counter(): i = 0 while True: i += 1 yield i c = counter() return lambda : next(c)foo = inc()print(foo()) #调用的时候是因为inc()函数返回的是一个匿名函数，而匿名函数的调用方式是（lambda 参数列表：函数体)(),所以调用的时候是foo后要加上（），即也就是inc()()。#等价于def inc(): def counter(): i = 0 while True: i += 1 yield i c = counter() def _inc(): #用到外面的自由变量（c）：闭包 return next(c) return _incfoo = inc() #可调用对象，函数print(foo()) yield fromyield from是python3.3出现的新语法 yield from iterable 是for item in iterable： yield item形式的语法糖。 123456for x in range(1000): yield x #等价于yield from range(1000) 从可迭代对象中一个个拿数据 12345678910def counter(n): #生成器，迭代器 for x in range(n): yield x def inc(n): yield from counter(n) foo = inc(10)print(next(foo))print(next(foo)) 协程coroutine 生成器的高级用法 比进程、线程轻量级 是在用户空间调度函数的一种实现 Python3 asyncio就是协程实现，已经加入到标准库 Python3.5 使用async、await关键字直接原生支持协程 协程调度器实现思路 有2个生成器A、B next(A)后，A执行到了yield语句暂停，然后去执行next(B)，B执行到yield语句也暂停，然后再次调用next(A)，再调用next(B)在，周而复始，就实现了调度的效果 可以引入调度的策略来实现切换的方式 协程是一种非抢占式调度 生成器表达式Generator expression 语法 (返回值 for 元素 in 可迭代对象 if 条件) 列表解析式的中括号换成小括号就行了 返回一个生成器 和列表解析式的区别 生成器表达式是按需计算（或称惰性求值、延迟计算），需要的时候才计算值，返回迭代器，可以迭代，从前到后走完一遍后，不能回头。 列表解析式是立即返回值，返回的不是迭代器，返回可迭代对象列表， 从前到后走完一遍后，可以重新回头迭代。 和列表解析式的对比 计算方式 生成器表达式延迟计算，列表解析式立即计算 内存占用 单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表 生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多 列表解析式构造新的列表需要占用内存 计算速度 单看计算时间看，生成器表达式耗时非常短，列表解析式耗时长 但是生成器本身并没有返回任何值，只返回了一个生成器对象 列表解析式构造并返回了一个新的列表 生成器 可迭代对象(able结尾) 迭代器(or结尾)，是不是迭代器用next（）方法可以检测，iter（）方法可以把一个可迭代对象封装成迭代器。 生成器和迭代器是不同的对象，但都是可迭代对象，生成器对象，就是迭代器对象，迭代器不一定是生成器。 内建函数 标识 id 返回对象的唯一标识，CPython返回内存地址 哈希 hash() 返回一个对象的哈希值 类型 type() 返回对象的类型 类型转换 float() int() bin() hex() oct() bool() list() tuple() dict() set() complex() bytes() bytearray() 输入 input([prompt]) 接收用户输入，返回一个字符串 打印 print(*objects, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) 打印输出，默认使用空格分割、换行结尾，输出到控制台 对象长度 len(s) 返回一个集合类型的元素个数 isinstance(obj, class_or_tuple) 判断对象obj是否属于某种类型或者元组中列出的某个类型 isinstance(True, int) issubclass(cls, class_or_tuple) 判断类型cls是否是某种类型的子类或元组中列出的某个类型的子类 issubclass(bool, int) 绝对值abs(x) x为数值 最大值max() 最小值min() 返回可迭代对象中最大或最小值 返回多个参数中最大或最小值 round(x) 四舍六入五取偶，round(-0.5) pow(x , y) 等价于 x**y range(stop) 从0开始到stop-1的可迭代对象；range(start, stop[, step])从start开始到stop-1结束步长为step的可迭代对象 divmod(x, y) 等价于 tuple (x//y, x%y) sum(iterable[, start]) 对可迭代对象的所有数值元素求和，start：初始值 sum(range(1,100,2)) chr(i) 给一个一定范围的整数返回对应的字符 chr(97) chr(20013) ord(c) 返回字符对应的整数 ord(‘a’) ord(‘中’) sortedsorted(iterable[, key][, reverse] )排序 返回一个新的列表，对一个可迭代对象的所有元素进行排序，默认升序 reverse是反转123sorted([1, 3, 5])sorted([1, 3, 5], reverse=True) #[5， 3 ， 1]sorted(&#123;'c':1, 'b':2, 'a':1&#125;) 翻转 reversed(seq)返回一个翻转元素的迭代器(惰性求值) 12345list(reversed(\"13579\"))&#123; reversed((2, 4)) &#125; # 有几个元素？for x in reversed(['c','b','a']): print(x)reversed(sorted(&#123;1, 5, 9&#125;)) 枚举 enumerate(seq, start=0) 迭代一个序列，返回索引数字和元素构成的二元组start表示索引开始的数字，默认是01234for x in enumerate([2,4,6,8]): print(x)for x in enumerate(\"abcde\"): print(x,end=\" \") 迭代器和取元素 iter(iterable)、next(iterator[, default]) iter将一个可迭代对象封装成一个迭代器next对一个迭代器取下一个元素。如果全部元素都取过了，再次next会抛StopIteration异常12345it = iter(range(5))next(it)it = reversed([1,3,5])next(it) 拉链函数zip(*iterables)像拉链一样，把多个可迭代对象合并在一起，返回一个迭代器将每次从不同对象中取到的元素合并成一个元组 12345list(zip(range(10),range(10)))list(zip(range(10),range(10),range(5),range(10)))dict(zip(range(10),range(10)))&#123;str(x):y for x,y in zip(range(10),range(10))&#125; 过滤数据filter(function, iterable) — &gt;filter object 过滤可迭代对象的元素，返回一个迭代器 function是一个具有一个参数的函数。返回bool 123#例子：过滤出数列中能被3整除的数字In [4]: list(filter(lambda x: x%3 == 0,[1,9,32,3,21,0,-1,123]))Out[4]: [9, 3, 21, 0, 123] reduce：连续计算，连续从一个可迭代对象中获取值，来进行计算，需要从functools模块中导入 映射map(func, *iterables) —-&gt; map object 对多个可迭代对象的元素按照指定的函数进行映射，返回一个迭代器","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python练习","slug":"06python习题代码","date":"2017-08-11T01:00:00.000Z","updated":"2018-12-07T07:48:07.041Z","comments":true,"path":"2017/08/11/06python习题代码/","link":"","permalink":"http://luoqian67.github.io/blog/2017/08/11/06python习题代码/","excerpt":"","text":"打印图形打印锥形12345678910111213141516#给定一个数字和一个符号，打出锥形import mathl = input().split()n = math.floor(math.sqrt((int(l[0])+1)/2))for i in range(-n,n+1): if i &lt; 0 : x = -i print(\" \"*(n-x)+l[1]*(2*x-1)) elif i&gt;1: x = i print(\" \"*(n-x)+l[1]*(2*x-1)) else: print(end=\"\")z = n**2*2-1print(int(l[0])-z) 31 * ******* ***** *** * *** ***** ******* 0 123456#坐标法打印锥形n = 7e = 7//2for i in range(-e,e+1): x = -i if i &lt; 0 else i print(\" \"*(e-x)+ \"*\" * (2*x+1)) ******* ***** *** * *** ***** ******* 打印菱形12345678#打印菱形n = 7e = -(n//2)for i in range(e,n+e): if i&lt;=0: print(\" \"*abs(i)+\"*\"*(n+2*i)) else : print(\" \"*i+\"*\"*(n-2*i)) * *** ***** ******* ***** *** * 打印闪电12345678910#打印闪电n = 7e = n//2for i in range(-e,e+1): if i&lt;0: print(\" \"*abs(i)+ \"*\" * (e+i+1)) elif i == 0: print(\"*\"*n) else: print(\" \"*3+\"*\"*(e-i+1)) * ** *** ******* *** ** * 打印正方形1234567#打印一个边长为n的正方形var = int(input(\"&gt;&gt;\"))for i in range(var): if i ==0 or i == var-1: print(\"*\"*var) else: print(\"*\" + \" \"*(var-2) + \"*\") &gt;&gt;4 **** * * * * **** 123456n = 4for i in range(n): if i % (n-1)==0: print(\"*\"*n) else: print(\"*\"+\" \"*(n-2)+\"*\") **** * * * * **** 12345678#打印一个边长为n的正方形n = int(input(\"&gt;&gt;\"))e = -(n//2)for i in range(e,n+e): if i == e or i == n+e-1: print (\"*\"*n) else : print(\"*\"+\" \"*(n-2)+\"*\") &gt;&gt;6 ****** * * * * * * * * ****** 12345678910111213#统计你输入的每个数字有多少个，按照升序输出l = input().split()l = int(l[0])num = list()num1 = [0]*10while l&gt;0: x = l % 10 num1[x] += 1 num.append(x) l //=10for i in range(10): if num1[i] !=0: print(\"&#123;&#125;:&#123;&#125;\".format(i,num1[i])) 1231013 0:1 1:3 2:1 3:2 1234567891011121314151617181920212223242526272829303132#读数字zz = input().split()a = int(zz[0])l = ['ling','yi','er','san','si','wu','liu','qi','ba','jiu','fu']i = 0li =list()x = ay = abs(a)while abs(x)&gt;0: x = abs(x)//10 i += 1for j in range(i): m = 10**(i-1) y = y// m li.append(y) i -= 1 y = abs(a) % mlength = len(li)if a&gt;0: for i in li: if int(i)&lt;length: print(\"&#123;&#125;\".format(str(l[i])),end=\" \") else: print(\"&#123;&#125;\".format(str(l[i])),end=\"\")else: print(str(l[10]),end=\" \") for i in li: if int(i)&lt;length: print(\"&#123;&#125;\".format(str(l[i])),end=\" \") else: print(\"&#123;&#125;\".format(str(l[i])),end=\"\") -123 fu yi er san 三个数排序1234567891011121314151617181920#只用判断，三个数排序l = list()for i in range(3): l.append(int(input(\"&gt;&gt;\")))if l[0] &gt; l[1]: if l[0] &gt; l[2]: if l[1]&gt;l[2]: print(l[0],l[1],l[2]) else: print(l[0],l[2],l[1]) else: print(l[2],l[1],l[0])else : if l[0] &gt; l[2]: print(l[1],l[0],l[2]) else: if l[1]&lt;l[2]: print(l[2],l[1],l[0]) else: print(l[1],l[2],l[0]) &gt;&gt;1 &gt;&gt;3 &gt;&gt;2 3 2 1 1234567891011#使用max函数，三个数排序l = list()for i in range(3): l.append(int(input(\"&gt;&gt;\")))while l: if len(l) == 1: print(l[0]) break m = max(l) print(m) l.remove(max(l)) &gt;&gt;2 &gt;&gt;3 &gt;&gt;1 3 2 1 123456#使用sort（）函数，三个数排序l = list()for i in range(3): l.append(int(input(\"&gt;&gt;\")))l.sort()l &gt;&gt;1 &gt;&gt;4 &gt;&gt;2 [1, 2, 4] 冒泡法排序（重要）1234567891011121314151617181920#优化后的冒泡法（重要）#l=[1,9,8,5,6,7,4,3,2]l=[1,2,3,4,5,6,7,9,8]length = len(num)count = 0count_swap = 0for i in range(length): flag = False for j in range(length-i-1): count += 1 if l[j] &gt; l[j+1]: tmp = l[j] l[j] = l[j+1] l[j+1] = tmp flag = True count_swap += 1 if not flag: breakprint(l,count,count_swap) [1, 2, 3, 4, 5, 6, 7, 8, 9] 15 1 优化点：可以设定一个标记判断此轮是否有数据交换发生，如果没有发生交换，可以结束排序，如果发生交换，则进行下一轮 最差的排序情况是，初始顺序和目标顺序完全相反，遍历次数1，…,n-1之和n*（n-）/2 最好的排序情况是，初始顺序与目标顺序完全相同，遍历次数n-1 时间复杂度O（n^2） 二分法查找1234567891011121314#二分法查找def banery_serch(list,item): low = 0 high = len(list)-1 while low &lt;= high: mid = (low+high)//2 giss = list[mid] if item == mid: print(Ture) elif item &gt; mid: high = mid - 1 else: low = mid +1my_list = [1,2,3,5,2,6,4,7,9] 给定一个数，输入为几位数，并依次输出12345678910111213141516 #给定一个数，输入为几位数num = int(input(\"&gt;&gt;\"))i = 0flag = Falsewhile num &gt; 0: a = num%10 print(\"a\",a,end=\" \") num = num//10 #给定一个数字判断有几位num = int(input(\"&gt;&gt;\"))i = 1while num &gt;= 10: num = num/10 i += 1print(\"i\",i) &gt;&gt;1234 a 4 a 3 a 2 a 1 12345678910111213 #给定一个数，并依此输出\\nx = '02300'x = int(x)n = 5w = 10000flag = Falsefor i in range(n): y = x // w if flag or y: flag = True print(y,end=\" \") x = x % w w = w //10 2 3 0 0 12345678910111213141516c = int('00211')w = 10000length = 5flag = Falsewhile w: t = c //w if flag: print(t,end=\" \") else: if t: print(t,end=\" \") flag =True else: length -=1 c %= w w //=10 2 1 1 求均值1234567891011a = int(input(\"&gt;&gt;\")) l = list() num = 0 for i in range(a): x = int(input('&gt;&gt;')) if x == None: break else: l.append(x) num = num+l[i] print(num/len(l)) &gt;&gt;3 &gt;&gt;1 1.0 &gt;&gt;3 2.0 &gt;&gt;4 2.6666666666666665 打印乘法表打印倒乘法表123456#打印倒乘法表for i in range(1,10): print(\"\\t\"*(i-1),end=\"\") for j in range(i,10): print (\"&#123;&#125;x&#123;&#125;=&#123;:&lt;&#123;&#125;&#125;\".format(i,j,i*j,2 if j&lt;2 else 3),end=\" \") print() 1x1=1 1x2=2 1x3=3 1x4=4 1x5=5 1x6=6 1x7=7 1x8=8 1x9=9 2x2=4 2x3=6 2x4=8 2x5=10 2x6=12 2x7=14 2x8=16 2x9=18 3x3=9 3x4=12 3x5=15 3x6=18 3x7=21 3x8=24 3x9=27 4x4=16 4x5=20 4x6=24 4x7=28 4x8=32 4x9=36 5x5=25 5x6=30 5x7=35 5x8=40 5x9=45 6x6=36 6x7=42 6x8=48 6x9=54 7x7=49 7x8=56 7x9=63 8x8=64 8x9=72 9x9=81 打印正乘法表12345#打印九九乘法表：for i in range(1,10): for j in range(1,i+1): print(\"&#123;&#125;x&#123;&#125;=&#123;&#125;\\t\".format(j,i,i*j),end=\" \") print() 1x1=1 1x2=2 2x2=4 1x3=3 2x3=6 3x3=9 1x4=4 2x4=8 3x4=12 4x4=16 1x5=5 2x5=10 3x5=15 4x5=20 5x5=25 1x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36 1x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49 1x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64 1x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81 12345#打印九九乘法表：for i in range(1,10): for j in range(1,i+1): print(j,\"x\",i,\"=\",j*i,\" \",end=\" \") print() 1 x 1 = 1 1 x 2 = 2 2 x 2 = 4 1 x 3 = 3 2 x 3 = 6 3 x 3 = 9 1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25 1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36 1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49 1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 8 = 64 1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 9 = 72 9 x 9 = 81 ​ 一到五阶乘之和12345678#一到五阶乘之和a= 1sum = 0for i in range(1,6): a *= i sum += a i += 1print(\"sum =\",sum ) 12345#100内的所有奇数之和a = 0for i in range (1,100,2): a = a+iprint(\"a=\",a) a= 2500 123456#100内的所有奇数之和a = 0for i in range(1,100,2): if not i%2 == 0: a += iprint(\"a=\",a) 斐波那契数列打印100以内的斐波那契数列123456# 打印100以内的斐波那契数列i = 0j = 1while i &lt; 100: print(i,end=\" \") i,j=j,i+j 0 1 1 2 3 5 8 13 21 34 55 89 12345678# 打印100以内的斐波那契数列i = 0j = 1while i&lt;=100: print (i,end=\" \") k = i + j i = j j = k 0 1 1 2 3 5 8 13 21 34 55 89 求斐波那契数列第101项123456789#求斐波那契数列第101项i = 0j = 1m = 1while m&lt;=101: i, j = j, i + j m += 1 print(i) 573147844013817084101 求素数寻常法12345678910111213#求10万内的所有素数import mathn = 100000count = 1for i in range(3,n,2): if i &gt; 10 and i % 5 ==0: continue #所有大于10 的素数中，个位数只有1，3，7，9，所以此处筛出5结尾的 for j in range(3,int(math.sqrt(i)+1),2): if i % j ==0: break else: count += 1print (count) 9592 利用素数列表，空间换时间123456789101112131415161718192021#存储质数#合数一定可以分解为几个质数的乘积，2是质数#质数一定不能整除1和本身之内的整数#使用质数来取模比利用基数取模计算次数更少import mathn = 100000count = 1primenumber = [2]for i in range(3,n,2): flag = False edge = math.sqrt(i) for j in primenumber: if i % j == 0: flag = True break if j &gt; edge: break if not flag: count += 1 primenumber.append(i)print(count) 利用孪生素数123456789101112131415161718#大于3 的素数只有6N-1和6N+1两种形式，如果6N-1和6N+1都是素数便叫作孪生素数import mathn = 100count = 2primenumber = [2,3]step = 2x = 5while x &lt; n: for i in range(3,int(math.sqrt(x)+1),2): if x % i == 0: break else: count += 1 primenumber.append(x) x += step step = 4 if step == 2 else 2print(count)print(primenumber) 埃式筛素数123456789101112#埃式筛素数def eratosthenes(n): IsPrime = [True] * (n + 1) IsPrime[1] = False for i in range(2, int(n ** 0.5) + 1): if IsPrime[i]: for j in range(i * 2, n + 1, i): IsPrime[j] = False return &#123;x for x in range(2, n + 1) if IsPrime[x]&#125;if __name__ == \"__main__\": print (eratosthenes(100)) {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} 杨辉三角计算杨辉三角，普通法12345678910#计算杨辉三角 普通法triangle = [[1],[1,1]]for i in range(2,6): swap = triangle[i-1] cul = [1] for j in range(i-1): cul.append(swap[j]+swap[j+1]) cul.append(1) triangle.append(cul)triangle 计算杨辉三角 补0法12345678910#计算杨辉三角 补0法triangle = [[1]]n = 7for i in range(1,n): swap = triangle[i-1]+[0] cul = [1] for j in range(len(swap)-1): cul.append(swap[j]+swap[j+1]) triangle.append(cul)print(triangle) 杨辉三角，对称法123456789101112#杨辉三角，对称法n=6triangle = [[1],[1,1]]for i in range(2,n): tmp = triangle[-1] cul = [1] * (i+1) for j in range(i//2): cul[j+1] = tmp[j]+tmp[j+1] if i != 2j: cul[-j-2] = cul[j+1] triangle.append(cul)triangle 中点的确定[1][1,1][1,2,1][1,3,3,1][1,4,6,4,1][1,5,10,10,5,1]把整个杨辉三角看成一个左对齐的二维矩阵。i == 2时，在第3行，中点的列索引j==1i == 3时，在第4行，无中点i == 4时，在第5行，中点的列索引j==2得到以下规律，如果i==2j，则有中点 杨辉三角，单列表方法12345678910111213#杨辉三角，单列表解决n = 6row = [1] * nfor i in range(n): z = 1 offset = n - i for j in range(1,i//2+1): val = z + row[j] z = row[j] row[j] = val if i != 2*j: row[-j - offset] = val print(row[:i+1])","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python-内置数据结构","slug":"05python内置数据结构思维导图","date":"2017-07-19T05:15:00.000Z","updated":"2018-12-07T07:44:52.701Z","comments":true,"path":"2017/07/19/05python内置数据结构思维导图/","link":"","permalink":"http://luoqian67.github.io/blog/2017/07/19/05python内置数据结构思维导图/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"python基础","slug":"04python基础","date":"2017-06-30T07:15:17.000Z","updated":"2018-12-07T13:00:08.140Z","comments":true,"path":"2017/06/30/04python基础/","link":"","permalink":"http://luoqian67.github.io/blog/2017/06/30/04python基础/","excerpt":"","text":"基础语法：一.冯诺依曼体系架构：五大部件： CPU:包括运算器和控制器，CPU只和一件设备，内存打交道。 运算器：是完成各类算术运算，逻辑运算，数据传输等数据加工处理。数据是通过总线传输，总线则是使用电信号传输。 控制器：是用于控制程序的执行。 存储器memory：用于记忆程序和数据，例如内存（缺点：掉电易失数据） I 输入设备：将数据或者程序数据传输到计算机中，例如键盘，鼠标。 O 输出设备：将数据或者程序的处理结果展示给用户，例如显示显示器，打印机。 CPU有三级cache，寄存器，cpu临时要计算的数据存储在寄存器中，寄存器的频率和CPU几乎同频率的运算频率，多级缓存则逐级递减。 高级语言和低级语言之间需要一个转换的工具：编译器，解释器。 编译语言：把源代码转换成目标机器的CPU指令。例如：C，C++。解释语言：解释后转换成字节码，运行在虚拟机上，解释器执行中间代码（bytecode）。例如：java，python，C#等语言。 二.程序：算法 + 数据结构 数据是一切程序的核心 数据结构是数据在计算机中的类型和组织方式 算法是处理数据的方式，算法有优劣之分 算法运行时间并不以秒为单位，算法运行时间是从其增速的角度度量的。 python语言类型：python是动态语言、强类型语言。python中：赋值即定义，如果一个变量已经定义，赋值相当于重新定义。（动态语言的特性） 语言的分类： 静态编译语言： 事先声明变量类型，类型不能再改变 编译时检查 动态编译语言： 不用事先声明类型，随时可以赋值为其他类型 编程时不知道是什么类型，很难推断。 强类型语言： 不同类型之间的操作，必须先强制类型转换为同一类型。例：print（’a’+1）弱类型语言： 不同类型之间操作，自动隐式转换，Javascript中console.log(1,+’a’) 重点：什么是动态语言，什么是强类型语言，强弱怎么区分?强弱是一个相对概念，用一个字符串加上一个数字就可判定。 python解释器： 官方Cpython：c语言开发，广泛的python解释器 IPython：一个交互式，功能增强的Cpython PyPy：python语言写的python解释器，JIT（jist type）技术，动态编译python代码。（效率比cpython高）。 Jython：python的源代码编译成java的字节码，跑在JVM上。 IronPython：与Jython类似，运行在.net平台上的解释器，python代码被编译成.net的字节码。 运算符优先级： 算术运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 &gt; 赋值运算符 单目运算符 &gt; 双目运算符 （JVM、PVM）内存管理： 变量无须事先声明，也不需要指定类型（动态语言的特性） python编程中一般无须关心变量的存亡，一般也不用关心内存的管理。 python使用引用技术记录所有对象的引用数： 当对象引用数变为0，它就可以被垃圾回收（GC）的自动回收机制回收(不建议手动管理，会影响性能) 计数增加： 赋值给其他变量就增加引用计数，例如：x=3;y=x. 计数减少： 函数运行结束时，局部变量就会被自动销毁，对象引用计数减少 变量被赋值给其他对象。例如：x=3,y=x（3的计数加一）,x=4（4的计数加一，3的计数减一） 注意：有关性能的时候，就要考虑变量的引用问题，切记尽量不要手动干预，但是该释放内存，还是尽量不释放内存，看需求。注意：垃圾回收还有包括规整，即碎片整理 共享引用：多个变量引用一个对象 ==是判断内容是否相等 is是判断是否指向同一内存空间，使用id来查看内存地址 界限为256，256以下的整数已被python缓存 判断一个东西有多少在引用： 12import syssys.getrefcount(4) False等价布尔值，相当于bool(value) 空集合 空字符串 空字典 空列表 空元组 none对象 0 列表、链表、队列、栈的区别重点：下列四者区别和特点 内存是线性编址的。 列表list：一个队列，一个排列整齐的队伍列表中的个体称作元素，由若干个元素组成列表元素可是是任意对象（数字，字符串，列表，元组，对象）列表内元素有顺序，可以使用索引。列表可以是一个可迭代对象列表是可变的，连续的内存中的顺序结构，通过偏移量在查询（检索起来快）“有顺序”“可索引”“可变”“可迭代”“线性结构”尽量不要使用remove和insert，比较耗时 链表：有序的在内存中分布散落，查询比列表慢，插入比列表快 queue：队列，先进先出不是为了遍历 stack：栈，后进先出 元组修改一般对于返回None的都意味着没有新的产生，就都是就地修改 元组：一个有序的元素组成的集合，不可变对象元组 + 元组，元组*数字，返回一个新元组。并不是改变原先的元组元组是只读的 字符串：是一个字面常量，不可变，可迭代 运算符判断 题 -&gt; 结果 6 or 2 &gt; 1 -&gt; 6 0 or 5 &lt; 4 -&gt; False 5 &lt; 4 or 3 -&gt; 3 2 &gt; 1 or 6 -&gt; True 3 and 2 &gt; 1 -&gt; True 0 and 3 &gt; 1 -&gt; 0 2 &gt; 1 and 3 -&gt; 3 3 &gt; 1and 0 -&gt; 0 print(1 or 2) -&gt; 1 print(0 or 100) -&gt; 100 print(1 and 2) -&gt; 2 print（bool(2)） -&gt; True print(bool(-2)) -&gt; True print(bool(0) -&gt; False 方法： x or y x为 (True) 非零，则返回x x and y x (True)非零，则返回y 非零转换成bool True 0转换成bool是False 拓展：while 1 的效率要比 while True高，因为Ture要先转换成1，然后再转化成二进制 网络传输，big:大端模式， 低字节放在高地址上就是大端模式 高字节放到低地址上就是小端模式 Windows小端模式 mac大端模式 python上下文：使用with方法不用每次都手动关闭文件123with open(\"file.xxx\") as f: for line in f.readlines(): print(line) 使用二进制写文件可以使用一个模块写：pickle.dump(word,file)读：pickle.load(file) 封装和解构： 封装：将多个值使用逗号分隔，结合在一起本质上返回了一个元组，只是省略了小括号t1 = (1,2) # 定义为元组t2 = 1,2 #将1，2封装成元组 解构把右边的元素解开，并顺序的赋给其他变量左边接纳的变量数要和右边解开的元素个数一致使用*变量名接收，但不能单独使用，被*变量名收集后组成一个列表例如： head,*mid,tail = “abcdefghijklmnopqrstuvwxyz” 例：12345temp = aa = bb = temp等价于a , b = b , a 等号右边使用了封装，而左边使用了解构 set和线性结构 线性结构的查询时间复杂度是O(n)，即随着数据规模的增大而增大 set、dict等结构，内部使用hash值作为key，时间复杂度为O(1),查询时间与数据规模无关。 set的元素要求必须可哈希 ​ 可变的数据结构不可哈希 ​ 元素不可索引 ​ set可以迭代 线性结构： 可迭代 for … in len()可以获取长度 通过下标可访问 可以切片 包括：列表、元组、字符串、bytes、bytearray不可变对象：元组、字符串、bytes 可hash对象：数值型：int、float、complex布尔型：True、False字符串：string、bytestuple，None以上都为不可变类型 可变类型：list，dict，bytearray 可迭代对象 能够通过迭代一次次返回不同的元素的对象。 所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，[‘a’, ‘a’]，虽然这个列表有2个元素，值一样，但是两个’a’是不同的元素 可以迭代，但是未必有序，未必可索引 可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器等 可以使用成员操作符in、not in，in本质上就是在遍历对象 字典的遍历和移除：不能直接遍历删除字典，要使用一个容器记录一个这个字典的key，然后通过遍历key来从字典中删除。 权限判定可以将弄成集合加载到内存中进行集合计算，速度要比在数据库中操作对比快得多。比如说微博的redis OrderedDict有序字典可以记录元素插入的顺序，打印的时候也是按照这个顺序输出打印3.6版本的Python的字典就是记录key插入的顺序（IPython不一定有效果） 应用场景： 假如使用字典记录了N个产品，这些产品使用ID由小到大加入到字典中 除了使用字典检索的遍历，有时候需要取出ID，但是希望是按照输入的顺序，因为输入顺序是有序的 否则还需要重新把遍历到的值排序 光盘、磁盘都是随机访问的","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}]},{"title":"Linux基础-文件管理和重定向","slug":"03Linux基础（二）-文件管理和重定向","date":"2017-04-15T07:18:00.000Z","updated":"2018-12-07T07:34:19.661Z","comments":true,"path":"2017/04/15/03Linux基础（二）-文件管理和重定向/","link":"","permalink":"http://luoqian67.github.io/blog/2017/04/15/03Linux基础（二）-文件管理和重定向/","excerpt":"","text":"Linux基础-文件管理和重定向1. 每一个分区都是一个独立存在的文件系统2. 目录：路径映射符3. 文件文件有两种数据 元数据：描述数据的数据属性 metadata 数据：data FHS：文件系统层级结构标准 4. Linux下的文件类型 -：普通文件 d：目录文件 b：块设备 c：字符设备 l：符号链接文件 p：管道文件pip，FIFO（first in，first out） s：套接字文件：服务加IP端口，作为一个服务的入口。socket 5. 显示当前路径 每个shell和系统进程都有一个当前的工作目录 CWD:current work directory 显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 6. 绝对路径和相对路径绝对路径: 以正斜杠开始 完整的文件的位置路径 可用于任何想指定一个文件名的时候 相对路径名: 不以斜线开始 指定相对于当前工作目录或某目录的位置 可以作为一个简短的形式指定一个文件名 注： 基名:basename 目录名:dirname 7. cd命令cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录 ：cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd - 选项：-P 相关的环境变量： 显示环境变量：printenv PWD：当前目录路径 OLDPWD：上一次目录路径 ~ ：当前用户家目录 ~luo ：用户luo家目录 ~+ ：当前工作目录 ~- ：前一个工作目录 8. 显示目录 列出当前目录的内容或指定目录(显示的数据都是元数据) 用法：ls [options][files_or_dirs] 示例: ls -a ：包含隐藏文件 ls -l ：显示额外的信息 ls -R ：目录递归显示 ls -ld ： 目录和符号链接信息 ls -1 ：文件分行显示 ls –S ：按从大到小排序 ls –t ： 按mtime排序 ls –u ：配合-t选项，显示并按atime从新到旧排序 ls –U : 按目录存放顺序显示 ls –X : 按文件后缀排序 9. 查看文件状态:显示当前文件的时间戳 命令：stat 文件：metadata, data 三个时间戳： access time：访问时间，atime，读取文件内容 modify time: 修改时间, mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变 注意：元数据发生变化，数据不一定变化数据发生变化，元数据一定变化 10. 文件通配符（对文件名做通配）(glob、globing、wildcard) * ：匹配零个或多个字符 ? ：匹配任何单个字符 [0-9] : 匹配数字范围 [a-z] ：字母 [A-Z] ：字母 [wang] : 匹配列表中的任何的一个字符 [^wang] : 匹配列表中的所有字符以外的字符 预定义的字符类：（帮助：man 7 glob） [:digit:]：任意数字，相当于0-9 [:lower:]：任意小写字母 [:upper:]：任意大写字母 [:alpha:]：任意大小写字母 [:alnum:]：任意数字或字母 [:blank:]：水平空白字符 [:space:]：水平或垂直空白字符 [:punct:]：标点符号 [:print:]：可打印字符 [:cntrl:]：控制（非打印）字符 [:graph:]：图形字符 [:xdigit:]：十六进制字符 11. touch命令：touch [OPTION]... FILE... -a 仅改变 atime和ctime -m 仅改变 mtime和ctime -t [[CC]YY]MMDDhhmm[.ss]指定atime和mtime的时间戳 -c 如果文件不存在，则不予创建 例如：touch -m -t 201806300000.00 /etc/passwd 1234567891011121314151617[root@localhost ~]# stat /etc/passwdFile: `/etc/passwd&apos;Size: 1677 Blocks: 8 IO Block: 4096 regular fileDevice: 803h/2051d Inode: 787752 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: (0/ root)Access: 2017-04-10 18:57:44.311586312 +0800Modify: 2017-04-10 18:48:32.693647980 +0800Change: 2017-04-10 18:48:32.693647980 +0800[root@localhost ~]# touch -m -t 201703300000.00 /etc/passwd[root@localhost ~]# stat /etc/passwdFile: `/etc/passwd&apos;Size: 1677 Blocks: 8 IO Block: 4096 regular fileDevice: 803h/2051d Inode: 787752 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2017-04-10 18:57:44.311586312 +0800Modify: 2017-03-30 00:00:00.000000000 +0800Change: 2017-04-10 14:13:22.439425983 +0800 12. 复制：所谓的复制就是创建一个新的空文件，然后在将源文件的数 据流读出来，然后写进去。cp默认不复制目录下的内容，选项：-r：递归复制12341.cp [OPTION]... [-T] SOURCE DEST2.cp [OPTION]... SOURCE... DIRECTORY3.cp [OPTION]... -t DIRECTORY SOURCE...（2.3等同）4.cp SRC DEST SRC是文件： 如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中。 ​ 基于安全，建议为cp命令使用-i选项。 如果DEST是目录：在DEST下新建与原文件同名的文件，并 将SRC中内容填充至新文件中。 cp SRC… DEST SRC…：多个文件 DEST必须存在，且为目录，其它情形均会出错； cp SRC DEST SRC是目录：此时使用选项：-r 如果DEST不存在：则创建指定目录，复制SRC目录中所有文件 至DEST中； 如果DEST存在： 如果DEST是文件：报错 如果DEST是目录 cp的常用选项 1234567891011121314151617-i：覆盖前提示 –n:不覆盖，注意两者顺序-r, -R: 递归复制目录及内部的所有内容-a: 归档，相当于-dR --preserv=all-d：--no-dereference --preserv=links 不复制件，只 复制 链接名--preserv[=ATTR_LIST] （元数据信息） mode: 权限 ownership: 属主、属组 timestamp: （时间戳（atime、mtime不变）（cti会变）） links：链接属性 xattr：拓展属性 context：保持selinux的安全属性 all：以上所有-p: 等同--preserv=mode,ownership,timestamp-v: --verbose 显示提示信息-f: --force 强制-u:--update 只复制源比目标更新文件或目标不存在的文件--backup=numbered 目标存在，覆盖前先备份加数字后缀 cp命令中：具体的流程是： 分配一个空闲的inode号，在inode表中生成新条目，在目录中创建一个目录项，将名称inode编号关联拷贝数据生成新的文件。 13. 移动和重命名文件123mv [OPTION]... [-T] SOURCE DESTmv [OPTION]... SOURCE... DIRECTORYmv [OPTION]... -t DIRECTORY SOURCE... 常用选项： -i: 交互式 -f: 强制 mv操作时，具体的流程是： 如果mv命令的目标和源在相同的文件系统，作为mv 命令用新的文件名创建对应新的目录项，删除旧目录条目对应的旧的文件名，不影响inode（除时间戳）或磁盘上的数据位置：没有数据被移动！ 如果目标和源在一个不同的文件系统， mv相当于cp和rm。 14. 删除rm [OPTION]... FILE... 常用选项： -i: 交互式 -f: 强制删除 -r: 递归 –no-preserve-root : 强制删除/目录，忽略root示例： rm -rf / rm操作时候，具体的逻辑是： 链接数递减，从而释放的inode号可以被重用 把数据块放在空闲列表中 删除目录项 数据实际上不会马上被删除，但当另一个文件使用数据块时将被覆盖。 15. 目录操作tree 显示目录树 -d: 只显示类型为目录 -L level：指定显示的层级数目 -P ：pattern 只显示由指定pattern匹配到的路径123[root@localhost ~]# tree -P *Base* /etc/yum.repos.d//etc/yum.repos.d/└── CentOS-Base.repo mkdir 创建目录 -p: 存在时不报错，且可自动创建所需的各目录 -v: 显示详细信息 -m MODE: 创建目录时直接指定权限123[root@localhost ~]# mkdir -p -v -m 777 /tmp/cmkdir: created directory `/tmp/c&apos;[root@localhost ~]# rmdir 删除空目录 -p: 递归删除父空目录 -v: 显示详细信息 rm -r 递归删除目录树12345678910[root@localhost ~]# mkdir -p -v /tmp/x/y/zmkdir: created directory `/tmp/x&apos;mkdir: created directory `/tmp/x/y&apos;mkdir: created directory `/tmp/x/y/z&apos;[root@localhost ~]# rmdir -p -v /tmp/x/y/zrmdir: removing directory, `/tmp/x/y/z&apos;rmdir: removing directory, `/tmp/x/y&apos;rmdir: removing directory, `/tmp/x&apos;rmdir: removing directory, `/tmp&apos;rmdir: failed to remove directory `/tmp&apos;: Directory not empty 16. 索引节点inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项(inode table)，包含有关文件的信息（ 元数据 包括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 文件引用一个是 inode号 人是通过文件名来引用一个文件 一个目录是目录下的文件名和文件inode号之间的映射 17. 硬链接和软链接详细说明[https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/inde.html#listing1(https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/inde.html#listing1 “转载自IBM博客”)​ 1. 硬链接 创建硬链接会增加额外的记录项以引用文件 对应于同一文件系统上一个物理文件 每个目录引用相同的inode号 创建时链接数递增 删除文件时： rm命令递减计数的链接 文件要存在，至少有一个链接数 当链接数为零时，该文件被删除 不能跨越驱动器或分区 语法: ln filename [linkname ] 注意： 目录不能使用硬链接 2. 软链接 一个符号链接指向另一个文件 ls - l的 显示链接的名称和引用的文件 一个符号链接的内容是它引用文件的名称 可以对目录进行 可以跨分区 指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增 - 加或减目标文件inode的引用计数； 语法：ln -s filename ​​[linkname] 注意:加粗部分为硬链接和软链接的核心区别。 18. 确定文件内容文件可以包含多种类型的数据检查文件的类型，然后确定适当的打开命令或应用程序使用​语法：file [options] &lt;filename&gt;...​常用选项: -b 列出文件辨识结果时，不显示文件名称 -f filelist 列出文件filelist中文件名的文件类型 -F 使用指定分隔符号替换输出文件名后默认的”:”分隔符 -L 查看对应软链接对应文件的文件类型 –help 显示命令在线帮助 19. 标准输入与输出 程序：指令+数据 读入数据：Input 输出数据：Output 打开的文件都有一个fd: file descriptor (文件描述符) Linux给程序提供三种I/O设备 标准输入（STDIN）－0 默认接受来自键盘的输入 标准输出（STDOUT）－1 默认输出到终端窗口 标准错误（STDERR）－2 默认输出到终端窗口 I/O重定向：改变默认位置 输入重定向： 12345[root@localhost ~]# cat &gt; /tmp/luoq.txt &lt;&lt;EOF&gt; woshishui&gt; EOF[root@localhost ~]# cat /tmp/luoq.txtwoshishui 20. 把输出和错误重新定向到文件 STDOUT和STDERR可以被重定向到文件 命令 操作符号 文件名 支持的操作符号包括： > 把STDOUT重定向到文件 2&gt; 把STDERR重定向到文件 &amp;&gt; 把所有输出重定向到文件12345678910[root@localhost ~]# touch /tmp/error.txt;cat /tmp/luo.txt1 2&gt;/tmp/error.txt[root@localhost ~]# cat /tmp/error.txtcat: /tmp/luo.txt1: No such file or directory[root@localhost ~]# [root@localhost ~]# cat /tmp/luoq.txt &amp;&gt; /tmp/error.txt[root@localhost ~]# cat /tmp/error.txtwoshishui[root@localhost ~]# cat /tmp/luoq.txt11 &amp;&gt; /tmp/error.txt[root@localhost ~]# cat /tmp/error.txtcat: /tmp/luoq.txt11: No such file or directory > 文件内容会被覆盖 set –C 禁止将内容覆盖已有文件,但可追加 >| file 强制覆盖 set +C 允许覆盖 >&gt; 原有内容基础上，追加内容 2&gt; 覆盖重定向错误输出数据流 2&gt;&gt; 追加重定向错误输出数据流 标准输出和错误输出各自定向至不同位置 COMMAND &gt; /path/to/file.out 2&gt;/path/to/error.out 合并标准输出和错误输出为同一个数据流进行重定向 &amp;&gt; 覆盖重定向 &amp;&gt;&gt; 追加重定向 COMMAND &gt; /path/to/file.out 2&gt;&amp;1 （顺序很重要） COMMAND &gt;&gt; /path/to/file.out 2&gt;&amp;1 ()：合并多个程序的STDOUT ( cal 2007 ; cal 2008 ) &gt; all. 21. tr命令tr 转换和删除字符​ 语法:tr [OPTION]... SET1 [SET2] 选项： -c –C –complement：取字符集的补集 -d –delete：删除所有属于第一字符集的字符 -s –squeeze-repeats：把连续重复的字符以单独一个字符表示 -t –truncate-set1：将第一个字符集对应字符转化为第二字符集对应的字符 [:alnum:]：字母和数字 [:alpha:]：字母 [:cntrl:]：控制（非打印）字符 [:digit:]：数字 [:graph:]：图形字符 [:lower:]：小写字母 [:print:]：可打印字符 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制字符 例如：tr ‘a-z’ ‘A-Z’&lt; /etc/issue 22. 管道 管道（使用符号“|”表示）用来连接命令 命令1 | 命令2 | 命令3 | … 将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT送到命令3的STDIN STDERR默认不能通过管道转发，可利用2&gt;&amp;1 或 |&amp; 实现 最后一个命令会在当前shell进程的子shell进程中执行来 组合多种工具的功能 ls | tr ‘a-z’ ‘A-Z’ 有些命令不支持管道传输过来的数据，可以加上 - 执行 23. tee命令，一路输入两路输出 命令1 | tee [-a ] 文件名 | 命令2 把命令1的STDOUT保存在文件中，做为命令2的输入 -a 追加 使用： 保存不同阶段的输出 复杂管道的故障排除 同时查看和记录输出 例如：[root@localhost ~]# cat /etc/passwd | tr -d &#39;abc&#39; | tr &#39;d-z&#39; &#39;D-Z&#39; | tee /tmp/luo.txt 24. selinux：安全Linux策略 配置文件在/etc/selinux/config ： 查看状态的命令：getenforce 三种状态： enforcing：强制：违反规则不能运行 permissive许可：可以允许运行，但是会记录，用来后期的审计 disabled：禁用：关闭selinux 25. 历史命令：history的环境变量配置：HISTCONTROL -ignoredups（忽略重复） -ignorespace（忽略空格） -ignoreboth（忽略所有) 26.权限认证；授权：审计 Authentication；Authorization；Adition","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}]},{"title":"umask总结","slug":"02umask总结","date":"2017-03-29T01:14:00.000Z","updated":"2018-12-07T07:25:07.402Z","comments":true,"path":"2017/03/29/02umask总结/","link":"","permalink":"http://luoqian67.github.io/blog/2017/03/29/02umask总结/","excerpt":"","text":"umask总结umask：反向掩码 umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask 如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定 umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~/.bashrc","categories":[],"tags":[],"keywords":[]},{"title":"Linux基础-权限管理","slug":"01Linux基础（一）-权限管理","date":"2017-03-28T01:11:00.000Z","updated":"2018-12-07T07:24:35.405Z","comments":true,"path":"2017/03/28/01Linux基础（一）-权限管理/","link":"","permalink":"http://luoqian67.github.io/blog/2017/03/28/01Linux基础（一）-权限管理/","excerpt":"","text":"Linux基础-权限管理一.权限管理1.用户权限：认证：1.1 Authentication；授权：Authorization；审计：Adition 1.2 Linux用户和组的主要配置文件： /etc/passwd：用户及其属性信息（名称、UID、主组ID等） /etc/group：组及其属性信息 /etc/shadow：用户密码及其相关属性 /etc/gshadow：组密码及其相关属性 1.3 安全上下文：进程代表用户在进行：谁启动了进程，进程就拥有谁的身份（以进程（process）发起者的身份运行）。 root:/bin/cat mage:/bin/cat 1.4 用户1.4.1 用户User： 令牌token,identity Linux用户：Username/UID 用户级别： 管理员：root, 0 普通用户：1-65535 系统用户：1-499, 1-999 （CentOS7） 对守护进程获取资源进行权限分配 登录用户:500+, 1000+（CentOS7） 交互式登录 1.4.2 passwd文件格式： login name：登录用名（wang） passwd：密码 (x) UID：用户身份编号 (1000) GID：登录默认所在组编号 (1000) GECOS：用户全名或注释 home directory：用户主目录 (/home/wang) shell：用户默认使用shell (/bin/bash) 123tcpdump:x:72:72::/:/sbin/nologinvampire:x:500:500:vampire:/home/vampire:/bin/bashmysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/false 1.4.3 shadow文件格式： 登录用名 用户密码:一般用sha512加密 从1970年1月1日起到密码最近一次被更改的时间 密码再过几天可以被变更（0表示随时可被变更） 密码再过几天必须被变更（99999表示永不过期） 密码过期前几天系统提醒用户（默认为一周） 密码过期几天后帐号会被锁定 从1970年1月1日算起，多少天后帐号失效 123tcpdump:!!:17735::::::vampire:$6$yk7XOpZX0ZngOz6D$qVI/.Q7Ch7M.KRfjsPC. WTiN9w2qJgUofENaFlnLxXpvzIN/lICVwcIme1b3LHMixqXxnEIGkgepuUIpsoadU1:1773 5:0:99999:7:::mysql:!!:17737:::::: 1.4.4 用户创建语法：useradd [options] LOGIN -u UID -o 配合-u 选项，不检查UID的唯一性 -g GID：指明用户所属基本组，可为组名，也可以GID -c “COMMENT”：用户的注释信息 -d HOME_DIR: 以指定的路径(不存在)为家目录 -s SHELL: 指明用户的默认shell程序 ​ 可用列表在/etc/shells文件中 -G GROUP1[,GROUP2,…]：为用户指明附加组，组须事先存在 -N 不创建私用组做主组，使用users组做主组 -r: 创建系统用户 CentOS 6: ID&lt;500，CentOS 7: ID&lt;1000 -m 创建家目录，用于系统用户 -M 不创建家目录，用于非系统用户 123[root@localhost ~]# useradd -u 111 luoqian -c \"vamp\" -s /bin/csh -m[root@localhost ~]# tail -1 /etc/passwdluoqian:x:111:501:vamp:/home/luqoian:/bin/csh 1.4.5 用户属性的修改：语法：`usermod [OPTION] login -u UID: 新UID -g GID: 新主组 -G GROUP1[,GROUP2,…[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项 -s SHELL：新的默认SHELL -c ‘COMMENT’：新的注释信息 -d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用-m选项 -l login_name: 新的名字； -L: lock指定用户,在/etc/shadow 密码栏的增加 ! -U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉 -e YYYY-MM-DD: 指明用户账号过期日期 -f INACTIVE: 设定非活动期限 1.4.6 删除用户：语法：userdel [OPTION]... login -r: 删除用户家目录 1.4.7 切换用户或以其他用户身份执行命令语法：su [options...] [-] [user [args...]] 切换用户的方式： su UserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录 su - UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换 root su至其他用户无须密码；非root用户切换时需要密码 换个身份执行命令： su [-] UserName -c &#39;COMMAND&#39; 选项：-l --login ​ su -l UserName 相当于 su - UserName 1.4.8 修改密码语法：passwd [OPTIONS] UserName:修改指定用户的密码 常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 1.5 组1.5.1 Linux组的类别 用户的主要组（primary group） 用户必须属于一个且只有一个主组 组名同用户名，且仅包含一个用户，私有组 用户的附加组（supplementary group） 一个用户可以属于零个或多个附加组 1.5.2 组group： Linux组：Groupname/GID 管理员组：root, 0 普通组： 系统组：1-499, 1-999（CENTOS7） 普通组：500+, 1000+（CENTOS7） 1.5.3 group文件格式 群组名称：就是群组名称 群组密码：通常不需要设定，密码是被记录在 /etc/gshadow GID：就是群组的 ID 以当前组为附加组的用户列表(分隔符为逗号) 1234[root@localhost ~]# cat /etc/grouproot:x:0:bin:x:1:bin,daemondaemon:x:2:bin,daemon 1.5.4 gshadow文件格式 群组名称：就是群组名称 群组密码： 组管理员列表：组管理员的列表，更改组密码和成员 以当前组为附加组的用户列表：(分隔符为逗号) 12345[root@localhost ~]# cat /etc/gshadowroot:::bin:::bin,daemondaemon:::bin,daemonsys:::bin,adm 1.5.5 创建组：语法：groupadd [OPTION]... group_name -g GID: 指明GID号；[GID_MIN, GID_MAX] -r: 创建系统组 CentOS 6: ID&lt;500 CentOS 7: ID&lt;1000 1.5.6 修改和删除组： 组属性修改：groupmod语法：groupmod [OPTION]… group 12-n group_name: 新名字-g GID: 新的GID 组删除：groupdel groupdel GROUP 1.5.7 更改组密码1234567组密码：gpasswdgpasswd [OPTION] GROUP -a user 将user添加至指定组中 -d user 从指定组中移除用户user -A user1,user2,... 设置有管理权限的用户列表newgrp命令：临时切换主组 如果用户本不属于此组，则需要组密码 2 文件权限：2.1 文件的权限主要针对三类对进行定义 owner: 属主, u，文档所有者 group: 属组, g，文档所属组用户 other: 其他, o，其他用户 每个文件针对每类访问者都义了三种权限 r: Readable：读 w: Writable：写 x: eXcutable：执行 2.2 文件和目录权限的区别： 文件： r: 可使用文件查看类工具获取其内容 w: 可修改其内容 x: 可以把此文件提请内核启动为一个进程 目录： r: 可以使用ls查看此目录中文件列表 w: 可在此目录中创建文件，也可删除此目录中的文件 x: 可以使用ls -l查看此目录中文件列表，可以cd进入此目录 2.3 修改文件权限：12345678910chmod [OPTION]... OCTAL-MODE FILE... -R: 递归修改权限（改目录的时候想修改目录内部所有文件的权限，但是不建议）chmod [OPTION]... MODE[,MODE]... FILE... MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]... --reference=RFILE FILE... （referance）参考RFILE文件的权限，将FILE的修改为同RFILE 2.4 修改文件的属组和属主： 修改文件的属主：chown chown [OPTION]… [OWNER][:[GROUP]] FILE… 用法： OWNER OWNER:GROUP :GROUP 命令中的冒号可用.替换 -R: 递归 语法：-chown [OPTION]... --reference=RFILE FILE... 修改文件的属组：chgrp 123chgrp [OPTION]... GROUP FILE...chgrp [OPTION]... --reference=RFILE FILE...-R 递归 注意： - (权限一定要给全，不然会从左边补全，例如如果给77，则默认为077） - (目录一定要有执行权限，普通文件不能随便给执行权限（防止一些恶意文件留后门）)， - (只写+w,只有属主加写权限) 2.5 新建文件和目录的默认权限 umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask 如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定 umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~/.bashrc 2.6 访问控制列表 ACL：Access Control List，实现灵活的权限管理 除了文件的所有者，所属组和其它人，可以对更多的用户设置权限 CentOS7 默认创建的xfs和ext4文件系统具有ACL功能 CentOS7 之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加 tune2fs –o acl /dev/sdb1 mount –o acl /dev/sdb1 /mnt/test ACL生效顺序：所有者，自定义用户，自定义组，其他人 为多用户或者组的文件和目录赋予访问权限rwx mount -o acl /directory getfacl file |directory setfacl -m u:wang:rwx file|directory setfacl -Rm g:sales:rwX directory setfacl -M file.acl file|directory setfacl -m g:salesgroup:rw file| directory setfacl -m d:u:wang:rx directory setfacl -x u:wang file |directory setfacl -X file.acl directory123456789101112131415161718[root@localhost ~]# getfacl linux222.txt# file: linux222.txt# owner: root# group: root user::rw-group::r--other::r--[root@localhost ~]# setfacl -m u:vampire:wx linux222.txt[root@localhost ~]# getfacl linux222.txt# file: linux222.txt# owner: root# group: rootuser::rw-user:vampire:-wxgroup::r--mask::rwxother::r--","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}]}]}