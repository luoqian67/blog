{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"Luo Qian","url":"http://luoqian67.github.io/blog"},"pages":[],"posts":[{"title":"云计算使用简介","slug":"阿里云平台使用安全","date":"2019-01-01T12:58:17.000Z","updated":"2019-01-19T10:05:42.195Z","comments":true,"path":"2019/01/01/阿里云平台使用安全/","link":"","permalink":"http://luoqian67.github.io/blog/2019/01/01/阿里云平台使用安全/","excerpt":"","text":"云计算的三种服务方式 IAAS（基础设置即服务）：虚拟的服务器、存储、网络 PASS（平台即服务）：中间件、应用服务器平台等 SAAS（软件即服务)：行业应用，CRM，ERP、OA等 常见的安全风险IT系统风险构成：按照等保的划分维度包括： 物理和环境安全：包括机房供电、温湿度控制、防风防雨防雷措施等 网络和通信安全：包括网络架构、边界防护、访问控制、入侵防范、通信加密等 设备和计算安全：包括入侵防范、恶意代码防范、身份鉴别、访问控制、集中管控和安全审计等 应用和数据安全：包括安全审计、数据完整性和保密信 云上安全风控的服务方式ALL in one部署安全注意事项： 登陆安全 账号授权管理 服务器安全漏洞 应用访问攻击 数据备份和加密 网络攻击风险 应用和数据分离新增安全注意事项： 数据传输安全 网络通信安全 数据库访问白名单授权 数据库的备份和容灾 应用集群部署新增安全注意事项： 服务器访问授权 服务器安全区域隔离 负载均衡加密访问 动静资源分离新增安全注意事项： 云存储数据备份和加密 云存储数据容灾 云上账号和资源的安全管理云上账号安全的指导原则账号安全 登录验证 配置强密码策略 定期轮转用户登陆密码 账号授权 遵循最小授权原则 及时撤销不再需要的权限 权限分配 不要为根账号创建访问密钥 将用户管理、权限管理与资源管理分离","categories":[{"name":"云计算","slug":"云计算","permalink":"http://luoqian67.github.io/blog/categories/云计算/"}],"tags":[{"name":"云计算，阿里云","slug":"云计算，阿里云","permalink":"http://luoqian67.github.io/blog/tags/云计算，阿里云/"}]},{"title":"excel合并表格","slug":"excel合并表格用","date":"2018-10-05T12:15:17.000Z","updated":"2018-12-11T12:55:58.187Z","comments":true,"path":"2018/10/05/excel合并表格用/","link":"","permalink":"http://luoqian67.github.io/blog/2018/10/05/excel合并表格用/","excerpt":"","text":"写在前面，朋友前几天找到我江湖救急，问我怎么合并多张表格，虽然是计算机专业毕业的我但是真的没做过几张表格啊，最后找了好多网站的资料介绍，找到下面可行的方法，回馈给需要的朋友。 在一个excel文件中如果存在几张附表，就可以使用下面的VBA代码合并附表到一个主表中。 方法是先新建一个主表，右键最下面的主表，然后选择查看代码，贴入下面的代码。然后保存运行即可发现已经合并成功。 方案一：1234567891011121314151617Sub main()For Each sh In SheetsIf sh.Name &lt;&gt; \"总表\" Theni = sh.Range(\"I65536\").End(3).Rowk = Range(\"A65536\").End(3).Rowsh.Range(\"A1:I50\" &amp; i).Copy Range(\"A\" &amp; k + 1)End IfNextEnd Sub 方案二：12345678910111213141516171819202122Sub main()Application.ScreenUpdating = FalseFor j = 1 To Sheets.CountIf Sheets(j).Name &lt;&gt; ActiveSheet.Name ThenX = Range(&quot;A65536&quot;).End(xlUp).Row + 1Sheets(j).UsedRange.Copy Cells(X, 1)End IfNextRange(&quot;B1&quot;).SelectApplication.ScreenUpdating = TrueMsgBox &quot;当前工作簿下的全部工作表已经合并完毕！&quot;, vbInformation, &quot;提示&quot;End Sub","categories":[{"name":"杂项教程","slug":"杂项教程","permalink":"http://luoqian67.github.io/blog/categories/杂项教程/"}],"tags":[{"name":"excel","slug":"excel","permalink":"http://luoqian67.github.io/blog/tags/excel/"}]},{"title":"win10win7打开软件提示系统资源不足,无法完成请求服务的解决方法","slug":"win10win7打开软件提示系统资源不足,无法完成请求服务的解决方法","date":"2018-08-02T12:15:17.000Z","updated":"2018-08-11T01:49:09.751Z","comments":true,"path":"2018/08/02/win10win7打开软件提示系统资源不足,无法完成请求服务的解决方法/","link":"","permalink":"http://luoqian67.github.io/blog/2018/08/02/win10win7打开软件提示系统资源不足,无法完成请求服务的解决方法/","excerpt":"","text":"有些win7、win10用户莫名的遇到了一个问题，就是安装部分软件的时候提示系统资源不足,无法完成请求服务，刚开始以为是系统缺少了某些组件，结果发现是国外杀毒迈克菲（McAfee）在捣鬼。 关闭迈克菲的实时防护或者卸载即可。","categories":[{"name":"杂项教程","slug":"杂项教程","permalink":"http://luoqian67.github.io/blog/categories/杂项教程/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://luoqian67.github.io/blog/tags/windows/"}]},{"title":"在eclipse中部署项目web有时候访问jsp会抛出以下类似的异常信息","slug":"在eclipse中部署项目web有时候访问jsp会抛出以下类似的异常信息","date":"2018-07-25T12:58:17.000Z","updated":"2018-12-11T13:02:20.492Z","comments":true,"path":"2018/07/25/在eclipse中部署项目web有时候访问jsp会抛出以下类似的异常信息/","link":"","permalink":"http://luoqian67.github.io/blog/2018/07/25/在eclipse中部署项目web有时候访问jsp会抛出以下类似的异常信息/","excerpt":"","text":"在eclipse中部署项目web有时候访问jsp会抛出以下类似的异常信息org.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp 部署web项目，如果抛出此异常。请保证 standard.jar与jstl.jar 两个jar包是否 在部署的项目中存在，如果不存在，请把，这两个包加入 /WEB-INF/lib 中。然后保证jsp中引用的版本地址 和 此版本地址是一致的： &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot;prefix=&quot;c&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;prefix=&quot;f&quot;%&gt;&lt;%@ taglib prefix=&quot;fn&quot;uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt; CSDN下载路径：https://download.csdn.net/download/weixin_42216574/10416519","categories":[{"name":"杂项教程","slug":"杂项教程","permalink":"http://luoqian67.github.io/blog/categories/杂项教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://luoqian67.github.io/blog/tags/Java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://luoqian67.github.io/blog/tags/eclipse/"}]},{"title":"centos6下部署Java Web项目","slug":"centos6下部署Java Web项目","date":"2018-07-25T12:58:17.000Z","updated":"2018-12-11T12:55:35.603Z","comments":true,"path":"2018/07/25/centos6下部署Java Web项目/","link":"","permalink":"http://luoqian67.github.io/blog/2018/07/25/centos6下部署Java Web项目/","excerpt":"","text":"在云服务器上安装好系统后： 1.先查看系统上有无原有的旧版本的mysql；tomcat；java。 若有则先卸载；卸载命令使用12yum -y remove mysql*;yum -y remove mysql*; 2.附上能下载的jdk1.7的链接，先下载jdk1.7后tomcat7放在本地目录下； #wget http://zhibo100.oss-cn-hangzhou.aliyuncs.com/software/jdk-7u79-linux-x64.tar.gz #wget http://zhibo100.oss-cn-hangzhou.aliyuncs.com/software/apache-tomcat-7.0.59.tar.gz 3.在/usr目录下建立一个java目录，java下建立jdk和tomcat目录用来存放解压好的文件； 4.解压jdk ，tomcat，命令如下； # tar -zxvf jdk-7u79-linux-x64.tar.gz -C /usr/java/ # tar -xzvf apache-tomcat-7.0.59.tar.gz -C /usr/java/tomcat/ 5.配置环境变量 配置JAVA环境变量并检测 1vim /etc/profile 在文件末尾加上 #java JAVA_HOME=/usr/java/jdk1.7.0_79 JRE_HOME=${JAVA_HOME}/jre CLASS_PATH=${JAVA_HOME}/lib PATH=$PATH:${JAVA_HOME}/bin export PATH JAVA_HOME CLASS_PATH PATH 保存退出 6.刷新环境变量123456789[root@luo ~]# source /etc/profile[root@luo ~]# java -versionjava version &quot;1.7.0_79&quot;Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode) 如图说明Java安装成功。 7.开启tomcat：123cd /usr/java/tomcat/apache-tomcat-7.0.59/bin/./startup.sh 验证能否访问，在浏览器下输入localhost：8080 能出现tomcat的页面就行了。 设置tomcat自启动， 在进去 vim /etc/rc.d/rc.local 最下面加入：12345export JDK_HOME=/usr/java/jdk1.7.0_79export JAVA_HOME=/usr/java/jdk1.7.0_79/usr/java/tomcat/apache-tomcat-7.0.59/bin/startup.sh 然后重启服务器试验。 8.安装mysql；因为yum源中默认没有mysql的安装源，所以需要手动添加，按照下面的语句顺序能顺利安装。 1wget https://dev.mysql.com/get/mysql57-community-release-el6-9.noarch.rpm b.安装用来配置mysql的yum源的rpm包 123rpm -Uvh mysql57-community-release-el6-9.noarch.rpm或yum localinstall -y mysql57-community-release-el6-9.noarch.rpm 安装成功后在/etc/yum.repos.d/下会多出几个mysql的yum源的配置 然后安装mysql yum install mysql-community-server 开启mysql服务1service mysqld start mysql安装成功后创建的超级用户‘root‘@’localhost’的密码会被存储在/var/log/mysqld.log，可以使用如下命令查看密码1grep &apos;temporary password&apos; /var/log/mysqld.log 由于mysql修改密码时候如果你输入简单密码会报错，将不能修改密码，使用初始密码更改MySQL检测密码的规则，代码如下： 首先，进入MySQL 然后修改validate_password_policy参数的值（可参考mysql报错博客） 12345mysql&gt;setglobal validate_password_policy=0;setglobal validate_password_length=1;setglobal validate_password_mixed_case_count=2; 然后通过mysql安全设置 12345678910111213141516171819202122232425mysql_secure_installation修改密码# mysql_secure_installation Enter current password for root (enter for none): ← 回车 Set root password? [Y/n] ← 回车 New password: ← 123456 Re-enter new password: ← 123456 Remove anonymous users? [Y/n] ← 回车(删除匿名用户) Disallow root login remotely? [Y/n] ← 回车(禁止远程root登录) Remove test database and access to it? [Y/n] ← 回车(删除test库) Reload privilege tables now? [Y/n] ← 回车 Thanks for using MySQL! # mysql -u root -p Enter password:123456 设置远程登录： CREATE USER &apos;mysql&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 清除缓存：mysql&gt; flush privileges; 设置默认编码集 1234567# vim /etc/my.cnf character-set-server=utf8# /etc/init.d/mysqld restart # mysqld --version 最后把导出的war文件放到服务器中tomcat下的webapps目录下即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"http://luoqian67.github.io/blog/tags/Java/"}]},{"title":"在Windows10中给右键中添加新建的方式","slug":"在Windows10中添加新建的右键","date":"2018-04-26T12:15:17.000Z","updated":"2018-12-11T13:02:31.992Z","comments":true,"path":"2018/04/26/在Windows10中添加新建的右键/","link":"","permalink":"http://luoqian67.github.io/blog/2018/04/26/在Windows10中添加新建的右键/","excerpt":"","text":"使用管理员权限打开window命令提示符输入如下即可cmd /k reg add &quot;HKEY_CLASSES_ROOT\\Directory\\Background\\shellex\\ContextMenuHandlers\\New&quot; /ve /t REG_SZ /d {D969A300-E7FF-11d0-A93B-00A0C90F2719} /f","categories":[{"name":"杂项教程","slug":"杂项教程","permalink":"http://luoqian67.github.io/blog/categories/杂项教程/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://luoqian67.github.io/blog/tags/windows/"}]},{"title":"元编程","slug":"20元编程","date":"2018-02-10T00:00:00.000Z","updated":"2018-12-13T13:16:31.315Z","comments":true,"path":"2018/02/10/20元编程/","link":"","permalink":"http://luoqian67.github.io/blog/2018/02/10/20元编程/","excerpt":"","text":"元编程元编程的概念来自LISP和smalltalk。 用来生成代码的程序称为元程序metaprogram，编写这种程序就称为元编程metaprogramming。python主要通过反射来实现元编程。 Python中所有非object类都继承自Object类所有类的类型包括type类都是typetype类继承自object类，object类的类型也是type类 type类type构建类123456789class type(object): def __init__(cls, what, bases=None, dict=None): # known special case of type.__init__ \"\"\" type(object_or_name, bases, dict) type(object) -&gt; the object's type type(name, bases, dict) -&gt; a new type # (copied from class doc) \"\"\" pass 构建 1234567891011121314def __init__(self): self.x = 1000 def show(self): return self.__dict__XClass = type('myclass', (object,), &#123;'a':100, 'b': 'string', 'show':show, '__init__':__init__&#125;) # 字典是类属性 print(XClass) print(XClass) print(XClass.__name__) print(XClass.__dict__) print(XClass.mro()) XClass().show() 可以借助type构造任何类，用代码生成代码，这就是元编程。 构建元类一个类可以继承自type类 12345class ModelMeta(type): def __new__(cls, *args): print(cls) print(*args) return super().__new__(cls, *args) 继承自type，ModelMeta就是元类，它可以创建出其他类。 1234567891011121314151617181920212223242526272829class ModelMeta(type): # 继承自type def __new__(cls, name, bases, attrs: dict): print(cls) print(name) print(bases) print(attrs) print(\"--------\") return super().__new__(cls, name, bases, attrs)# 第一种 使用metaclass关键字参数指定元类class A(metaclass=ModelMeta): id = 100 def __init__(self): self.x = 2000# 第二种 B继承自A后，依然是从ModelMeta的类型class B(A): # 继承 pass# 第三种 元类就可以使用下面的方式创建新的类C = ModelMeta('Class', (), &#123;'y': 200&#125;)print(type(A))print(type(B))print(type(C)) 从运行结果还可以分析出__new__(cls, *args) 的参数结构中间是一个元组 (&#39;A&#39;, (), {&#39;__init__&#39;: &lt;function A.__init__ at 0x0000000000B6E598&gt;, &#39;__module__&#39;:&#39;__main__&#39;, &#39;__qualname__&#39;: &#39;A&#39;, &#39;id&#39;: 100})对应(name, bases, dict) 从运行结果可以看出，只要元类是ModelMeta，创建类对象时，就会调用ModelMeta的__new__方法 元类的应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Field: def __init__(self, fieldname=None, pk=False, nullable=False): self.fieldname = fieldname self.pk = pk self.nullable = nullable def __repr__(self): return \"&lt;Field &#123;&#125;&gt;\".format(self.fieldname)class ModelMeta(type): # 继承自type def __new__(cls, name, bases, attrs: dict): print(cls) print(name) print(bases) print(attrs, '-------------') # 使用元类动态注入表名 tblname = '__tablename__' if tblname not in attrs.keys(): attrs[tblname] = name primarykeys = [] for k, v in attrs.items(): if isinstance(v, Field): print(k) print(v) print(v.fieldname) if v.fieldname is None: v.fieldname = k # 没有名字则使用属性名 if v.pk: primarykeys.append(v) attrs['__primarykeys__'] = primarykeys return super().__new__(cls, name, bases, attrs)class ModelBase(metaclass=ModelMeta): passclass Student(ModelBase): id = Field(pk=True, nullable=False) name = Field('username', nullable=False) age = Field()print('----------------')print(Student.__dict__) 元编程的总结元类是制造类的工厂，是生成类的类。构造好元类，就可以在类定义时，使用关键字参数metaclass指定元类，可以使用最原始的metatype(name,bases, dict)的方式构造一个类。元类的 __new__()方法中，可以获取元类信息、当前类、基类、类属性字典。 元编程一般用于框架开发中。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"按位与、或、非、异或总结","slug":"19按位与、或、非、异或的总结","date":"2018-01-05T12:15:17.000Z","updated":"2018-12-07T13:38:24.526Z","comments":true,"path":"2018/01/05/19按位与、或、非、异或的总结/","link":"","permalink":"http://luoqian67.github.io/blog/2018/01/05/19按位与、或、非、异或的总结/","excerpt":"","text":"位运算符有：&amp;(按位与)、|(按位或)、^(按位异或)、~ (按位取反)。优先级从高到低，依次为~、&amp;、^、|1. 按位与操作 0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1 例子：10&amp;9： 0000 1010 &amp; 0000 1001 = 0000 1000 = 8 负数按补码形式参加按位与运算 “与运算”的特殊用途： （1）清零。如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 （2）取一个数中指定位方法：找一个数，对应X要取的位，该数的对应位为1，其余位为零，此数与X进行“与运算”可以得到X中的指定位。例：设X=10101110，取X的低4位，用 X &amp; 0000 1111 = 0000 1110 即可得到；还可用来取X的2、4、6位。 2. 按位或运算符（|） 参加运算的两个对象，按二进制位进行“或”运算。 运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1； 即 ：参加运算的两个对象只要有一个为1，其值为1。 例如:3|5 即 0000 0011 | 0000 0101 = 0000 0111 因此，3|5的值得7。 另，负数按补码形式参加按位或运算。 “或运算”特殊作用： （1）常用来对一个数据的某些位置1。 方法：找到一个数，对应X要置1的位，该数的对应位为1，其余位为零。此数与X相或可使X中的某些位置1。 例：将X=10100000的低4位置1 ，用 X | 0000 1111 = 1010 1111即可得到。 3. 异或运算符（^） 参加运算的两个数据，按二进制位进行“异或”运算。 运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 例如：10^-9 即 0000 1010 ^ 1111 0111 = 1111 1101(补码) 原码即为1000 0011 即10^-9 = -3 “异或运算”的特殊作用： （1）使特定位翻转 找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。 例：X=10101110，使X低4位翻转，用X ^ 0000 1111 = 1010 0001即可得到。 （2）与0相异或，保留原值 ，X ^ 0000 0000 = 1010 1110。 交换a和b |方法一|方法二||:—:|:—:||1.a=a^b | 1.a= a-b||2.b=b^a | 2.b= a+b||3.a=a^b | 3.a= b-a| 4. 取反运算符（~） 参加运算的一个数据，按二进制位进行“取反”运算。 运算规则：~1=0； ~0=1； 即：对一个二进制数按位取反，即将0变1，1变0。 使一个数的最低位为零，可以表示为：a&amp;~1。 ~1的值为1111111111111110，再按“与”运算，最低位一定为0。因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 5. 左移运算符（&lt;&lt;） 将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 例：a = a &lt;&lt; 2 将a的二进制位左移2位，右补0， 左移1位后a = a * 2; 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。 6. 右移运算符（&gt;&gt;） 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 操作数每右移一位，相当于该数除以2。 例如：a = a &gt;&gt; 2 将a的二进制位右移2位， 左补0 or 补1 得看被移数是正还是负。 >> 运算符把 expression1 的所有位向右移 expression2 指定的位数。expression1 的符号位被用来填充右移后左边空出来的位。向右移出的位被丢弃。 例如，下面的代码被求值后，temp 的值是 -4： var temp = -14 &gt;&gt; 2 -14 （即二进制的 11110010）右移两位等于 -4 （即二进制的 11111100）。 无符号右移运算符（&gt;&gt;&gt;） >>> 运算符把 expression1 的各个位向右移 expression2 指定的位数。右移后左边空出的位用零来填充。移出右边的位被丢弃。 7. 复合赋值运算符 位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是： 位运算符 例子 相当于 &amp;= 例：a &amp;= b 相当于a=a &amp; b \\ = 例：a \\ = b 相当于a=a \\ b >>= 例：a &gt;&gt;= b 相当于a=a &gt;&gt; b &lt;&lt;= 例：a &lt;&lt;= b 相当于a=a &lt;&lt; b ^= 例：a ^= b 相当于a=a ^ b 运算规则：和前面讲的复合赋值运算符的运算规则相似。 不同长度的数据进行位运算 如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。 以“与”运算为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行“与”运算，右端对齐后，左边不足的位依下面三种情况补足， （1）如果整型数据为正数，左边补16个0。（2）如果整型数据为负数，左边补16个1。 （3）如果整形数据为无符号数，左边也补16个0。 如：long a=123;int b=1;计算a &amp; b。a 0000 0000 0111 1011 &amp;b 0000 0000 0000 0001= 0000 0000 0000 0001如：long a=123;int b=-1;计算a &amp; b。a 0000 0000 0111 1011 &amp;b 1111 1111 1111 1111= 0000 0000 0111 1011如：long a=123;unsigned int b=1;计算a &amp; b。a 0000 0000 0111 1011b 0000 0000 0000 0001= 0000 0000 0000 0001 8. 原码、反码、补码，负数表示法 原码:5 =&gt; 0b101，1 =&gt; 0b1 ，-1 =&gt; -0b1， bin(-1) 反码: 正数的反码与原码相同；负数的反码符号位不变其余按位取反 补码: 正数的补码与原码相同；负数的补码符号位不变其余按位取反后+1","categories":[{"name":"杂项","slug":"杂项","permalink":"http://luoqian67.github.io/blog/categories/杂项/"}],"tags":[{"name":"按位计算","slug":"按位计算","permalink":"http://luoqian67.github.io/blog/tags/按位计算/"}]},{"title":"python-日志分析步骤","slug":"18日志分析步骤","date":"2017-12-15T16:00:00.000Z","updated":"2018-12-11T13:03:34.493Z","comments":true,"path":"2017/12/16/18日志分析步骤/","link":"","permalink":"http://luoqian67.github.io/blog/2017/12/16/18日志分析步骤/","excerpt":"","text":"日志分析一般采集流程日志产出 -&gt; 采集（Logstash、Flume、Scribe） -&gt; 存储 -&gt; 分析 -&gt; 存储（数据库、NoSQL） -&gt; 可视化 开源实时日志分析ELK平台Logstash收集日志，并存放到ElasticSearch集群中，Kibana则从ES集群中查询数据生成图表，返回浏览器端 数据提取数据非结构化数据一眼看不出结构的数据。（二进制的，无法用文本理解） 半结构化数据日志是半结构化数据，是有组织的，有格式的数据。可以分割成行和列，就可以当做表理解和处理了，当然也可以分析里面的数据。 结构化数据数据库内的数据（能够像是行和列一样很好的组织起来） 文本分析日志是文本文件，需要依赖文件IO、字符串操作、正则表达式等技术。通过这些技术就能够把日志中需要的数据提取出来。4 这是最常见的日志，nginx、tomcat等WEB Server都会产生这样的日志。 这里面每一段有效的数据对后期的分析都是必须的。 12183.60.212.153 - - [19/Feb/2013:10:23:29 +0800] \"GET /o2o/media.html?menu=3 HTTP/1.1\" 200 16691 \"-\" \"Mozilla/5.0 (compatible; EasouSpider; +http://www.easou.com/search/spider.html)\" 思路：如果用空格切割，数据并没有按照业务分割好，比如时间就被分开了，URL相关的也被分开了，User Agent的空格最多，被分割了。 所以，定义的时候不选用这种在filed中出现的字符就可以省很多事，例如使用’\\x01’、‘\\0x02’这个不可见的ASCII。 12for field in line.split(\"\\x02\"): print(field) 类型转换 fields中的数据是有类型的，例如时间、状态码等。对不同的field要做不同的类型转换，甚至是自定义的转换 时间转换19/Feb/2013:10:23:29 +0800 对应格式是%d/%b/%Y:%H:%M:%S %z使用的函数是datetime类的strptime方法 12345import datetime def convert_time(timestr): return datetime.datetime.strptime(timestr, '%d/%b/%Y:%H:%M:%S %z')#lambda timestr: datetime.datetime.strptime(timestr, '%d/%b/%Y:%H:%M:%S %z' 请求信息的解析 123456#GET /o2o/media.html?menu=3 HTTP/1.1 #method url protocol 三部分都非常重要def get_request(request:str): return dict(zip(['method','url','protocol'],request.split()))#lambda request: dict(zip(['method','url','protocol'],request.split())) 映射对每一个字段命名，然后与值和类型转换的方法对应。解析每一行是有顺序的 映射对每一个字段命名，然后与值和类型转换的方法对应。解析每一行是有顺序的 123456789101112131415161718192021222324252627282930313233343536373839404142import datetime line = '''183.60.212.153 - - [19/Feb/2013:10:23:29 +0800] \\\"GET /o2o/media.html?menu=3 HTTP/1.1\" 200 16691 \"-\" \\\"Mozilla/5.0 (compatible; EasouSpider; +http://www.easou.com/search/spider.html)\"''' CHARS = set(' \\'\"[]')print(CHARS) def makekey(line:str): start = 0 flag = False stopchar = '' for i, c in enumerate(line): # [a] if c in CHARS: if c == '[': flag = True start = i + 1 if c == ']': flag = False if c == '\"': flag = not flag if flag: start = i + 1 if flag: continue if start == i: start = i + 1 continue yield line[start:i] start = i + 1 if start &lt; len(line): yield line[start:]names = ('remote', '', '', 'datetime', 'request', 'status', 'length', '', 'useragent')ops = (None, None, None, lambda timestr: datetime.datetime.strptime(timestr, '%d/%b/%Y:%H:%M:%S lambda request: dict(zip(['method', 'url', 'protocol'], request.split())), int, int, None, Nonedef extract(line:str): return dict(map(lambda item: (item[0], item[2](item[1]) if item[2] is not None else item[1]),zip(names, makekey(line), ops)))print(extract(line)) 正则表达式的提取 12345678910111213141516171819202122232425import datetimeimport re line = '''183.60.212.153 - - [19/Feb/2013:10:23:29 +0800] \\\"GET /o2o/media.html?menu=3 HTTP/1.1\" 200 16691 \"-\" \\\"Mozilla/5.0 (compatible; EasouSpider; +http://www.easou.com/search/spider.html)\"''' ops = &#123; 'datetime': lambda timestr: datetime.datetime.strptime(timestr, '%d/%b/%Y:%H:%M:%S %z'), 'status': int, 'length': int&#125; pattern = '''(?P&lt;remote&gt;[\\d.]&#123;7,&#125;) - - \\[(?P&lt;datetime&gt;[/\\w +:]+)\\] \\\"(?P&lt;method&gt;\\w+) (?P&lt;url&gt;\\S+) (?P&lt;protocol&gt;[\\w/\\d.]+)\" \\(?P&lt;status&gt;\\d+) (?P&lt;length&gt;\\d+) .+ \"(?P&lt;useragent&gt;.+)\"''' regex = re.compile(pattern) def extract(line:str) -&gt; dict: matcher = regex.match(line) return &#123;k:ops.get(k, lambda x:x)(v) for k,v in matcher.groupdict().items()&#125; print(extract(line)) 异常处理日志中不免会出现一些不匹配的行，需要处理。 这里使用re.match方法，有可能匹配不上。所以要增加一个判断采用抛出异常的方式，让调用者获得异常并自行处理。 1234567def extract(logline:str) -&gt; dict: \"\"\"返回字段的字典，如果返回None说明匹配失败\"\"\" matcher = regex.match(line) if matcher: return &#123;k:ops.get(k, lambda x:x)(v) for k,v in matcher.groupdict().items()&#125; else: return None # 或输出日志记录 数据载入 123456789def load(path): \"\"\"装载日志文件\"\"\" with open(path) as f: for line in f: fields = extract(line) if fields: yield fields else: continue # TODO 解析失败就抛弃，或者打印日志","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"日志分析","slug":"日志分析","permalink":"http://luoqian67.github.io/blog/tags/日志分析/"}]},{"title":"python-并发和线程","slug":"17并发和线程","date":"2017-11-08T16:00:00.000Z","updated":"2018-12-11T13:37:21.728Z","comments":true,"path":"2017/11/09/17并发和线程/","link":"","permalink":"http://luoqian67.github.io/blog/2017/11/09/17并发和线程/","excerpt":"","text":"并发并发和并行的区别并行、parallel ​ 同时做某些事情，可以互不干扰的同一时刻做几件事 并发、concurrency ​ 一个时段内有事情要处理。 并发的解决1、队列、缓冲区使用队列，先进先出，解决了资源使用的问题。排成的队列，其实就是一个缓冲地带，就是缓冲区。（队列的作用：解耦，缓冲） 2、争抢通过争抢，当一个抢到时就会触发一种类似锁机制，抢到资源就上锁，排他性的锁。这也是一种高并发解决方案，但是这样就有可能会有些会很长时间都抢不到。 3、预处理一种提前加载用户需要的数据的思路，预处理思想，缓存常用。（要考虑到冷、热数据的问题，经常访问的数据可以先预加载） 4、并行一般日常可以通过购买服务器，或多开进程、线程实现并行处理，来解决并发问题。注意：这些都是水平拓展的思想。 注：如果线程在单CPU上处理，就不是并行了。但是多数服务器都是多CPU的，服务的部署往往是多机的、分布式的，这都是并行处理。 5、提速提高单个CPU性能，或单个服务器安装更多的CPU。这是一种垂直扩展思想。 6、消息中间件一般就是在程序之前实现的技术。 常见的消息中间件有RabbitMQ、ActiveMQ（Apache）、RocketMQ（阿里Apache）、kafka（Apache）等 总结：一般来说不同的并发场景使用不同的策略，而策略可能是多种方式的优化组合。 进程和线程在实现了线程的操作系统中，线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个程序的执行实例就是一个进程。进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 进程和程序的关系程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据（资源），它也是线程的容器。 Linux进程有父进程、子进程，Windows的进程是平等关系。 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。在许多系统中，创建一个线程比创建一个进程快10-100倍。 进程、线程的理解现代操作系统提出进程的概念，每一个进程都认为自己独占所有的计算机硬件资源。进程就是独立的王国，进程间不可以随便的共享数据。线程就是省份，同一个进程内的线程可以共享进程的资源，每一个线程拥有自己独立的堆栈。 线程的状态 状态 含义 就绪(Ready) 线程能够运行，但在等待被调度。可能线程刚刚创建启动，或刚刚从阻塞中恢复，或者被其他线程抢占 运行(Running) 线程正在运行 阻塞(Blocked) 线程等待外部事件发生而无法运行，如I/O操作 终止(Terminated) 线程完成，或退出，或被取消 Python中的进程和线程 进程会启动一个解释器进程，线程共享一个解释器进程 Python的线程开发 Python的线程开发使用标准库threading Thread类123#签名def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): 参数名 含义 target 线程调用的对象，就是目标函数 name 为线程起的名字 args 为目标函数传递实参，元组 kwargs 为目标函数关键字传参，字典 线程启动123456789import threading # 最简单的线程程序def worker(): print(\"I'm working\") print('Fineshed') t = threading.Thread(target=worker, name='worker') # 线程对象t.start() # 启动 通过threading.Thread创建一个线程对象，target是目标函数，name可以指定名称。但是线程没有启动，需要调用start方法。线程之所以执行函数，是因为线程中就是执行代码的，而最简单的封装就是函数，所以其实还是函数调用，当函数执行完，线程就退出，当主线程结束后，程序也就执行完毕。 线程退出Python没有提供线程退出的方法，线程在下面情况时退出。 1、线程函数内语句执行完毕2、线程函数中抛出未处理的异常 Python的线程没有优先级，没有线程组的概念，也不能被销毁、停止、挂起、那也没有恢复、中断了。 threading的属性和方法 名称 含义 current_thread() 返回当前线程对象 main_thread() 返回主线程对象 active_count() 当前处于alive状态的线程个数 enumerate() 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程 get_ident() 返回当前线程的ID,非0整数 active_count、enumerate方法返回的值还包括主线程。 Thread实例的属性和方法 名称 含义 name 只是一个名字，只是一个标识，名称可以重名。getName(),setName()，获取设置这个名词 ident 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用 is_alive() 返回线程是否活着 注意：线程的name这是一个名称，可以重复；ID必须唯一，但可以在线程退出后再利用。 start方法和run方法 名称 含义 start() 启动线程。每一个线程必须且只能执行该方法一次 run() 运行线程函数 虽然说，start()方法会调用run()方法，而run()方法可以运行函数。但是在使用start()方法启动线程，是启动了一个新的线程，而使用run方法只是在主线程中调用了一个普通的函数而已，并没有启动新的线程。 多线程一个进程中如果有多个线程，就是多线程，实现一种并发。 当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。 一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个主线程。其他线程称为工作线程。 线程安全线程安全，就是线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。 当在线程中使用print函数的时候，可以让它不打印换行，这样就可以避免print函数线程不安全；还可以使用标准库中的logging模块，日志处理模块，线程安全的。 1234567891011import threadingimport loggingdef worker(): for x in range(20): logging.warning(\"&#123;&#125; is running\".format(threading.current_thread().name))for x in range(1, 5): name = \"worker-&#123;&#125;\".format(x) t = threading.Thread(target=worker, name=name) t.start() daemon线程和non-daemon线程进程靠线程执行代码，至少有一个主线程，其它线程是工作线程。 主线程是第一个启动的线程。 父线程：如果线程A中启动了一个线程B，A就是B的父线程。 子线程：B就是A的子线程。 python中，构造线程的时候，可以设置daemon属性，这个属性必须在start方法前设置好。 123456# 源码Thread的__init__方法中if daemon is not None: self._daemonic = daemon # 用户设定bool值else: self._daemonic = current_thread().daemonself._ident = None 线程daemon属性，如果设定就是用户的设置，否则就取当前线程的daemon值。主线程是non-daemon线程，即daemon = False。 名称 含义 daemon属性 表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常 isDaemon() 是否是daemon线程 setDaemon 设置为daemon线程，必须在start方法之前设置 总结：线程具有daemon属性，可以显示设置为True或False，也可以不设置，则取默认值None如果不设置daemon，就取当前线程的daemon来设置它。 主线程是non-daemon线程，即daemon = False。从主线程创建的所有线程的不设置daemon属性，则默认都是daemon = False，也就是non-daemon线程。 Python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。 如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束，如果还有daemon线程，主线程需要退出，会结束所有daemon线程，退出。 join方法join(timeout=None)，是线程的标准方法之一。一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。一个线程可以被join多次。timeout参数指定调用者等待多久，没有设置超时，就一直等到被调用线程结束。一个线程调用谁的join方法，就是join谁，就要等谁。 1234567891011121314import timeimport threadingdef foo(n): for i in range(n): print(i) time.sleep(0.3)t1 = threading.Thread(target=foo, args=(10,), daemon=True)t1.start()t1.join()print(\"Main Thread Exiting\") 使用了join方法后，daemon线程执行完了，主线程才退出。 daemon线程的应用场景这个概念唯一的作用就是，当你把一个线程设置为 daemon，它会随主线程的退出而退出。 主要应用场景有： 1、后台任务。如发送心跳包、监控，这种场景最多。 2、主线程工作才有用的线程。如主线程中维护这公共的资源，主线程已经清理了，准备退出，而工作线程使用这些资源工作也没有意义了，一起退出最合适。 3、随时可以被终止的线程 如果主线程退出，想所有其它工作线程一起退出，就使用daemon=True来创建工作线程。 比如，开启一个线程定时判断WEB服务是否正常工作，主线程退出，工作线程也没有必须存在了，应该随着主线程退出一起退出。这种daemon线程一旦创建，就可以忘记它了，只用关心主线程什么时候退出就行了。daemon线程，简化了程序员手动关闭线程的工作。 如果在non-daemon线程A中，对另一个daemon线程B使用了join方法，这个线程B设置成daemon就没有什么意义了，因为non-daemon线程A总是要等待B。 如果在一个daemon线程C中，对另一个daemon线程D使用了join方法，只能说明C要等待D，主线程退出，C和D不管是否结束，也不管它们谁等谁，都要被杀掉。 threading.local类123456789101112import threadingimport time# 局部变量实现def worker(): x = 0 for i in range(100): time.sleep(0.0001) x += 1 print(threading.current_thread(), x)for i in range(10): threading.Thread(target=worker).start() 当想保证线程安全，可以使用局部变量来进行运算，避免错误。 当然如果想使用全局变量，那就可以使用threading下的local类，将这个类实例化得到一个全局变量，但是不同的线程使用这个对象存储的数据，其他线程看不见。 12345678910111213141516171819202122import threadingimport timeglobal_date = threading.local()def worker(): global_date.x = 0 for i in range(100): time.sleep(0.001) global_date.x += 1 print(threading.current_thread(), global_date.x)for i in range(5): threading.Thread(target=worker).start() #&lt;Thread(Thread-3, started 3648)&gt; 100#&lt;Thread(Thread-4, started 9404)&gt; 100#&lt;Thread(Thread-1, started 7472)&gt; 100#&lt;Thread(Thread-5, started 10876)&gt; 100#&lt;Thread(Thread-2, started 12424)&gt; 100 threading.local类构建了一个大字典，存放所有线程相关的字典，定义如下：{ id(thread) -&gt; (ref(thread), thread-local dict) }每一线程实例的id为key，元组为value。value中两部分为线程对象引用，每个线程自己的字典。 本质运行时，threading.local实例处在不同的线程中，就从大字典中找到当前线程相关键值对中的字典，覆盖threading.local实例的 __dict__ 。这样就可以在不同的线程中，安全地使用线程独有的数据，做到了线程间数据隔离，如同本地变量一样安全 定时器Timer/延时执行 threading.Timer继承自Thread，这个类用来定义延迟多久后执行一个函数。 class.threading.Timer(interval, function, args=None, kwargs=None)start方法执行之后，Timer对象会处于等待状态，等待了interval秒之后，然后开始执行function函数。 123456789101112131415161718192021222324252627282930313233import threadingimport timeimport loggingFORMAT = \"%(asctime)s %(threadName)s %(thread)d %(message)s\"logging.basicConfig(level=logging.INFO, format=FORMAT)def worker(): logging.info(\"in worker\") time.sleep(2)t = threading.Timer(4, worker)t.setName(\"timer\")t.start()while True: print(threading.enumerate()) time.sleep(1) if len(threading.enumerate()) == 1: break #打印[&lt;_MainThread(MainThread, started 10416)&gt;, &lt;Timer(timer, started 2768)&gt;][&lt;_MainThread(MainThread, started 10416)&gt;, &lt;Timer(timer, started 2768)&gt;][&lt;_MainThread(MainThread, started 10416)&gt;, &lt;Timer(timer, started 2768)&gt;][&lt;_MainThread(MainThread, started 10416)&gt;, &lt;Timer(timer, started 2768)&gt;]2018-10-12 16:24:44,066 timer 2768 in worker[&lt;_MainThread(MainThread, started 10416)&gt;, &lt;Timer(timer, started 2768)&gt;][&lt;_MainThread(MainThread, started 10416)&gt;, &lt;Timer(timer, started 2768)&gt;] Timer提供了cancel方法，用来取消一个未执行的函数，如果上面例子中worker函数已经开始执行，cancel就没有任何效果了。 总结Timer是线程Thread的子类，就是线程类，具有线程的能力和特征。它的实例是能够延时执行目标函数的线程，在真正执行目标函数之前，都可以cancel它。cancel方法本质使用Event类实现。这并不是说，线程提供了取消的方法。 线程同步概念：线程同步，线程间协同，通过某种技术，让一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。 不同操作系统实现技术有所不同，有临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件Event等 Event事件 Event事件，是线程间通信机制中最简单的实现，使用一个内部的标记flag，通过flag的True或False的变化来进行操作。 名称 含义 set() 标记设置为True clear() 标记设置为False is_set() 标记是否为True wait(timeout=None) 设置等待标记为True的时长，None为无限等待。等到返回True，未等到超时了返回False 需求： 老板雇佣了一个工人，让他生产杯子，老板一直等着这个工人，直到生产了10个杯子。 123456789101112131415161718192021222324252627282930import loggingimport timefrom threading import Event, ThreadFORMAT = \"%(asctime)s %(threadName)s %(thread)s %(message)s\"logging.basicConfig(format=FORMAT, level=logging.INFO)def boss(event: Event): logging.info(\"I'm boss, waitting for U.\") event.wait() #等待 logging.info(\"Good Job.\")def worker(event: Event, count=10): logging.info(\"i'm working for U.\") cups = [] while True: logging.info(\"make 1\") time.sleep(0.5) cups.append(1) if len(cups) &gt;= count: event.set() #通知 break logging.info(\"I'm finish my job, cups = &#123;&#125;\".format(cups))event = Event()t1 = Thread(target=boss, name=\"bose\", args=(event,)).start()t2 = Thread(target=worker, name=\"worker\", args=(event,)).start() 总结使用同一个Event对象的标记flag。谁wait就是等到flag变为True，或等到超时返回False。不限制等待的个数。 wait的使用 123456789101112131415161718192021222324from threading import Event, Threadimport logginglogging.basicConfig(level=logging.INFO)def do(event:Event, interval:int): while not event.wait(interval): # 条件中使用，返回True或者False logging.info('do sth.')e = Event()Thread(target=do, args=(e, 3)).start()e.wait(10) # 也可以使用time.sleep(10)e.set()print('main exit')#输出INFO:root:do sth.INFO:root:do sth.INFO:root:do sth.main exitProcess finished with exit code 0 Event的wait优于time.sleep，它会更快的切换到其它线程，提高并发效率。 Lock锁，凡是存在共享资源争抢的地方都可以使用锁，从而保证只有一个使用者可以使用这个资源。 锁，一旦线程获得锁，其它试图获取锁的线程将被阻塞 名称 含义 acquire(blocking=True,timeout=-1) 默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取锁，返回True，否则返回False release() 释放锁。可以从任何线程调用释放。已上锁的锁，会被重置为unlocked,未上锁的锁上调用，抛RuntimeError异常。 加锁和解锁 一般来说，加锁就需要解锁，但是加锁后解锁前，还要有一些代码执行，就有可能抛异常，一旦出现异常，锁是无法释放，但是当前线程可能因为这个异常被终止了，这就产生了死锁。 加锁、解锁常用语句：1、使用try…finally语句保证锁的释放 1234try: self.lock.acquire() finally: self.lock.release() 2、with上下文管理，锁对象支持上下文管理 123self.__lock = threading.Lock() with self.__lock: ****** 锁的应用场景 锁适用于访问和修改同一个共享资源的时候，即读写同一个资源的时候。 如果全部都是读取同一个共享资源需要锁吗？不需要。因为这时可以认为共享资源是不可变的，每一次读取它都是一样的值，所以不用加锁 使用锁的注意事项： 少用锁，必要时用锁。使用了锁，多线程访问被锁的资源时，就成了串行，要么排队执行，要么争抢执行 举例，高速公路上车并行跑，可是到了省界只开放了一个收费口，过了这个口，车辆依然可以在多车道上一起跑。过收费口的时候，如果排队一辆辆过，加不加锁一样效率相当，但是一旦出现争抢，就必须加锁,一辆辆过。 加锁时间越短越好，不需要就立即释放锁 一定要避免死锁 可重入锁RLOCK 可重入锁，是线程相关的锁。线程A获得可重复锁，并可以在同一线程中多次成功获取，不会阻塞。最后要在线程A中做和acquire次数相同的release。release多了会报错。有个count在计数。属主owner会记录当前是谁在使用锁。 当锁未释放完，其他线程获得锁就会阻塞，直到当前持有锁的线程释放完锁。 Condition 构造方法Condition(lock=None)，可以传入一个Lock或Rlock对象，默认是Rlock。 名称 含义 acquire(*args) 获取锁 wait(self,timeout = None) 等待或超时 notify（n =1） 唤醒至多指定指定个数的等待的线程，没有等待的线程就没有任何操作 notify_all() 唤醒所有等待的线程 Condition用于生产者、消费者模型，为了解决生产者消费者速度匹配的问题。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"网络编程","slug":"16网络编程","date":"2017-10-31T16:00:00.000Z","updated":"2018-12-11T13:16:38.341Z","comments":true,"path":"2017/11/01/16网络编程/","link":"","permalink":"http://luoqian67.github.io/blog/2017/11/01/16网络编程/","excerpt":"","text":"Socket介绍 Socket套接字Python中提供socket.py标准库，非常底层的接口库。Socket是一种通用的网络编程接口，和网络层次没有一一对应的关系。 协议族AF表示Address Family，用于socket()第一个参数 名称 含义 AF_INET IPV4 AF_INET6 IPv6 AF_UNIX Unix Domain Socket，windows没有 socket类型| 名称 | 含义 || ——– | ——————————- || SOCK_STREAM| 面向连接的流套接字。默认值，TCP协议||SOCK_DGRAM |无连接的数据报文套接字。UDP协议 | TCP编程Socket编程，需要两端，一般来说需要一个服务端、一个客户端，服务端称为Server，客户端称为Client TCP服务端编程 服务器端编程步骤 创建Socket对象 绑定IP地址Address和端口Port。bind()方法 IPv4地址为一个二元组(‘IP地址字符串’, Port) 开始监听，将在指定的IP的端口上监听。listen()方法 获取用于传送数据的Socket对象 socket.accept() -&gt; (socket object, address info)accept方法阻塞等待客户端建立连接，返回一个新的Socket对象和客户端地址的二元组地址是远程客户端的地址，IPv4中它是一个二元组(clientaddr, port) 接收数据recv(bufsize[, flags]) 使用缓冲区接收数据 发送数据send(bytes)发送数据 查看监听端口 123456windows 命令# netstat -anp tcp | findstr 9999linux命令# netstat -tanl | grep 9999# ss -tanl | grep 9999 练习——写一个一对多通信 需求分析 聊天工具是CS程序，C是每一个客户端，S是服务器端。 服务器应该具有的功能： 启动服务，包括绑定地址和端口，并监听 建立连接，能和多个客户端建立连接 接收不同用户的信息 分发，将接收的某个用户的信息转发到已连接的所有客户端 停止服务 记录连接的客户端 代码实现 服务端应该对应一个类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(thread)d %(message)s\")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 #accept会阻塞主线程，所以开一个新线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 self.clients[client] = sock # 添加到客户端字典 #准备接收数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(sock, client)).start() def recv(self, sock:socket.socket, client): # 接收客户端数据 while not self.event.is_set(): data = sock.recv(1024) # 阻塞到数据到来 msg = data.decode().strip() # 客户端退出命令 if msg == 'quit' or msg == '': self.clients.pop(client) sock.close() logging.info('&#123;&#125; quits'.format(client)) break msg = \"&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\\n&#123;&#125;\\n\".format(datetime.datetime.now(), *client,data.decode()) logging.info(msg) msg = msg.encode() for s in self.clients.values(): s.send(msg) def stop(self): # 停止服务 for s in self.clients.values(): s.close() self.sock.close() self.event.set() cs = ChatServer()cs.start()while True: cmd = input('&gt;&gt;').strip() if cmd == 'quit': cs.stop() threading.Event().wait(3) break logging.info(threading.enumerate()) # 用来观察断开后线程的变化 socket常用的方法 名称 含义 socket.recv(bufsize[, flags]) 获取数据。默认是阻塞的方式 socket.recvfrom(bufsize[, flags]) 获取数据，返回一个二元组(bytes, address) socket.recv_into(buffer[, nbytes[,flags]]) 获取到nbytes的数据后，存储到buffer中。如果nbytes没有指定或0，将buffer大小的数据存入buffer中。返回接收的字节数。 socket.recvfrom_into(buffer[,nbytes[, flags]]) 获取数据，返回一个二元组(bytes, address)到buffer中 socket.send(bytes[, flags]) TCP发送数据 socket.sendall(bytes[, flags]) TCP发送全部数据，成功返回None socket.sendto(string[,flag],address) UDP发送数据 socket.sendfile(file, offset=0,count=None) 发送一个文件直到EOF，使用高性能的os.sendfile机制，返回发送的字节数。如果win下不支持sendfile，或者不是普通文件，使用send()发送文件。offset告诉起始位置。3.5版本开始 socket.getpeername() 返回连接套接字的远程地址。返回值通常是元组(ipaddr,port) socket.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) socket.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常 socket.settimeout(value) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()) socket.setsockopt(level,optname,value) 设置套接字选项的值。比如缓冲区大小。太多了，去看文档。不同系统，不同版本都不尽相同 MakeFile socket.makefile(mode=&#39;r&#39;, buffering=None, *, encoding=None, errors=None, newline=None)创建一个与该套接字相关连的文件对象，将recv方法看做读方法，将send方法看做写方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 使用makefile简单例子import socketsockserver = socket.socket()ip = '127.0.0.1'port = 9999addr = (ip, port)sockserver.bind(addr)sockserver.listen()print('-'30)s, _ = sockserver.accept()print('-'30)f = s.makefile(mode='rw')line = f.read(10) # 阻塞等print('-'30)print(line)f.write('Return your msg: &#123;&#125;'.format(line))f.flush()# 改写成循环接收消息import socketimport threadingsockserver = socket.socket()ip = '127.0.0.1'port = 9999addr = (ip, port)sockserver.bind(addr)sockserver.listen()print('-'30)event = threading.Event()def accept(sock:socket.socket, e:threading.Event): s, _ = sock.accept() f = s.makefile(mode='rw') while True: line = f.readline() print(line) if line.strip() == \"quit\": # 注意要发quit\\n break f.write('Return your msg: &#123;&#125;'.format(line)) f.flush() f.close() sock.close() e.wait(3) t = threading.Thread(target=accept, args=(sockserver, event))t.start()t.join()print(sockserver) makefile练习 使用makefile改写一对多通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(thread)d %(message)s\")class ChatServer: def init(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 #accept会阻塞主线程，所以开一个新线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 #准备接收数据，recv是阻塞的，开启新的线程 f = sock.makefile('rw') # 支持读写 self.clients[client] = f # 添加到客户端字典 threading.Thread(target=self.recv, args=(f, client), name='recv').start() def recv(self, f, client): # 接收客户端数据 while not self.event.is_set(): try: data = f.readline() # 阻塞到换行符 except Exception as e: logging.error(e) # 有任何异常，退出 data = 'quit' msg = data.strip() #客户端退出命令 if msg == 'quit': self.clients.pop(client) f.close() logging.info('&#123;&#125; quits'.format(client)) break msg = \"&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\\n&#123;&#125;\\n\".format(datetime.datetime.now(), *client,data) logging.info(msg) for s in self.clients.values(): s.write(msg) s.flush() def stop(self): # 停止服务 for s in self.clients.values(): s.close() self.sock.close() self.event.set() def main(): cs = ChatServer() cs.start() while True: cmd = input('&gt;&gt;').strip() if cmd == 'quit': cs.stop() threading.Event().wait(3) break logging.info(threading.enumerate()) # 用来观察断开后线程的变化if __name__ == '__main__': main() TCP客户端编程 客户端编程步骤 创建Socket对象 连接到远端服务端的IP和PORT、connect()方法 传输数据 使用send、recv方法发送、接收数据 关闭连接、释放资源 12345678import socketclient = socket.socket()ipaddr = ('127.0.0.1', 9999)client.connect(ipaddr) # 直接连接服务器client.send(b'abcd\\n')data = client.recv(1024) # 阻塞等待print(data)client.close() 编写聊天的客户类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import socketimport threadingimport datetimeimport loggingFORMAT = \"%(asctime)s %(threadName)s %(thread)d %(message)s\"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatClient: def init(self, ip='127.0.0.1', port=9999): self.sock = socket.socket() self.addr = (ip, port) self.event = threading.Event() def start(self): # 启动对远端服务器的连接 self.sock.connect(self.addr) self.send(\"I'm ready.\") #准备接收数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, name=\"recv\").start() def recv(self): # 接收客户端的数据 while not self.event.is_set(): try: data = self.sock.recv(1024) # 阻塞 except Exception as e: logging.error(e) break msg = \"&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\\n&#123;&#125;\\n\".format(datetime.datetime.now(), *self.addr,data.strip()) logging.info(msg) def send(self, msg:str): data = \"&#123;&#125;\\n\".format(msg.strip()).encode() # 服务端需要一个换行符 self.sock.send(data) def stop(self): self.sock.close() self.event.wait(3) self.event.set() logging.info('Client stops.') def main(): cc = ChatClient() cc.start() while True: cmd = input('&gt;&gt;&gt;') if cmd.strip() == 'quit': cc.stop() break cc.send(cmd) # 发送消息if name == 'main': main()","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"socket","slug":"socket","permalink":"http://luoqian67.github.io/blog/tags/socket/"}]},{"title":"python-反射、描述器","slug":"15python反射、描述器","date":"2017-10-18T16:00:00.000Z","updated":"2018-12-11T12:46:16.937Z","comments":true,"path":"2017/10/19/15python反射、描述器/","link":"","permalink":"http://luoqian67.github.io/blog/2017/10/19/15python反射、描述器/","excerpt":"","text":"反射概述运行时，区别于编译时，指的是程序被加载到内存中执行的时候。反射，reflection，指的是运行时获取类型定义信息。简单说，在Python中，能够通过一个对象，找出其type、class、attribute或method的能力，称为反射或者自省。具有反射能力的函数有：type()、isinstance()、callable()、dir()、getattr() 内建函数 意义 getattr(object, name[, default]) 通过name返回object的属性值。当属性不存在，将使用default返回，如果没有default，则抛出AttributeError。name必须为字符串 setattr(object, name, value) object的属性存在，则覆盖，不存在，新增 hasattr(object, name) 判断对象是否有这个名字的属性，name必须为字符串 给一个实例用setattr添加一个方法，不做绑定，不会绑定到类中，此时不能用类调用，然而类使用setattr方法，会把那个方法绑定到类的字典上。 思考这种动态增加属性的方式和装饰器修饰一个类、Mixin方式的差异？ 这种动态增删属性的方式是运行时改变类或者实例的方式，但是装饰器或Mixin都是定义时就决定了，因此反射能力具有更大的灵活性。 反射相关的魔术方法__getattr__()、__setattr__()、__delattr__()这三个魔术方法。 魔术方法 意义 __getattr__() 当通过搜索实例、实例的类及祖先类查不到属性，就会调用此方法 __setattr__() 通过.访问实例属性，进行增加、修改都要调用它 __delattr__() 当通过实例来删除属性时调用此方法 __getattribute__() 实例所有的属性调用都从这个方法开始 一个类的属性会按照继承关系找，如果找不到，就会执行__getattr__() 方法，如果没有这个方法，就会抛出AttributeError异常表示找不到属性。查找属性顺序为：实例调用__getattribute__() –&gt;instance.__dict__ –&gt;instance.__class__.__dict__ –&gt; 继承的祖先类（直到object）的__dict__—找不到–&gt; 调用__getattr__() 123456789101112131415class Point(Base): z = 6 def __init__(self, x, y): self.x = x self.y = y def show(self): print(self.x, self.y) def __getattr__(self, item): return \"missing &#123;&#125;\".format(item) def __setattr__(self, key, value): print(\"setattr &#123;&#125;=&#123;&#125;\".format(key,value)) self.__dict__[key] = value __setattr__()方法，可以拦截对实例属性的增加、修改操作，如果要设置生效，需要自己操作实例的__dict__。 __getattribute__方法 实例的所有的属性访问，第一个都会调用__getattribute__方法，它阻止了属性的查找，该方法应该返回（计算后的）值或者抛出一个AttributeError异常。 它的return值将作为属性查找的结果。 如果抛出AttributeError异常，则会直接调用__getattr__方法，因为表示属性没有找到。 __getattribute__方法中为了避免在该方法中无限的递归，它的实现应该永远调用基类的同名方法以访问需要的任何属性，例如object.__getattribute__(self, name)。注意，除非你明确地知道__getattribute__方法用来做什么，否则不要使用它。 描述器描述器的表现用到3个魔术方法:__get__()、__set__()、__delete__()方法签名如下object.__get__(self, instance, owner)object.__set__(self, instance, value)object.__delete__(self, instance)self 指代当前实例，调用者instance 是owner的实例owner 是属性的所属的类 描述器定义Python中，一个类实现了__get__、__set__、__delete__三个方法中的任何一个方法，就是描述器。如果仅实现了__get__，就是非数据描述符 non-data descriptor；同时实现了__get__、__set__就是数据描述符 data descriptor 如果一个类的类属性设置为描述器实例，那么它被称为owner属主。 属性查找顺序实例的__dict__ 优先于非数据描述器数据描述器优先于实例的__dict____delete__方法有同样的效果，有了这个方法，也是数据描述器。 Python中的描述器 Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖方法。这允许单个实例获取与同一类的其他实例不同的行为。 property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。 123456789101112131415161718192021222324252627class A: @classmethod # 非数据描述器 def foo(cls): pass @staticmethod # 非数据描述器 def bar(): pass @property # 数据描述器 def z(self): return 5 def getfoo(self): # 非数据描述器 return self.foo def __init__(self): # 非数据描述器 self.foo = 100 self.bar = 200 #self.z = 300 a = A()print(a.__dict__)print(A.__dict__)#foo、bar都可以在实例中覆盖，但是z不可以。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python面向对象-特殊属性、查看属性、魔术方法","slug":"14python面向对象-特殊属性、查看属性、魔术方法","date":"2017-10-10T16:00:00.000Z","updated":"2018-12-11T11:04:23.152Z","comments":true,"path":"2017/10/11/14python面向对象-特殊属性、查看属性、魔术方法/","link":"","permalink":"http://luoqian67.github.io/blog/2017/10/11/14python面向对象-特殊属性、查看属性、魔术方法/","excerpt":"","text":"特殊属性 属性 含义 __name_ 类、函数、方法等的名字 __module_ 类定义所在的模块名 __class_ 对象或者类所属的类 __bases__ 类的基类的元组，顺序为它们在基类列表中出现的顺序 __doc__ 类、函数的文档字符串，如果没有定义则为None __mro__ 类的mro，class.mro()返回的结果保存在__mro__中 __dict__ 类的实例的属性，可写的字典 查看属性 方法 意义 __dir__ 返回类或者对象的所有成员名称列表。dir()函数就是调用__dir__()。 使用实例调用时，如果提供__dir__()，则返回其返回值，要求是可迭代对象。 如果没有提供__dir__()，则会从实例和类及祖先类中收集信息（尽可能多的） 如果dir([obj])参数obj包含方法__dir__()，该方法将被调用。如果参数obj不包含__dir__()，该方法将最大限度地收集属性信息。 dir(obj)对于不同类型的对象obj具有不同的行为： 如果对象是模块对象，返回的列表包含模块的属性名和变量名。 如果对象是类或者类对象，返回的列表包含类的属性名，及它的基类的属性名。 如果obj不写，返回列表包含内容不同 在模块中，返回模块的属性和变量名 在函数中，返回本地作用域的变量名 在方法中，返回本地作用域的变量名 魔术方法 分类： 创建、初始化和销毁 __new__和__init__和__del__ hash bool 可视化 运算符重载 容器和大小 可调用对象 上下文管理 反射 描述器 其他 实例化 方法 意义 __new__ 实例化一个对象该方法需要返回一个值(本类型的实例)，如果该值不是cls的实例，则不会调用__init__该方法永远都是静态 __new__方法很少使用，即使创建了该方法，也会使用return super().__new__(cls)得到实例化对象，或者基类object的__new__方法来创建实例并返回。 hash 方法 意义 __hash__ 内建函数hash()调用的返回值，返回一个整数。如果定义这个方法该类的实例就可hash。 __eq__ 对应==操作符，判断2个对象是否相等，返回bool值 1234567891011121314151617class A: def __init__(self, name, age=18): self.name = name def __hash__(self): return 1 def __eq__(self, other): return self.name == other.name def __repr__(self): return self.name print(hash(A('tom')))print((A('tom'), A('tom')))print([A('tom'), A('tom')])print(&#123;('tom',), ('tom',)&#125;) hash(x) ,x都一样，求得的hash应该是不变的，这是幂等性的缘故，一般来说，x不一样，hash应该不一样。 不同的hash算法，不同的x求得同样的hash值，这就是hash冲突。 __hash__方法只是返回一个hash值作为set的key，但是去重，还需要__eq__（等效==，就是内容相等）来判断2个对象是否相等，is判断的是内存地址，is相等的话就肯定是同一个元素。hash值相等，只是hash冲突，不能说明两个对象是相等的。因此，一般来说提供__hash__方法是为了作为set或者dict的key，所以去重要同时提供__eq__方法。 不可hash对象isinstance(p1, collections.Hashable)一定为False。去重需要提供__eq__方法。 list类实例为什么不可hash 源码中有一句__hash__ = None，也就是如果调用__hash__()相当于None()，一定报错。所有类都继承object，而这个类是具有__hash__()方法的，如果一个类不能被hash，就把__hash__设置为None。 bool 方法 意义 __bool__ 内建函数bool()，或者对象放在逻辑表达式的位置，调用这个函数返回布尔值。 定义__bool__()，这个函数的返回值必须要是bool类型。没有定义__bool__()，就找__len__()返回长度，非0为真。 如果__len__()也没有定义，那么所有实例都返回真。 两个对象（类和实例）可以当作True理解。 等效Fals的本质是：对于四大皆空：空串，空元组。空列表，空字典，先找bool，如果没有bool就看长度，当长度为0就恒为假。 可视化 方法 意义 __repr__ 内建函数repr()对一个对象获取字符串表达。 调用__repr__方法返回字符串表达，如果__repr__也没有定义，就直接返回object的定义，就是显示内存地址信息。 __str__ str()函数、format()函数、print()函数调用，需要返回对象的字符串表达。如果没有定义，就去调用__repr__方法返回字符串表达，如果__repr__没有定义，就直接返回对象的内存地址信息。 __bytes__ bytes()函数调用，返回一个对象的bytes表达，即返回bytes对象 123456789101112131415161718192021class A: def __init__(self, name, age=18): self.name = name self.age = age def __repr__(self): return 'repr: &#123;&#125;,&#123;&#125;'.format(self.name, self.age) def __str__(self): return 'str: &#123;&#125;,&#123;&#125;'.format(self.name, self.age) def __bytes__(self): #return \"&#123;&#125; is &#123;&#125;\".format(self.name, self.age).encode() import json return json.dumps(self.__dict__).encode() print(A('tom')) # print函数使用__str__print([A('tom')]) # []使用__str__，但其内部使用__repr__print([str(A('tom'))]) # []使用__str__，其中的元素使用str()函数也调用__str__print(bytes(A('tom'))) 总结：一般首先找的是repr，当repr没有就找str，都没有就去object中去寻找。bytes方法转成二进制只是一种序列化的表达，和序列化还是有差别的，序列化是一种通用的二进制格式或者通用的中间格式，序列化是一种交互，转化成文本传输的，而这里的转换只是一种表达，给人展示用的。 注意不能通过判断是否带引号来判断输出值的类型，类型判断要使用type或isinstance 运算符重载 operator模块提供了以下特殊方法，可以将类的实例使用下面的操作符来操作 运算符 特殊方法 含义 &lt;, &lt;=, ==, &gt;, &gt;=, != __lt__, __le__, __eq__, __gt__, __ge__, __ne__ 比较运算符 +, -, *, /, %, //,**, divmod __add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__ 算数运算符 +=, -=, *=, /=, %=, //=, **= __iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__,__ipow__ @functools.total_ordering 装饰器__lt__, __le__, __eq__, __gt__, __ge__是比较大小必须实现的方法，但是全部写完太麻烦，使用@functools.total_ordering 装饰器就可以大大简化代码。 但是要求__eq__必须实现，其它方法__lt__, __le__, __gt__, __ge__ 实现其一。 但是： __eq__等于可以推断不等于__gt__大于可以推断小于__ge__大于等于可以推断小于等于也就是用3个方法，就可以把所有比较解决了，所以total_ordering可以不使用 容器相关方法 方法 意义 __len__ 内建函数len()，返回对象的长度（&gt;=0的整数），如果把对象当做容器类型看，就如同list或者dict。bool()函数调用的时候，如果没有__bool__()方法，则会看__len__()方法是否存在，存在返回非0为真。 __iter__ 迭代容器时，调用，返回一个新的迭代器对象 __contains__ in 成员运算符，没有实现，就调用__iter__方法遍历 __getitem__ 实现self[key]访问。序列对象，key接受整数为索引，或者切片。对于set和dict，key为hashable。key不存在引发KeyError异常 __setitem__ 和__getitem__的访问类似，是设置值的方法 __missing__ 字典或其子类使用__getitem__()调用时，key不存在执行该方法 1234567class A(dict): def __missing__(self, key): print('Missing key : ', key) return 0 a = A()print(a['k']) 可调用对象 123456def foo(): print(foo.__module__, foo.__name__) foo()# 等价于foo.__call__() 函数即对象，对象foo加上()，就是调用此函数对象的__call__()方法。 可调用对象 方法 意义 __call__ 类中定义一个方法，实例就可以像函数一样调用 1234567891011121314151617181920212223242526272829class Point: def __init__(self, x, y): self.x = x self.y = y def __call__(self, *args, **kwargs): return \"&lt;Point &#123;&#125;:&#123;&#125;&gt;\".format(self.x, self.y) p = Point(4, 5)print(p)print(p()) class Adder: def __call__(self, *args): ret = 0 for x in args: ret += x self.ret = ret return ret adder = Adder()print(adder(4, 5, 6))print(adder.ret)#&lt;__main__.Point object at 0x000002D5F04C2198&gt;#&lt;Point 4:5&gt;#15#15 练习: 定义一个斐波那契数列的类，方便调用，计算第n项 123456789101112131415class Fib: def __init__(self): self.items = [0, 1, 1] def __call__(self, index): if index &lt; 0: raise IndexError('Wrong Index') if index &lt; len(self.items): return self.items[index] for i in range(3, index+1): self.items.append(self.items[i-1] + self.items[i-2]) return self.items[index] print(Fib()(100)) 上例中，增加迭代的方法、返回容器长度、支持索引的方法 1234567891011121314151617181920212223242526272829303132333435363738class Fib: def __init__(self): self.items = [0, 1, 1] def __call__(self, index): return self[index] def __iter__(self): return iter(self.items) def __len__(self): return len(self.items) def __getitem__(self, index): if index &lt; 0: raise IndexError(\"Wrong Index\") if index &lt; len(self.items): return self.items[index] for i in range(len(self), index + 1): self.items.append(self.items[i - 1] + self.items[i - 2]) return self.items[index] def __str__(self): return str(self.items) __repr__ = __str__fib = Fib()print(fib(5), len(fib)) # 全部计算print(fib(10), len(fib)) # 部分计算print(\"------\")for x in fib: print(x, end=\" \")print()print(fib[5], fib[9]) # 索引访问，不计算 上下文管理对象 当一个对象同时实现了__enter__（）和__exit__（）方法，它就属于上下文管理的对象。 方法 意义 __enter__ 进入与此对象相关的上下文。如果存在该方法，with语法会把该方法的返回值作为绑定到as子句中指定的变量上 __exit__ 退出与此对象相关的上下文。 12345678910111213141516class Point: def __init__(self): print(\"init\") def __enter__(self): print(\"enter\") def __exit__(self, exc_type, exc_val, exc_tb): print(\"exit\")with Point() as f: print(\"-\" * 30) raise Exception('error')print(\"=====end=======\") 实例化对象的时候，并不会调用enter，进入with语句块调用__enter__方法，然后执行语句体，最后离开with语句块的时候，调用__exit__方法。 with可以开启一个上下文运行环境，在执行前做一些准备工作，执行后做一些收尾工作。注意，with并不开启一个新的作用域。 上下文管理很安全，不管是碰到异常都还是会正常执行 __enter__方法返回值就是上下文中使用的对象，with语法会把它的返回值赋给as子句的变量。 方法的参数 __enter__方法 没有其他参数。__exit__方法有3个参数：__exit__(self, exc_type, exc_value, traceback)这三个参数都与异常有关。如果该上下文退出时没有异常，这3个参数都为None。如果有异常，参数意义如下exc_type，异常类型exc_value，异常的值traceback，异常的追踪信息__exit__方法返回一个等效True的值，则压制异常；否则，继续抛出异常 上下文应用场景 增强功能 在代码执行的前后增加代码，以增强其功能。类似装饰器的功能。 资源管理 打开了资源需要关闭，例如文件对象、网络连接、数据库连接等 权限验证 在执行代码之前，做权限的验证，在__enter__中处理 contextlib.contextmanager contextlib.contextmanager它是一个装饰器实现上下文管理，装饰一个函数，而不用像类一样实现__enter__和__exit__方法。对下面的函数有要求，必须有yield，也就是这个函数必须返回一个生成器，且只有yield一个值。也就是这个装饰器接收一个生成器对象作为参数。 1234567891011121314151617181920212223242526import contextlib@contextlib.contextmanagerdef sub(x, y): # 为生成器函数增加了上下文管理 print(\"enter\") start = datetime.datetime.now() try: yield x - y # yield的值只能有一个，作为__enter__方法的返回值 finally: detla = (datetime.datetime.now() - start).total_seconds() print(detla) print(\"exit\")with sub(6, 2) as f: time.sleep(2) print(\"------------\") print(f) print(\"~~~~~~~~~~\") #输出enter------------4~~~~~~~~~~2.000654exit 当yield发生处为生成器函数增加了上下文管理。这是为函数增加上下文机制的方式。 把yield之前的当做__enter__方法执行 把yield之后的当做__exit__方法执行 把yield的值作为__enter__的返回值 总结 :如果业务逻辑简单可以使用函数加contextlib.contextmanager装饰器方式，如果业务复杂，用类的方式加__enter__和__exit__方法方便。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-面向对象","slug":"13python面向对象基础","date":"2017-09-30T16:00:00.000Z","updated":"2018-12-07T14:22:31.538Z","comments":true,"path":"2017/10/01/13python面向对象基础/","link":"","permalink":"http://luoqian67.github.io/blog/2017/10/01/13python面向对象基础/","excerpt":"","text":"面向对象 一种认识世界，分析世界的方法论。将万事万物抽象为类 类class 类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。用计算机语言来描述就是属性和方法的集合（封装）。 对象instance、object，对象是类的具象，是一个实体，类也是对象。 属性，它是对象状态的抽象，用数据结构来描述。 操作，是对对象行为的抽象，用操作名和实现该操作的方法来描述。 哲学 一切皆对象 对象是数据和操作的封装 对象是独立的，但是对象之间可以相互作用 目前OOP是最接近人类认知的编程范式 面向对象三要素封装：将属性和方法组装到一起，隐藏数据，对外只暴露一些接口用于连接。继承：目的：多复用，继承来的就不用自己写了；多继承少修改（开闭原则），OCP(open_closed principle)，使用继承来改变。作用：就是为了修改不一样的属性。多态：面向对象编程最灵活的地方，多种表现，动态绑定。#### Python的类定义：12class ClassName： 语句块要求：1. 必须使用class关键字2. 类名必须使用大驼峰命名3. 类定义完成后会产生一个类对象，会绑定到ClassName这个标识符上面。#### 类对象和类属性类对象，类的定义就会生成一个类对象类的属性，类定义中的变量和类中定义的方法都是类的属性类变量，定义在类中的变量#### 实例化在类对象名称后面加上一个括号，就调用类的实例化方法，完成实例化，实例化就真正创建一个该类的对象（实例）。每一次实例化，只能生成该类的一个具体实例，生成的是不同的实例。即使通过相同的参数实例化，得到的对象也不相同。python类实例化后，会自动调用__init__方法，可以不定义，如果没有定义会在实例化后隐式调用，初始化函数可以有多个参数，第一参数必须留给self，init方法不能有返回值，也就是只能有return None作用：对实例进行初始化 类里面的函数叫做方法对象method，不是普通的函数对象function，一般至少要有一个参数，第一个参数可以是self（一般习惯上用self），这个参数位置指代的就是当前这个实例本身。 实例对象instance类实例化后一定会获得一个对象，就是实例对象。init方法的第一个参数self就是指代某一个实例。 实例变量和类变量实例变量是每个实例自己的变量，是自己独有的；列变量是类的变量，是类的所有实例共享的属性和方法。 特殊属性 含义 __name__ 对象名 __class__ 对象的类型 __dict__ 对象的属性的字典 __qualname__ 类的限定名 类属性保存在类的dict中，实例属性保存在实例的dict中，如果从实例访问类的属性，就要借助class找到所属的类。 类有类名字，实例没有实体名。 python中每一种对象都拥有不同的属性。函数、类都是对象，类的实例也是对象。 类不可以访问实例的属性，实例可以访问类的属性。（是类的，也是这个类所有实例的，其实例都可以访问到；是实例的，就是这个实例自己的，通过类访问不到。） 对象（实例或类）可以动态的给自己增加一个属性，实例.__dict__[变量名]可以访问到，实例的同名变量会隐藏掉类变量，或者说是覆盖了这个类的变量。 一般来说，属性使用字典保存是为了提升查找效率，必须用空间换时间，但是也有个问题，如果数百万个对象，那么字典占的比较大，所以可以使用__slots__方法。 slots告诉解释器，实例的属性都叫什么，一般来说，既然要节省内存，那就最好还是使用元组。 一旦类提供了slots，就阻止实例产生dict来保存实例的属性。子类不会继承slots 12345678910111213141516class A: X = 1 __slots__ = ('z','y') def __init__(self): self.y = 5 def show(self): print(self.X,self.y)a = A()a.show()print(\"A\",A.__dict__.keys())# print(\"obj\",a.__dict__.keys()) 实例属性的查找顺序 指的是实例使用.点号来访问属性，会先找实例自己的_dict\\_，如果没有，然后通过属性__class__找到自己的类，再去类的__dict__中找类属性中没找到就往类继承的父类中去查找，最终找到根基类object，没找到则抛出异常 。注意，如果实例使用__dict__[变量名]访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的key查找，不是属性查找。一般来说，类变量可使用全大写来命名。 装饰一个类为一个类通过装饰，添加一些类属性。 1234567891011121314151617#增加类变量def adda_name(name,cls): cls.NAME = name #动态增加类属性#改进成装饰器def add_name(name): def wrapper(cls): cls.NAME = name return cls return wrapper@add_name(\"jerry\")class Person(): #Person = add_name(\"jerry\")(Person) = wrapper(person) = Person AGE = 3# adda_name(Person ,\"tom\") print(Person.__dict__)print(Person.NAME) 之所以能够装饰，本质上是为类对象动态的添加了一个属性，而Person这个标识符指向这个类对象。 类方法和静态方法类方法 12345678class Person: @classmethod def class_method(cls): # cls是什么 print('class = &#123;0.__name__&#125; (&#123;0&#125;)'.format(cls)) cls.HEIGHT = 170 Person.class_method()print(Person.__dict__) 类方法 在类定义中，使用@classmethod装饰器修饰的方法，不管使用实例还是类来调用，调用的都是类的方法，传入当前类自身。 必须至少有一个参数，且第一个参数留给了cls，cls指代调用者即类对象自身 cls这个标识符可以是任意合法名称，但是为了易读，请不要修改 通过cls可以直接操作类的属性 静态方法 123456789101112131415161718192021222324class Person: def method(self,name)： #普通方法 print(self) @classmethod #类方法 def class_method(cls ， age): # cls是什么 是当前类 print('class = &#123;0.__name__&#125; (&#123;0&#125;)'.format(cls)) cls.HEIGHT = 170 @staticmethod #静态方法 def static_methd(a): print(Person.HEIGHT , a) Person.method(Person(),\"ken\") #第一参数不会自动传入，自己传Person（）Person().method(\"tom\") #第一参数自动传入Person（）Person.class_method(20) #第一参数cls自动传入Person().method(18) #第一参数cls自动传入Person.static_methd() #第一参数不用传Person().static_method() #第一参数不用传print(Person.__dict__) 静态方法 在类定义中，使用@staticmethod装饰器修饰的方法 调用时，不管是实例还是类调用，不会隐式的传入参数 。 静态方法，只是表明这个方法属于这个名词空间。函数归在一起，方便组织管理。 总结：类除了普通方法都可以调用，普通方法需要对象的实例作为第一参数。实例可以调用所有类中定义的方法（包括类方法、静态方法），普通方法传入实例自身，静态方法和类方法需要找到实例的类。 实例方法 如果用实例，第一参数则传入self，则叫做绑定。如果使用类调用，则没有绑定（未绑定行为）。 访问控制私有(Private)属性使用双下划线开头的属性名，就是私有属性12345678910111213class Person: def __init__(self, name, age=18): self.name = name self.__age = age def growup(self, i=1): if i &gt; 0 and i &lt; 150: # 控制逻辑 self.__age += i def getage(self): return self.__age print(Person('tom').getage()) 私有变量的本质：类定义的时候，如果声明一个实例变量的时候，使用双下划线，Python解释器会将其改名，转换名称为_类名__变量名的名称，所以用原来的名字访问不到了。 保护变量在变量名前使用一个下划线，称为保护变量。 12345678class Person: def __init__(self, name, age=18): self.name = name self._age = age tom = Person('Tom')print(tom._age)print(tom.__dict__) 可以看出，这个_age属性根本就没有改变名称，和普通的属性一样，解释器不做任何特殊处理。 这只是开发者共同的约定，看见这种变量，就如同私有变量，不要直接使用。 私有方法参照保护变量、私有变量，使用单下划线、双下划线命名方法。 私有方法的本质 单下划线的方法只是开发者之间的约定，解释器不做任何改变。 双下划线的方法，是私有方法，解释器会改名，改名策略和私有变量相同，_类名__方法名 。方法变量都在类的__dict__中可以找到。 私有成员的总结 : 在Python中使用单下划线或者 \\_ 双下划线来标识一个成员被保护或者被私有化隐藏起来。但是，不管使用什么样的访问控制，都不能真正的阻止用户修改类的成员。Python中没有绝对的安全的保护成员或者私有成员。因此，前导的下划线只是一种警告或者提醒，请遵守这个约定。除非真有必要，不要修改或者使用保护成员或者私有成员，更不要修改它们。 1234567891011121314151617class Person: def __init__(self, name, age=18): self.name = name self._age = age def _getname(self): return self.name def __getage(self): return self._age tom = Person('Tom')print(tom._getname()) # 没改名print(tom.__getage()) # 无此属性print(tom.__dict__)print(tom.__class__.__dict__)print(tom._Person__getage()) # 改名了 补丁可以通过修改或者替换类的成员。使用者调用的方式没有改变，但是，类提供的功能可能已经改变了。 猴子补丁（Monkey Patch）：在运行时，对属性、方法、函数等进行动态替换。其目的往往是为了通过替换、修改来增强、扩展原有代码的能力。黑魔法，慎用。 1234567891011# test1.pyfrom test2 import Personfrom test3 import get_score def monkeypatch4Person(): Person.get_score = get_score monkeypatch4Person() # 打补丁 if __name__ == \"__main__\": print(Person().get_score()) 123456# test2.pyclass Person: def get_score(self): # connect to mysql ret = &#123;'English':78, 'Chinese':86, 'History':82&#125; return ret 123# test3.pydef get_score(self): return dict(name=self.__class__.__name__,English=88, Chinese=90, History=85) 上例中，假设Person类get_score方法是从数据库拿数据，但是测试的时候，不方便。为了测试时方便，使用猴子补丁，替换了get_score方法，返回模拟的数据。 属性装饰器一般好的设计是：把实例的属性保护起来，不让外部直接访问，外部使用getter读取属性和setter方法设置属性。 1234567891011121314151617181920212223class Person: def __init__(self, name, age=18): self.name = name self.__age = age @property def age(self): return self.__age @age.setter def age(self, age): self.__age = age @age.deleter def age(self): # del self.__age print('del')tom = Person('Tom')print(tom.age)tom.age = 20print(tom.age)del tom.age 特别注意：使用property装饰器的时候这三个方法同名property装饰器后面跟的函数名就是以后的属性名。它就是getter。这个必须有，有了它至少是只读属性 setter装饰器与属性名同名，且接收2个参数，第一个是self，第二个是将要赋值的值。有了它，属性可写 deleter装饰器可以控制是否删除属性。很少用 property装饰器必须在前，setter、deleter装饰器在后。property装饰器能通过简单的方式，把对方法的操作变成对属性的访问，并起到了一定隐藏效果. 对象的销毁类中可以定义 __del__ 方法，称为析构函数（方法）。 作用：销毁类的实例的时候调用，以释放占用的资源。其中就放些清理资源的代码，比如释放连接。 注意这个方法不能引起对象的真正销毁，只是对象销毁的时候会自动调用它。 使用del语句删除实例，引用计数减1。当引用计数为0时，会自动调用__del__ 方法。由于Python实现了垃圾回收机制，不能确定对象何时执行垃圾回收。 由于垃圾回收对象销毁时，才会真正清理对象，还会在回收对象之前自动调用__del__ 方法，除非你明确知道自己的目的，建议不要手动调用这个方法。 方法重载(overload)其他面向对象的高级语言中，会有重载的概念。所谓重载，就是同一个方法名，但是参数数量、类型不一样，就是同一个方法的重载。 Python没有重载！Python不需要重载！Python中，方法（函数）定义中，形参非常灵活，不需要指定类型（就算指定了也只是一个说明而非约束），参数个数也不固定（可变参数）。一个函数的定义可以实现很多种不同形式实参的调用。所以Python不需要方法的重载。 或者说Python本身就实现了其它语言的重载。 封装面向对象的三要素之一，封装Encapsulation 将数据和操作组织到类中，即属性和方法 将数据隐藏起来，给使用者提供操作（方法）。使用者通过操作就可以获取或者修改数据。getter和setter。 通过访问控制，暴露适当的数据和操作给用户，该隐藏的隐藏起来，例如保护成员或私有成员。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python直接赋值、深拷贝和浅拷贝","slug":"12python直接赋值、深拷贝和浅拷贝","date":"2017-09-30T12:15:17.000Z","updated":"2018-12-07T13:34:13.559Z","comments":true,"path":"2017/09/30/12python直接赋值、深拷贝和浅拷贝/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/30/12python直接赋值、深拷贝和浅拷贝/","excerpt":"","text":"python中，对象赋值实际上是对象的引用。当创建一个对象，将其赋值给另一个变量，python并没有拷贝这个对象，而是拷贝了这个对象的引用。 所以如果从单纯的赋值语句来实现clone对象的话， 那可能bug出现的也会莫名其妙. Python中可以使用copy模块来复制对象. copy.copy 为浅拷贝, 只copy父对象， 不会拷贝对象内部的子对象 copy.deepcopy 深拷贝, 拷贝对象及其子对象 1234567891011121314151617&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,3,4,['a','b']]&gt;&gt;&gt; b = a # 赋值拷贝&gt;&gt;&gt; c = copy.copy(a) # 浅拷贝, 只拷贝了a的引用, 内部元素没有拷贝.&gt;&gt;&gt; d = copy.deepcopy(a) # 深拷贝, 完全拷贝&gt;&gt;&gt;&gt;&gt;&gt; a.append(5) &gt;&gt;&gt; a[4].append('c')&gt;&gt;&gt;&gt;&gt;&gt; print 'a=',aa= [1, 2, 3, 4, ['a', 'b', 'c'], 5]&gt;&gt;&gt; print 'b=',bb= [1, 2, 3, 4, ['a', 'b', 'c'], 5] #赋值拷贝, 内存地址指向一样的。 相当于一个人的两个名字而已.&gt;&gt;&gt; print 'c=',cc= [1, 2, 3, 4, ['a', 'b', 'c']] #浅拷贝, 子元素c[4]引用的地址和a[4]是一样的. 所以改变a[4]相当于改了c[4].&gt;&gt;&gt; print 'd=',dd= [1, 2, 3, 4, ['a', 'b']] #深拷贝完全拷贝. a和d完全改变了.","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-异常处理、模块化","slug":"11python异常处理、模块化","date":"2017-09-21T16:00:00.000Z","updated":"2018-12-11T08:36:37.710Z","comments":true,"path":"2017/09/22/11python异常处理、模块化/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/22/11python异常处理、模块化/","excerpt":"","text":"异常处理异常Exception 错误 Error ：错误是可以避免的逻辑错误：算法写错了，加法写成了减法笔误：变量名写错了，语法错误函数或类使用错误，其实这也属于逻辑错误 异常 Exception ：异常不可能避免本意就是意外情况这有个前提，没有出现上面说的错误，也就是说程序写的没有问题，但是在某些情况下，会出现一些意外，导致程序无法正常的执行下去。例如open函数操作一个文件，文件不存在，或者创建一个文件时已经存在了，或者访问一个网络文件，突然断网了，这就是异常，是个意外的情况。 错误和异常在高级编程语言中，一般都有错误和异常的概念，异常是可以捕获，并被处理的，但是错误是不能被捕获的。 产生异常 产生： raise 语句显式的抛出异常 Python解释器自己检测到异常并引发它 程序会在异常抛出的地方中断执行，如果不捕获，就会提前结束程序（其实是终止当前线程的执行） raise语句raise后什么都没有，表示抛出最近一个被激活的异常，如果没有，则抛类型异常。这种方式很少用 。 raise后要求应该是BaseException类的子类或实例，如果是类，将被无参实例化。 异常类及继承层次 12345678910111213141516171819202122232425262728293031323334353637# Python异常的继承 BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- RuntimeError | +-- RecursionError +-- MemoryError +-- NameError +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- LookupError | +-- IndexError | +-- KeyError +-- SyntaxError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError BaseException及子类 BaseException所有内建异常类的基类是BaseException SystemExitsys.exit(n)函数引发的异常，异常不捕获处理，就直接交给Python解释器，解释器退出。n=0,正常退出，n=1异常退出。 如果except语句捕获了该异常，则继续向后面执行，如果没有捕获住该异常SystemExit，解释器直接退出程序。 1234567891011121314import sys print('before')sys.exit(1)print('SysExit')print('outer') # 不执行# 捕获这个异常import systry: sys.exit(1)except SystemExit: # 换成Exception print('SysExit')print('outer') # 执行 KeyboardInterrupt对应的捕获用户中断行为Ctrl + C 12345678try: import time while True: time.sleep(0.5) passexcept KeyboardInterrupt: print('ctl + c')print('outer') Exception及子类Exception是所有内建的、非系统退出的异常的基类，自定义异常应该继承自它 SyntaxError 语法错误Python将这种错误也归到异常类下面的Exception下的子类，但是这种错误是不可捕获的 ArithmeticError 所有算术计算引发的异常，其子类有除零异常等 LookupError使用映射的键或序列的索引无效时引发的异常的基类：IndexError, KeyError 自定义异常从Exception继承的类 1234567class MyException(Exception): passtry: raise MyException()except MyException: # 捕获自定义异常 print('catch the exception') 未实现和未实现异常12345print(type(NotImplemented))print(type(NotImplementedError))#&lt;class 'NotImplementedType'&gt;#&lt;class 'type'&gt; NotImplemented是个值，单值，是NotImplementedType的实例 NotImplementedError是类型，是异常，返回type 异常的捕获 1234try: 待捕获异常的代码块except [异常类型]: 异常的处理代码块 使用了try…except语句块捕捉到了这个异常，异常生成位置之后语句将不再执行，转而执行对应的except部分的语句，最后执行try…except语句块之外的语句。 except 后接异常类型，用来捕获指定类型的异常，except可以捕获多个异常。 捕获规则捕获是从上到下依次比较，如果匹配，则执行匹配的except语句块如果被一个except语句捕获，其他except语句就不会再次捕获了如果没有任何一个except语句捕获到这个异常，则该异常向外抛出 捕获的原则从小到大，从具体到宽泛 被抛出的异常，应该是异常的实例，使用as子句接收这个抛出的异常。 finally子句 finally最终，即最后一定要执行的，try…finally语句块中，不管是否发生了异常，都要执行finally的部分 finally中一般放置资源的清理、释放工作的语句，也可以在finally中再次捕捉异常。 异常的传递 123456789def foo1():​ return 1/0def foo2():​ print('foo2 start')​ foo1()​ print('foo2 stop')foo2() foo2调用了foo1，foo1产生的异常，传递到了foo2中。异常总是向外层抛出，如果外层没有处理这个异常，就会继续向外抛出如果内层捕获并处理了异常，外部就不能捕获到了如果到了最外层还是没有被处理，就会中断异常所在的线程的执行。注意整个程序结束的状态返回值。 123456789101112131415161718192021222324# 线程中测试异常import threadingimport time def foo1(): return 1/0 def foo2(): time.sleep(3) # 3秒后抛出异常 print('foo2 start') foo1() print('foo2 stop') t = threading.Thread(target=foo2)t.start() while True: time.sleep(1) print('Everything OK') if t.is_alive(): print('alive') else: print('dead') try嵌套 内部捕获不到异常，会向外层传递异常但是如果内层有finally且其中有return、break语句，则异常就不会继续向外抛出：异常被压制。 12345678910111213141516try: try: ret = 1 / 0 except KeyError as e: print(e) finally: print('inner fin')except: print('outer catch')finally: print('outer fin')#输出 #inner fin#outer catch#outer fin 异常的捕获的时机1.立即捕获 需要立即返回一个明确的结果 1234567def parse_int(s): try: return int(s) except: return 0 print(parse_int('s')) 2.边界捕获 封装产生了边界 例如，写了一个模块，用户调用这个模块的时候捕获异常，模块内部不需要捕获、处理异常，一旦内部处理了，外部调用者就无法感知了。例如，open函数，出现的异常交给调用者处理，文件存在了，就不用再创建了，看是否修改还是删除例如，自己写了一个类，使用了open函数，但是出现了异常不知道如何处理，就继续向外层抛出，一般来说最外层也是边界，必须处理这个异常了，否则线程退出 else子句12345678try: ret = 1 * 0except ArithmeticError as e: print(e)else: print('OK')finally: print('fin') else子句没有任何异常发生，则执行 总结 12345678910try: &lt;语句&gt; #运行别的代码except &lt;异常类&gt;： &lt;语句&gt; # 捕获某种类型的异常except &lt;异常类&gt; as &lt;变量名&gt;: &lt;语句&gt; # 捕获某种类型的异常并获得对象else: &lt;语句&gt; #如果没有异常发生finally: &lt;语句&gt; #退出try时总会执行 try的工作原理 1、如果try中语句执行时发生异常，搜索except子句，并执行第一个匹配该异常的except子句2、如果try中语句执行时发生异常，却没有匹配的except子句，异常将被递交到外层的try，如果外层不处理这个异常，异常将继续向外层传递。如果都不处理该异常，则会传递到最外层，如果还没有处理，就终止异常所在的线程3、如果在try执行时没有发生异常，将执行else子句中的语句4、无论try中是否发生异常，finally子句最终都会执行。 模块化Python中只有一种模块对象类型，但是为了模块化组织模块的便利，提供了“包”的概念。模块module，指的是Python的源代码文件。 包package，指的是模块组织在一起的和包名同名的目录及其相关文件。 导入语句 语句 含义 import 模块1，[模块2….] 完全导入 import….as….. 模块别名 import语句 1、找到指定的模块，加载和初始化它，生成模块对象。找不到，抛出ImportError 2、在import所在的作用域的局部命名空间中，增加名称和上一步创建的对象关联。 总结 导入顶级模块，其名称会加入到本地名词空间中，并绑定到其模块对象。 导入非顶层模块，只将其顶级模块名称加入到本地名称空间中。导入的模块必须使用完全限定名称来访问。 如果使用了as，as后的名称直接绑定到导入的模块对象，并将该名称加入到本地名词空间中。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-文件处理、路径处理、序列化和反序列化","slug":"09python文件处理、路径处理、序列化和反序列化","date":"2017-09-09T16:00:00.000Z","updated":"2018-12-07T12:29:31.884Z","comments":true,"path":"2017/09/10/09python文件处理、路径处理、序列化和反序列化/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/10/09python文件处理、路径处理、序列化和反序列化/","excerpt":"","text":"文件IO常用操作一般说IO操作，指的是文件IO。 把文件存储到磁盘上的这个过程，叫做落地。 column column open 打开 read 读取 write 写入 close 关闭 readline 行读取 readlines 多行读取 seek 文件指针操作 tell 指针位置 open打开操作12345open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True,opener=None)f = open(\"file名字\") #文件对象print(f.read()) #读取文件f.close() #关闭文件 打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。基本使用： 创建一个文件test，然后打开它，用完关闭。 文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。 注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。 mode模式 描述字符 r 缺省的，表示只读打开 w 只写打开，有的话就清除重新写 x 创建并写入一个新文件 a 写入打开，如果文件存在，则追加 b 二进制模式 t 缺省的，文本模式 + 读写打开一个文件，给原来只读、只写的增加缺失的功能 open默认是只读模式r打开已经存在的文件。 r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。 w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。 x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。 a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容 r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。 +为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。 t和b： 文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。 二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。 t/b不能单独存在，要和a/w/x/r配合使用。 seek文件指针文件指针，指向当前字节位置。 mode = r，指针起始在0 ，mode = a 指针起始在EOF。 tell（）：显示指针当前位置。 seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。 文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0 12345678910111213# 文本模式f = open('test4','r+')f.tell() # 起始f.read()f.tell() # EOFf.seek(0) # 起始f.read()f.seek(2,0)f.read()f.seek(2,0)f.seek(2,1) # offset必须为0f.seek(2,2) # offset必须为0f.close() 二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。 1234567891011121314# 二进制模式f = open('test4','rb+')f.tell() # 起始f.read()f.tell() # EOFf.write(b'abc')f.seek(0) # 起始f.seek(2,1) # 从当前指针开始，向后2f.read() f.seek(-2,2) # 从EOF开始，向前2f.read()f.seek(-20,2) # OSErrorf.close() 二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。 buffering缓冲区-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是4096或者8192。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。 0 只在二进制模式使用，表示关buffer 1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush 大于1 用于指定buffer的大小 buffer 缓冲区 缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。 flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。 io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。 buffering 说明 buffering = -1 t和b，都是io.DEFAULT_BUFFER_SIZE buffering = 0 b 关闭缓冲区 t 不支持 buffering = 1 b 就一个字节t 行缓冲，遇到换行符才flush buffering &gt; 1 b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。 t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘 | 一般来说： 文本模式，一般都用默认缓冲区大小 二进制模式，是一个个字节的操作，可以指定buffer的大小 一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它 一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候 其他参数编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A） errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略 newline：文本模式中，换行的转换。可以为None、’’ 空串、’\\r’、’\\n’、’\\r\\n’ 。 None表示’\\r’、’\\n’、’\\r\\n’都被转换为’\\n’； ‘’ 表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。 ‘\\n’或’’表示’\\n’不替换；其它合法字符表示’\\n’会被替换为指定的字符 closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。 文件描述符：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。 对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。 read（）read(size=-1)size表示读取的多少个字符或字节；负数或者None表示读取到EOF readline(size=-1)一行行读取文件内容。size设置一次能读取行内几个字符或字节。 readlines(hint=-1)读取所有行的列表。指定hint则返回指定的行数。 write（）write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。 close（）flush并关闭文件对象。文件已经关闭，再次关闭没有任何效果。 其他 名称 说明 seekable（） 是否可seek readable（） 是否可读 writeable（） 是否可写 closed（） 是否已经关闭 上下文管理1、异常处理当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。 12345f = open('test')try: f.write(\"abc\") # 文件只读，写入失败finally: f.close() # 这样才行 使用finally可以保证打开的文件可以被关闭。 上下文管理 使用with … as 关键字 上下文管理的语句块并不会开启新的作用域 with语句块执行完的时候，会自动关闭文件对象 StringIO操作io模块中的类 from io import StringIO 内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 123456789from io import StringIO# 内存中构建sio = StringIO() # 像文件对象一样操作print(sio.readable(), sio.writable(), sio.seekable())# True True Truesio.write(\"luo\\nPython\")sio.seek(0) print(sio.readline()) #mageduprint(sio.getvalue()) # 无视指针，输出全部内容 magedu Pythonsio.close() 好处 一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。 BytesIO操作io模块中的类 from io import BytesIO 内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 12345678from io import BytesIO # 内存中构建bio = BytesIO()print(bio.readable(), bio.writable(), bio.seekable()) #True True Truebio.write(b\"luo\\nPython\")bio.seek(0)print(bio.readline()) # b'magedu\\n'print(bio.getvalue()) # 无视指针，输出全部内容 b'magedu\\nPython'bio.close() file-like对象类文件对象，可以像文件对象一样操作。 socket对象，输入输出对象（stdin、stdout）都是类文件对象 1234from sys import stdout, stderrf = stdoutprint(type(f)) #&lt;class 'ipykernel.iostream.OutStream'&gt;f.write('magedu.com') #magedu.com 路径操作os.path模块3.4版本之前 12345678910from os import pathp = path.join('d:/','tmp')print(type(p), p) #&lt;class 'str'&gt; d:/tmpprint(path.exists(p)) #判断是否存在该路径 Trueprint(path.split(p)) # (head,tail) ('d:/', 'tmp')print(path.abspath('.')) # 打印当前的绝对路径 C:\\Users\\vampire\\pythonp = path.join('D:/', p, 'test.txt') # 'd:/tmp\\\\test.txt'print(path.dirname(p)) # 目录名print(path.basename(p)) #基名，就是文件名print(path.splitdrive(p)) #二元组 ('d:', '/tmp\\\\test.txt'） 1234567p1 = path.abspath(\".\") #“文件路径”print(p1, path.basename(p1))while p1 != path.dirname(p1): p1 = path.dirname(p1) print(p1, path.basename(p1))​ C:\\Users\\vampire\\python pythonC:\\Users\\vampire vampireC:\\Users UsersC:\\​123456789101112131415```##### pathlib模块提供Path对象来操作。包括目录和文件。导入模块：from pathlib import Path**目录操作初始化**：```pythonp = Path() # 当前目录 WindowsPath(&apos;.&apos;)p.absolute()# WindowsPath(&apos;C:/Users/vampire/python&apos;)p = Path(&apos;a&apos;,&apos;b&apos;,&apos;c/d&apos;) # 当前目录下的 WindowsPath(&apos;C:/Users/vampire/python/a/b/c/d&apos;)p = Path(&apos;/etc&apos;) # 根下的etc目录 路径拼接和分解 操作符/Path对象 / Path对象Path对象 / 字符串 或者 字符串 / Path对象 分解parts属性，可以返回路径中的每一个部分 12p3.absolute() #WindowsPath('C:/Users/vampire/python/c/a')p3.absolute().parts #('C:\\\\', 'Users', 'vampire', 'python', 'c', 'a') joinpathjoinpath(*other) 连接多个字符串到Path对象中 1234567891011p = Path() # WindowsPath('.')p = p / 'a' # WindowsPath('a')p.absolute() # WindowsPath('C:/Users/vampire/python/a')p1 = 'b' / p # WindowsPath('C:/Users/vampire/python/b/a')p2 = Path('c') # WindowsPath('C:/Users/vampire/python/c')p2.absolute() # WindowsPath('C:/Users/vampire/python/c')p3 = p2 / p1 # WindowsPath('c/b/a')p3.absolute() # WindowsPath('C:/Users/vampire/python/c/b/a')print(p3.parts) #p3.absolute().parts # ('C:\\\\', 'Users', 'vampire', 'python', 'c', 'b', 'a')p3.joinpath('etc','init.d',Path('httpd')) 获取路径str 获取路径字符串 bytes 获取路径字符串的bytes 1234p = Path('/etc')print(str(p), bytes(p))# \\etc b'\\\\etc' 父目录parent 目录的逻辑父目录 parents 父目录序列，索引0是直接的父 12345678910p = Path('/a/b/c/d')print(p.absolute()) #C:\\a\\b\\c\\dprint(p.parent.parent) #\\a\\bfor x in p.parents: print(x) #\\a\\b\\c#\\a\\b#\\a#\\ 目录的组合部分name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) name 目录的最后一个部分 suffix 目录中最后一个部分的扩展名 stem 目录最后一个部分，没有后缀 suffixes 返回多个扩展名列表 with_suffix(suffix) 有扩展名则替换，无则补充扩展名 with_name(name) 替换目录最后一个部分并返回一个新的路径 123456789p = Path('mysqlinstall/mysql.tar.gz')print(p.name) #mysql.tar.gzprint(p.suffix) #.gzprint(p.suffixes) # ['.tar', '.gz']print(p.stem) # mysql.tarprint(p.with_name('mysql-5.tgz')) #\\mysqlinstall\\mysql-5.tgzprint(p.with_suffix('.png')) #\\mysqlinstall\\mysql.tar.pngp = Path('README') # READMEprint(p.with_suffix('.txt')) # README.txt 判断方法is_dir() 是否是目录，目录存在返回True is_file() 是否是普通文件，文件存在返回True is_symlink() 是否是软链接 is_socket()是否是socket文件 is_block_device()是否是块设备 is_char_device() 是否是字符设备 is_absolute()是否是绝对路径 resolve()返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 absolute() 获取绝对路径 exists()目录或文件是否存在 rmdir()删除空目录。没有提供判断目录为空的方法 touch(mode=0o666, exist_ok=True) 创建一个文件 as_uri() 将路径返回成URI，例如’file:///etc/passwd’ mkdir(mode=0o777, parents=False, exist_ok=False) parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略 iterdir()迭代当前目录 匹配match（pattern） 模式匹配，成功返回True。 123456Path('a/b.py').match('*.py') # TruePath('/a/b/c.py').match('b/*.py') # TruePath('/a/b/c.py').match('a/*.py') # FalsePath('/a/b/c.py').match('a/*/*.py') # TruePath('/a/b/c.py').match('a/**/*.py') # TruePath('/a/b/c.py').match('**/*.py') # True stat() 相当于stat命令 ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息 pathlib模块下的文件操作Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None) 使用的方法类似内建函数open，返回一个文件对象。 3.5增加的新函数 Path.read_bytes() 以’rb’读取路径对应文件，并返回二进制流。看源码 Path.read_text(encoding=None, errors=None) 以’rt’方式读取路径对应文件，返回文本。 Path.write_bytes(data) 以’wb’方式写入数据到路径对应文件。 Path.write_text(data, encoding=None, errors=None) 以’wt’方式写入字符串到路径对应文件。 123456789101112131415p = Path('my_binary_file')p.write_bytes(b'Binary file contents')p.read_bytes() # b'Binary file contents' p = Path('my_text_file')p.write_text('Text file contents')p.read_text() # 'Text file contents' from pathlib import Pathp = Path('o:/test.py')p.write_text('hello python')print(p.read_text())with p.open() as f: print(f.read(5)) csv文件逗号分隔值Comma-Separated Values。 CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 CSV 不指定字符编码。 行分隔符为\\r\\n，最后一行可以没有换行符 列分隔符常为逗号或者制表符。 每一行称为一条记录record 字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。 表头可选，和字段列对齐就行了。 手动生成csv文件 12345678910111213141516from pathlib import Pathp = Path('D:/tmp/test.csv')parent = p.parentif not parent.exists(): parent.mkdir(parents=True,exist_ok =True) #exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。csv_body = '''\\id,name,age,comment1,zs,18,\"I'm 18\"2,ls,20,\"this is a \"\"test\"\" string.\"3,ww,23,\"你好计算机\"'''p.write_text(csv_body) csv模块1def reader(iterable, dialect='excel', *args, **kwargs) 返回一个reader对象，是一个行迭代器 默认使用excel方言，如下： delimiter 列分隔符,逗号 lineterminator 行分隔符\\r\\n quotechar 字段的引用符号，缺省为”双引号 双引号的处理 doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。 escapechar 一个转义字符，默认为None writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符 quoting 指定双引号的规则 QUOTE_ALL 所有字段 QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则 QUOTE_NONNUMERIC非数字字段 QUOTE_NONE都不使用引号。 1def writer(fileobj, dialect='excel', *args, **kwargs) 返回DictWriter实例，主要的方法有writerow，writerows。 1234567891011121314151617181920212223import csv p = Path('d://tmp/tesr.csv')with open(str(p)) as f: reader = csv.reader(f) #返回一个迭代对象 print(next(reader)) #不回头 print(next(reader)) for line in reader: print(line) rows = [ [4,'tom',22,'tom'], (5,'jerry',24,'jerry'), (6,'justin',22,'just\\t\"in'), \"abcdefghi\", ((1,),(2,))]row = rows[0] with open(str(p), 'a',newline=\"\") as f: #newline为了不换行 writer = csv.writer(f) writer.writerow(row) #一次写一条 writer.writerows(rows) #将所有的一次写入 ini文件一般作为配置文件。 ini文件： 1234567891011[DEFAULT]a = test [mysql]default-character-set=utf8 [mysqld]datadir =/dbserver/dataport = 33060character-set-server=utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 中括号里面的部分称为section，译作节、区、段。 每一个section内，都是key=value形成的键值对，key称为option选项。 这里的DEFAULT是缺省section的名字，必须大写。 configparser模块configparser模块的ConfigParser类就是用来操作。 可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。 123456789101112131415161718192021222324252627282930313233read(filenames, encoding=None) #读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。sections() #返回section列表。缺省section不包括在内。 add_section(section_name) #增加一个section。 has_section(section_name) #判断section是否存在 options(section) #返回section的所有option，会追加缺省section的option has_option(section, option) #判断section是否存在这个optionget(section, option, *, raw=False, vars=None[, fallback]) #从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。getint(section, option, *, raw=False, vars=None[, fallback]) getfloat(section, option, *, raw=False, vars=None[, fallback]) getboolean(section, option, *, raw=False, vars=None[, fallback]) #上面3个方法和get一样，返回指定类型数据。items(raw=False, vars=None) items(section, raw=False, vars=None) #没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。set(section, option, value) #section存在的情况下，写入option=value，要求option、value必须是字符串。remove_section(section) #移除section及其所有option remove_option(section, option) #移除section下的option。write(fileobject, space_around_delimiters=True) #将当前config的所有内容写入fileobject中，一般open函数使用w模式。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from configparser import ConfigParserfrom pathlib import Pathfilename = Path(\"d://tmp/mysql.ini\")newfilename = Path(\"d://tmp/mysql111.ini\")cfg = ConfigParser()read_ok = cfg.read(str(filename))print(read_ok)print(cfg.sections())print(cfg.has_section(\"mysql\"))print(\"-\"*30)for k,v in cfg.items(): #未指定section print(k,type(k)) print(v,type(v)) print(cfg.items(k)) print(\"~~~~~~~~~~~~~~~~~~\")print(\"-\"*30)for k,v in cfg.items(\"mysqld\"): #指定section print(k,type(k)) print(v,type(v)) print(\"~~~~~~~~~~\")tmp = cfg.get(\"mysqld\",\"port\")print(tmp, type(tmp))print(cfg.get(\"mysqld\", \"a\"))print(cfg.get(\"mysqld\", \"python\" , fallback= \"linux\")) #按照类型，fallbac：给与缺省值tmp = cfg.getint(\"mysqld\", \"port\")print(type(tmp), tmp)cfg.add_section(\"test\")cfg.set(\"test\",\"test1\",\"1\")cfg.set(\"test\",\"test2\",\"2\")with open(newfilename,\"w+\",newline=\"\") as f: cfg.write(f)print(cfg.getint(\"test\" , \"test1\"))cfg.remove_option(\"test\", \"test1\")# cfg.remove_section(\"test\")# print(\"x\" in cfg[\"test2\"])#字典操作cfg[\"test3\"] = &#123;\"c\":\"1000\"&#125; #没有落地，在内存中修改print(\"x\" in cfg[\"test\"])print(\"c\" in cfg[\"test3\"])# 其他内部方式print(cfg._dict) # 返回默认的字典类型，默认使用有序字典for k, v in cfg._sections.items(): print(k, v)for k,v in cfg._sections['mysqld'].items(): print(k,v)#重新写入文件with open(newfilename, 'w') as f: cfg.write(f) 序列化和反序列化要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。 serialization：序列化将内存中对象存储下来，变成一个个字节 –&gt; 二进制 deseiralization：反序列化将文件中的一个个字节恢复成内存中对象 &lt;–二进制 序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。 pickle库python中的序列化，反序列化模块。 dumps 对象序列化为bytes对象 dump 对象序列化到文件对象，就是存入文件 loads 从bytes对象反序列化 load 对象反序列化，从文件读取数据 序列化的应用一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。 现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。 但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。 不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。 JsonJson(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/ Json的数据类型 值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 字符串：有正负，有整数，浮点数。 对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。 数组：有序的值的集合 格式[val1，，，，valn] 12345678910111213&#123; \"person\": [ &#123; \"name\": \"tom\", \"age\": 18 &#125;, &#123; \"name\": \"jerry\", \"age\": 16 &#125; ], \"total\": 2&#125; Json模块 Python支持少量内建数据类型到Json类型的转换 Python类型 Json类型 True true False false None null str string int integer float float list array dict object 常用方法 Python类型 Json类型 dumps Json编码 dump Json编码并存入文件 loads Json解码 load Json解码，从文件读取数据 一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。 MessagePackMessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 它可以像JSON那样，在许多种语言之间交换结构对象。 兼容 json和pickle。 MessagePack简单易用，高效压缩，支持语言丰富。 所以，用它序列化也是一种很好的选择。 安装：$pip install msgpack-python 常用方法： packb 序列化对象。提供了dumps来兼容pickle和json。 unpackb 反序列化对象。提供了loads来兼容。 pack 序列化对象保存到文件对象。提供了dump来兼容。 unpack 反序列化对象保存到文件对象。提供了load来兼容。 123456789101112131415161718192021import pickleimport jsonimport msgpackd = &#123;\"person\":[&#123;\"name\":\"tom\",\"age\":18&#125;,&#123;\"name\":\"jerry\",\"age\":16&#125;],\"total\":2&#125;j = json.dumps(d)print(j, type(j), len(j)) # 请注意引号的变化print(len(j.replace(' ',''))) # 72 bytes 注意这样替换的压缩是不对的print(\"-\"*30)p = pickle.dumps(d)print(p)print(len(p)) # 101 bytesprint(\"-\"*30)m = msgpack.dumps(d)print(m)print(len(m)) # 48 bytesprint(\"-\"*30)u = msgpack.unpackb(m)print(type(u), u)u = msgpack.loads(m, encoding='utf-8')print(type(u), u) 1234567891011&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &apos;str&apos;&gt; 8272------------------------------b&apos;\\x80\\x03&#125;q\\x00(X\\x06\\x00\\x00\\x00personq\\x01]q\\x02(&#125;q\\x03(X\\x04\\x00\\x00\\x00nameq\\x04X\\x03\\x00\\x00\\x00tomq\\x05X\\x03\\x00\\x00\\x00ageq\\x06K\\x12u&#125;q\\x07(h\\x04X\\x05\\x00\\x00\\x00jerryq\\x08h\\x06K\\x10ueX\\x05\\x00\\x00\\x00totalq\\tK\\x02u.&apos;101------------------------------b&apos;\\x82\\xa6person\\x92\\x82\\xa4name\\xa3tom\\xa3age\\x12\\x82\\xa4name\\xa5jerry\\xa3age\\x10\\xa5total\\x02&apos;48------------------------------&lt;class &apos;dict&apos;&gt; &#123;b&apos;person&apos;: [&#123;b&apos;name&apos;: b&apos;tom&apos;, b&apos;age&apos;: 18&#125;, &#123;b&apos;name&apos;: b&apos;jerry&apos;, b&apos;age&apos;: 16&#125;], b&apos;total&apos;: 2&#125;&lt;class &apos;dict&apos;&gt; &#123;&apos;person&apos;: [&#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18&#125;, &#123;&apos;name&apos;: &apos;jerry&apos;, &apos;age&apos;: 16&#125;], &apos;total&apos;: 2&#125;","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-文件处理、路径处理、序列化和反序列化","slug":"10python文件处理、路径处理、序列化和反序列化","date":"2017-09-09T16:00:00.000Z","updated":"2018-12-07T12:29:31.884Z","comments":true,"path":"2017/09/10/10python文件处理、路径处理、序列化和反序列化/","link":"","permalink":"http://luoqian67.github.io/blog/2017/09/10/10python文件处理、路径处理、序列化和反序列化/","excerpt":"","text":"文件IO常用操作一般说IO操作，指的是文件IO。 把文件存储到磁盘上的这个过程，叫做落地。 column column open 打开 read 读取 write 写入 close 关闭 readline 行读取 readlines 多行读取 seek 文件指针操作 tell 指针位置 open打开操作12345open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True,opener=None)f = open(\"file名字\") #文件对象print(f.read()) #读取文件f.close() #关闭文件 打开一个文件，返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。基本使用： 创建一个文件test，然后打开它，用完关闭。 文件操作中最常用的就是读和写。文件访问的模式有两种：文本模式和二进制模式。 注：windows中使用codepage代码页。可以认为每一个代码页就是一张编码表 cp936和gbk等价。 mode模式 描述字符 r 缺省的，表示只读打开 w 只写打开，有的话就清除重新写 x 创建并写入一个新文件 a 写入打开，如果文件存在，则追加 b 二进制模式 t 缺省的，文本模式 + 读写打开一个文件，给原来只读、只写的增加缺失的功能 open默认是只读模式r打开已经存在的文件。 r 只读打开文件，如果使用write方法，会抛异常。 如果文件不存在，抛出FileNotFoundError异常。 w 表示只写方式打开，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容。 x 文件不存在，创建文件，并只写方式打开，文件存在，抛出FileExistsError异常。 a 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容 r是只读，wxa都是只写。 wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件。 +为r、w、a、x提供缺失的读或写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。 +不能单独使用，可以认为它是为前面的模式字符做增强功能的。 t和b： 文本模式t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是rt。 二进制模式b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型。 t/b不能单独存在，要和a/w/x/r配合使用。 seek文件指针文件指针，指向当前字节位置。 mode = r，指针起始在0 ，mode = a 指针起始在EOF。 tell（）：显示指针当前位置。 seek(offset[, whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始。 文本模式下 whence 0 缺省值，表示从头开始，offset只能正整数 whence 1 表示从当前位置，offset只接受0，whence 2 表示从EOF开始，offest只接受0 12345678910111213# 文本模式f = open('test4','r+')f.tell() # 起始f.read()f.tell() # EOFf.seek(0) # 起始f.read()f.seek(2,0)f.read()f.seek(2,0)f.seek(2,1) # offset必须为0f.seek(2,2) # offset必须为0f.close() 二进制模式下 whence 0 缺省值，表示从头开始，offest只能正整数 whence 1表示从当前位置，offest可正可负，whence 2 表示从EOF开始，offest可正可负。 1234567891011121314# 二进制模式f = open('test4','rb+')f.tell() # 起始f.read()f.tell() # EOFf.write(b'abc')f.seek(0) # 起始f.seek(2,1) # 从当前指针开始，向后2f.read() f.seek(-2,2) # 从EOF开始，向前2f.read()f.seek(-20,2) # OSErrorf.close() 二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。 向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。 buffering缓冲区-1 表示使用缺省大小的buffer。如果是二进制模式，使io.DEFAULT_BUFFER_SIZE值，默认是4096或者8192。如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。 0 只在二进制模式使用，表示关buffer 1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush 大于1 用于指定buffer的大小 buffer 缓冲区 缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。 flush() 将缓冲区数据写入磁盘 close() 关闭前会调用flush()。 io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节。 buffering 说明 buffering = -1 t和b，都是io.DEFAULT_BUFFER_SIZE buffering = 0 b 关闭缓冲区 t 不支持 buffering = 1 b 就一个字节t 行缓冲，遇到换行符才flush buffering &gt; 1 b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush 。 t模式，是io.DEFAULT_BUFFER_SIZE字节，flush完后把当前字符串也写入磁盘 | 一般来说： 文本模式，一般都用默认缓冲区大小 二进制模式，是一个个字节的操作，可以指定buffer的大小 一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它 一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候 其他参数编码：windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5 95 8A） errors ：编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略 newline：文本模式中，换行的转换。可以为None、’’ 空串、’\\r’、’\\n’、’\\r\\n’ 。 None表示’\\r’、’\\n’、’\\r\\n’都被转换为’\\n’； ‘’ 表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行写。 ‘\\n’或’’表示’\\n’不替换；其它合法字符表示’\\n’会被替换为指定的字符 closefd：关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看。 文件描述符：Linux一切皆文件，文件打开后都会有一个位于的文件描述符，在计算机系统中是一个有限的资源。0,1,2,标准输入，标准输出，标准错误输出。 对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源。IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。 一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。 read（）read(size=-1)size表示读取的多少个字符或字节；负数或者None表示读取到EOF readline(size=-1)一行行读取文件内容。size设置一次能读取行内几个字符或字节。 readlines(hint=-1)读取所有行的列表。指定hint则返回指定的行数。 write（）write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件。 close（）flush并关闭文件对象。文件已经关闭，再次关闭没有任何效果。 其他 名称 说明 seekable（） 是否可seek readable（） 是否可读 writeable（） 是否可写 closed（） 是否已经关闭 上下文管理1、异常处理当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是应为资源限制产生的。 12345f = open('test')try: f.write(\"abc\") # 文件只读，写入失败finally: f.close() # 这样才行 使用finally可以保证打开的文件可以被关闭。 上下文管理 使用with … as 关键字 上下文管理的语句块并不会开启新的作用域 with语句块执行完的时候，会自动关闭文件对象 StringIO操作io模块中的类 from io import StringIO 内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 123456789from io import StringIO# 内存中构建sio = StringIO() # 像文件对象一样操作print(sio.readable(), sio.writable(), sio.seekable())# True True Truesio.write(\"luo\\nPython\")sio.seek(0) print(sio.readline()) #mageduprint(sio.getvalue()) # 无视指针，输出全部内容 magedu Pythonsio.close() 好处 一般来说，磁盘的操作比内存的操作要慢得多，内存足够的情况下，一般的思路是少落地，减少磁盘IO的过程，可以大大的提高程序的运行效率。 BytesIO操作io模块中的类 from io import BytesIO 内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 12345678from io import BytesIO # 内存中构建bio = BytesIO()print(bio.readable(), bio.writable(), bio.seekable()) #True True Truebio.write(b\"luo\\nPython\")bio.seek(0)print(bio.readline()) # b'magedu\\n'print(bio.getvalue()) # 无视指针，输出全部内容 b'magedu\\nPython'bio.close() file-like对象类文件对象，可以像文件对象一样操作。 socket对象，输入输出对象（stdin、stdout）都是类文件对象 1234from sys import stdout, stderrf = stdoutprint(type(f)) #&lt;class 'ipykernel.iostream.OutStream'&gt;f.write('magedu.com') #magedu.com 路径操作os.path模块3.4版本之前 12345678910from os import pathp = path.join('d:/','tmp')print(type(p), p) #&lt;class 'str'&gt; d:/tmpprint(path.exists(p)) #判断是否存在该路径 Trueprint(path.split(p)) # (head,tail) ('d:/', 'tmp')print(path.abspath('.')) # 打印当前的绝对路径 C:\\Users\\vampire\\pythonp = path.join('D:/', p, 'test.txt') # 'd:/tmp\\\\test.txt'print(path.dirname(p)) # 目录名print(path.basename(p)) #基名，就是文件名print(path.splitdrive(p)) #二元组 ('d:', '/tmp\\\\test.txt'） 1234567p1 = path.abspath(\".\") #“文件路径”print(p1, path.basename(p1))while p1 != path.dirname(p1): p1 = path.dirname(p1) print(p1, path.basename(p1))​ C:\\Users\\vampire\\python pythonC:\\Users\\vampire vampireC:\\Users UsersC:\\​123456789101112131415```##### pathlib模块提供Path对象来操作。包括目录和文件。导入模块：from pathlib import Path**目录操作初始化**：```pythonp = Path() # 当前目录 WindowsPath(&apos;.&apos;)p.absolute()# WindowsPath(&apos;C:/Users/vampire/python&apos;)p = Path(&apos;a&apos;,&apos;b&apos;,&apos;c/d&apos;) # 当前目录下的 WindowsPath(&apos;C:/Users/vampire/python/a/b/c/d&apos;)p = Path(&apos;/etc&apos;) # 根下的etc目录 路径拼接和分解 操作符/Path对象 / Path对象Path对象 / 字符串 或者 字符串 / Path对象 分解parts属性，可以返回路径中的每一个部分 12p3.absolute() #WindowsPath('C:/Users/vampire/python/c/a')p3.absolute().parts #('C:\\\\', 'Users', 'vampire', 'python', 'c', 'a') joinpathjoinpath(*other) 连接多个字符串到Path对象中 1234567891011p = Path() # WindowsPath('.')p = p / 'a' # WindowsPath('a')p.absolute() # WindowsPath('C:/Users/vampire/python/a')p1 = 'b' / p # WindowsPath('C:/Users/vampire/python/b/a')p2 = Path('c') # WindowsPath('C:/Users/vampire/python/c')p2.absolute() # WindowsPath('C:/Users/vampire/python/c')p3 = p2 / p1 # WindowsPath('c/b/a')p3.absolute() # WindowsPath('C:/Users/vampire/python/c/b/a')print(p3.parts) #p3.absolute().parts # ('C:\\\\', 'Users', 'vampire', 'python', 'c', 'b', 'a')p3.joinpath('etc','init.d',Path('httpd')) 获取路径str 获取路径字符串 bytes 获取路径字符串的bytes 1234p = Path('/etc')print(str(p), bytes(p))# \\etc b'\\\\etc' 父目录parent 目录的逻辑父目录 parents 父目录序列，索引0是直接的父 12345678910p = Path('/a/b/c/d')print(p.absolute()) #C:\\a\\b\\c\\dprint(p.parent.parent) #\\a\\bfor x in p.parents: print(x) #\\a\\b\\c#\\a\\b#\\a#\\ 目录的组合部分name、stem、suffix、suffixes、with_suffix(suffix)、with_name(name) name 目录的最后一个部分 suffix 目录中最后一个部分的扩展名 stem 目录最后一个部分，没有后缀 suffixes 返回多个扩展名列表 with_suffix(suffix) 有扩展名则替换，无则补充扩展名 with_name(name) 替换目录最后一个部分并返回一个新的路径 123456789p = Path('mysqlinstall/mysql.tar.gz')print(p.name) #mysql.tar.gzprint(p.suffix) #.gzprint(p.suffixes) # ['.tar', '.gz']print(p.stem) # mysql.tarprint(p.with_name('mysql-5.tgz')) #\\mysqlinstall\\mysql-5.tgzprint(p.with_suffix('.png')) #\\mysqlinstall\\mysql.tar.pngp = Path('README') # READMEprint(p.with_suffix('.txt')) # README.txt 判断方法is_dir() 是否是目录，目录存在返回True is_file() 是否是普通文件，文件存在返回True is_symlink() 是否是软链接 is_socket()是否是socket文件 is_block_device()是否是块设备 is_char_device() 是否是字符设备 is_absolute()是否是绝对路径 resolve()返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 absolute() 获取绝对路径 exists()目录或文件是否存在 rmdir()删除空目录。没有提供判断目录为空的方法 touch(mode=0o666, exist_ok=True) 创建一个文件 as_uri() 将路径返回成URI，例如’file:///etc/passwd’ mkdir(mode=0o777, parents=False, exist_ok=False) parents，是否创建父目录，True等同于mkdir -p；False时，父目录不存在，则抛出FileNotFoundError exist_ok参数，在3.5版本加入。False时，路径存在，抛出FileExistsError；True时，FileExistsError被忽略 iterdir()迭代当前目录 匹配match（pattern） 模式匹配，成功返回True。 123456Path('a/b.py').match('*.py') # TruePath('/a/b/c.py').match('b/*.py') # TruePath('/a/b/c.py').match('a/*.py') # FalsePath('/a/b/c.py').match('a/*/*.py') # TruePath('/a/b/c.py').match('a/**/*.py') # TruePath('/a/b/c.py').match('**/*.py') # True stat() 相当于stat命令 ，lstat() 同stat()，但如果是符号链接，则显示符号链接本身的文件信息 pathlib模块下的文件操作Path.open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None) 使用的方法类似内建函数open，返回一个文件对象。 3.5增加的新函数 Path.read_bytes() 以’rb’读取路径对应文件，并返回二进制流。看源码 Path.read_text(encoding=None, errors=None) 以’rt’方式读取路径对应文件，返回文本。 Path.write_bytes(data) 以’wb’方式写入数据到路径对应文件。 Path.write_text(data, encoding=None, errors=None) 以’wt’方式写入字符串到路径对应文件。 123456789101112131415p = Path('my_binary_file')p.write_bytes(b'Binary file contents')p.read_bytes() # b'Binary file contents' p = Path('my_text_file')p.write_text('Text file contents')p.read_text() # 'Text file contents' from pathlib import Pathp = Path('o:/test.py')p.write_text('hello python')print(p.read_text())with p.open() as f: print(f.read(5)) csv文件逗号分隔值Comma-Separated Values。 CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 CSV 不指定字符编码。 行分隔符为\\r\\n，最后一行可以没有换行符 列分隔符常为逗号或者制表符。 每一行称为一条记录record 字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义。 表头可选，和字段列对齐就行了。 手动生成csv文件 12345678910111213141516from pathlib import Pathp = Path('D:/tmp/test.csv')parent = p.parentif not parent.exists(): parent.mkdir(parents=True,exist_ok =True) #exist_ok 用在python3.5之后，如果文件目录存在，True则压制异常。csv_body = '''\\id,name,age,comment1,zs,18,\"I'm 18\"2,ls,20,\"this is a \"\"test\"\" string.\"3,ww,23,\"你好计算机\"'''p.write_text(csv_body) csv模块1def reader(iterable, dialect='excel', *args, **kwargs) 返回一个reader对象，是一个行迭代器 默认使用excel方言，如下： delimiter 列分隔符,逗号 lineterminator 行分隔符\\r\\n quotechar 字段的引用符号，缺省为”双引号 双引号的处理 doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀。 escapechar 一个转义字符，默认为None writer = csv.writer(f, doublequote=False, escapechar=‘@’) 遇到双引号，则必须提供转义字符 quoting 指定双引号的规则 QUOTE_ALL 所有字段 QUOTE_MINIMAL特殊字符字段，Excel方言使用该规则 QUOTE_NONNUMERIC非数字字段 QUOTE_NONE都不使用引号。 1def writer(fileobj, dialect='excel', *args, **kwargs) 返回DictWriter实例，主要的方法有writerow，writerows。 1234567891011121314151617181920212223import csv p = Path('d://tmp/tesr.csv')with open(str(p)) as f: reader = csv.reader(f) #返回一个迭代对象 print(next(reader)) #不回头 print(next(reader)) for line in reader: print(line) rows = [ [4,'tom',22,'tom'], (5,'jerry',24,'jerry'), (6,'justin',22,'just\\t\"in'), \"abcdefghi\", ((1,),(2,))]row = rows[0] with open(str(p), 'a',newline=\"\") as f: #newline为了不换行 writer = csv.writer(f) writer.writerow(row) #一次写一条 writer.writerows(rows) #将所有的一次写入 ini文件一般作为配置文件。 ini文件： 1234567891011[DEFAULT]a = test [mysql]default-character-set=utf8 [mysqld]datadir =/dbserver/dataport = 33060character-set-server=utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 中括号里面的部分称为section，译作节、区、段。 每一个section内，都是key=value形成的键值对，key称为option选项。 这里的DEFAULT是缺省section的名字，必须大写。 configparser模块configparser模块的ConfigParser类就是用来操作。 可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典。 123456789101112131415161718192021222324252627282930313233read(filenames, encoding=None) #读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码。sections() #返回section列表。缺省section不包括在内。 add_section(section_name) #增加一个section。 has_section(section_name) #判断section是否存在 options(section) #返回section的所有option，会追加缺省section的option has_option(section, option) #判断section是否存在这个optionget(section, option, *, raw=False, vars=None[, fallback]) #从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有。getint(section, option, *, raw=False, vars=None[, fallback]) getfloat(section, option, *, raw=False, vars=None[, fallback]) getboolean(section, option, *, raw=False, vars=None[, fallback]) #上面3个方法和get一样，返回指定类型数据。items(raw=False, vars=None) items(section, raw=False, vars=None) #没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的section的键值对组成二元组。set(section, option, value) #section存在的情况下，写入option=value，要求option、value必须是字符串。remove_section(section) #移除section及其所有option remove_option(section, option) #移除section下的option。write(fileobject, space_around_delimiters=True) #将当前config的所有内容写入fileobject中，一般open函数使用w模式。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from configparser import ConfigParserfrom pathlib import Pathfilename = Path(\"d://tmp/mysql.ini\")newfilename = Path(\"d://tmp/mysql111.ini\")cfg = ConfigParser()read_ok = cfg.read(str(filename))print(read_ok)print(cfg.sections())print(cfg.has_section(\"mysql\"))print(\"-\"*30)for k,v in cfg.items(): #未指定section print(k,type(k)) print(v,type(v)) print(cfg.items(k)) print(\"~~~~~~~~~~~~~~~~~~\")print(\"-\"*30)for k,v in cfg.items(\"mysqld\"): #指定section print(k,type(k)) print(v,type(v)) print(\"~~~~~~~~~~\")tmp = cfg.get(\"mysqld\",\"port\")print(tmp, type(tmp))print(cfg.get(\"mysqld\", \"a\"))print(cfg.get(\"mysqld\", \"python\" , fallback= \"linux\")) #按照类型，fallbac：给与缺省值tmp = cfg.getint(\"mysqld\", \"port\")print(type(tmp), tmp)cfg.add_section(\"test\")cfg.set(\"test\",\"test1\",\"1\")cfg.set(\"test\",\"test2\",\"2\")with open(newfilename,\"w+\",newline=\"\") as f: cfg.write(f)print(cfg.getint(\"test\" , \"test1\"))cfg.remove_option(\"test\", \"test1\")# cfg.remove_section(\"test\")# print(\"x\" in cfg[\"test2\"])#字典操作cfg[\"test3\"] = &#123;\"c\":\"1000\"&#125; #没有落地，在内存中修改print(\"x\" in cfg[\"test\"])print(\"c\" in cfg[\"test3\"])# 其他内部方式print(cfg._dict) # 返回默认的字典类型，默认使用有序字典for k, v in cfg._sections.items(): print(k, v)for k,v in cfg._sections['mysqld'].items(): print(k,v)#重新写入文件with open(newfilename, 'w') as f: cfg.write(f) 序列化和反序列化要设计一套协议，按照某种规则，把内存中数据保存到文件中，文件是一个字节序列，所以必须把数据转换成&lt;font color=red &gt;字节&lt;/font&gt;序列，输出到文件。这就是序列化。反之，从文件的字节序列恢复到内存。就是反序列化。 serialization：序列化将内存中对象存储下来，变成一个个字节 –&gt; 二进制 deseiralization：反序列化将文件中的一个个字节恢复成内存中对象 &lt;–二进制 序列化保存到文件就是持久化，可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络中接收到的字节序列反序列化。 pickle库python中的序列化，反序列化模块。 dumps 对象序列化为bytes对象 dump 对象序列化到文件对象，就是存入文件 loads 从bytes对象反序列化 load 对象反序列化，从文件读取数据 序列化的应用一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。 将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据反序列化后，就可以使用了。 但是，要注意一点，远程接收端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程的有一致的定义。 现在，大多数项目，都不是单机的，也不是单服务的。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程。 但是，问题是，Python程序之间还可以都是用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议pickle就不太适合了，就需要公共的协议。例如XML、Json、Protocol Buffer等。 不同的协议，效率不同、学习曲线不同，适用不同场景，要根据不同的情况分析选型。 JsonJson(JavaScript Object Notation，JS对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript (w3c组织制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。网址: http://json.org/ Json的数据类型 值：双引号引起来的字符串，数值，true和false，null，对象，数组，这些都是值 字符串：有正负，有整数，浮点数。 对象：无序的键值对的集合，格式{key:value…}，key必须是一个字符串，需要双引号包围这个字符串，value可以是任意合法的值。 数组：有序的值的集合 格式[val1，，，，valn] 12345678910111213&#123; \"person\": [ &#123; \"name\": \"tom\", \"age\": 18 &#125;, &#123; \"name\": \"jerry\", \"age\": 16 &#125; ], \"total\": 2&#125; Json模块 Python支持少量内建数据类型到Json类型的转换 Python类型 Json类型 True true False false None null str string int integer float float list array dict object 常用方法 Python类型 Json类型 dumps Json编码 dump Json编码并存入文件 loads Json解码 load Json解码，从文件读取数据 一般Json编码的数据很少落地，数据都是通过网络传输，传输的时候，要考虑压缩它，节省流量。本质来说它就是个文本，就是个字符串。 MessagePackMessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 它可以像JSON那样，在许多种语言之间交换结构对象。 兼容 json和pickle。 MessagePack简单易用，高效压缩，支持语言丰富。 所以，用它序列化也是一种很好的选择。 安装：$pip install msgpack-python 常用方法： packb 序列化对象。提供了dumps来兼容pickle和json。 unpackb 反序列化对象。提供了loads来兼容。 pack 序列化对象保存到文件对象。提供了dump来兼容。 unpack 反序列化对象保存到文件对象。提供了load来兼容。 123456789101112131415161718192021import pickleimport jsonimport msgpackd = &#123;\"person\":[&#123;\"name\":\"tom\",\"age\":18&#125;,&#123;\"name\":\"jerry\",\"age\":16&#125;],\"total\":2&#125;j = json.dumps(d)print(j, type(j), len(j)) # 请注意引号的变化print(len(j.replace(' ',''))) # 72 bytes 注意这样替换的压缩是不对的print(\"-\"*30)p = pickle.dumps(d)print(p)print(len(p)) # 101 bytesprint(\"-\"*30)m = msgpack.dumps(d)print(m)print(len(m)) # 48 bytesprint(\"-\"*30)u = msgpack.unpackb(m)print(type(u), u)u = msgpack.loads(m, encoding='utf-8')print(type(u), u) 1234567891011&#123;&quot;person&quot;: [&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;jerry&quot;, &quot;age&quot;: 16&#125;], &quot;total&quot;: 2&#125; &lt;class &apos;str&apos;&gt; 8272------------------------------b&apos;\\x80\\x03&#125;q\\x00(X\\x06\\x00\\x00\\x00personq\\x01]q\\x02(&#125;q\\x03(X\\x04\\x00\\x00\\x00nameq\\x04X\\x03\\x00\\x00\\x00tomq\\x05X\\x03\\x00\\x00\\x00ageq\\x06K\\x12u&#125;q\\x07(h\\x04X\\x05\\x00\\x00\\x00jerryq\\x08h\\x06K\\x10ueX\\x05\\x00\\x00\\x00totalq\\tK\\x02u.&apos;101------------------------------b&apos;\\x82\\xa6person\\x92\\x82\\xa4name\\xa3tom\\xa3age\\x12\\x82\\xa4name\\xa5jerry\\xa3age\\x10\\xa5total\\x02&apos;48------------------------------&lt;class &apos;dict&apos;&gt; &#123;b&apos;person&apos;: [&#123;b&apos;name&apos;: b&apos;tom&apos;, b&apos;age&apos;: 18&#125;, &#123;b&apos;name&apos;: b&apos;jerry&apos;, b&apos;age&apos;: 16&#125;], b&apos;total&apos;: 2&#125;&lt;class &apos;dict&apos;&gt; &#123;&apos;person&apos;: [&#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18&#125;, &#123;&apos;name&apos;: &apos;jerry&apos;, &apos;age&apos;: 16&#125;], &apos;total&apos;: 2&#125;","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-函数、高阶函数、装饰器、参数注解","slug":"08python函数、高阶函数、装饰器、参数注解、缓存","date":"2017-08-20T16:00:00.000Z","updated":"2018-12-07T08:31:10.513Z","comments":true,"path":"2017/08/21/08python函数、高阶函数、装饰器、参数注解、缓存/","link":"","permalink":"http://luoqian67.github.io/blog/2017/08/21/08python函数、高阶函数、装饰器、参数注解、缓存/","excerpt":"","text":"函数 1. 函数的定义 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元。 完成一定的功能。 函数也是对象，python把函数的默认值放在了属性中，这个属性就伴随着这个函数对象的整个生命周期。 2. 函数的作用 结构化编程是对代码的最基本的封装，一般按照功能组织一段代码。 封装的目的是为了复用，减少冗余代码。 代码更加简洁美观，可读易懂。 3. 函数的分类： 内建函数；库函数；自建函数 4. 函数的定义、调用定义 def语句定义函数 def 函数名（参数列表）： 函数体（代码块） [return 返回值] 定义中的参数列表成为形式参数，只是一种符号表达，简称形参。 定义需要在调用前，否则会抛出NameError异常。 调用 函数定义，只是声明了一个函数，它不会被指执行，需要调用。 调用的方式，就是函数名加上小括号，括号内写上参数。 调用时写的参数时实际参数，是实实在在传入的值，简称实参 传参时位置参数要放在关键字参数前面。 参数传递：不可变类型，传递副本给函数，函数内操作不影响原始值 可变类型，传递的是地址引用，函数内操作可能影响原始值 定义形参和传递实参时候的注意事项 参数调用时传入的参数要和定义的个数相匹配，可变参数例外 定义时，缺省参数要放在非缺省参数前。 定义时加* ：可变位置参数：可以收集位置参数传入的所有参数，收集多个实参为一个tuple。可变位置参数不能用关键字传参。 形参加**：可变关键字参数，只能用关键字传参。可变关键字参数，收集的实参名称和值组成一个字典，所以可修改。 函数名也是标识符，返回值也是值，函数是可调用的对象，callable(函数名) -&gt; True。 混合使用参数的时候，可变参数要放到参数列表的最后，普通参数要放到参数列表的最前面，可变位置参数发要放在可变关键字参数的前面。 keyword-only参数：如果在一个可变位置参数后面，出现了普通参数，此时这个普通参数已经变成了一个keyword-only参数 参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数。 参数解构： 给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参。 非字典类型使用*解构成位置参数 字典类型使用**解构成关键字参数 提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配。 5.函数的返回值python函数使用return语句返回“返回值”。 所有函数都有返回值。如果没有return语句，隐式调用return None。 return语句并不一定是函数的语句块的最后一条语句 return语句只能执行一次，执行完，函数结束，当前return后面的语句就不会再运行了。所以函数一次只能返回一个值，不能返回多个值，但是可以返回容器，容器里面包含多个值。（return [1,3,5]是指明返回一个列表，是一个列表对象；return 1,3,5看似返回多个值，隐式的被python封装成一个元组） 作用：结束函数调用、返回值。 函数的嵌套 函数有可见范围。这就是作用域的概念 外层变量作用域在内层作用域可见 内部函数不能在外部直接使用，会抛NameError异常，因为它不可见。 6. 作用域 一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域。 全局作用域：在整个函数运行环境中都可见。 局部作用域：在函数、类内部可见；局部变量的使用范围不能超过其所在的局部作用域。 例子： 12345678a = 5def foo(): a += 1foo()---------------------------------------------------------------------------UnboundLocalError Traceback (most recent call last)UnboundLocalError: local variable 'a' referenced before assignment 报错原因： a += 1其实就是a = a + 1,a = 5是全局的变量，虽然能在内部函数foo中可见，但是在foo函数内部出现了 a = ，出现等号就是即赋值即重新定义，那么=的右边作为赋值的内容 ：a+1,但在函数中，此时的a已经算是重新定义了一个局部变量，而不是用外面的全局变量，但是此时a还没有完成赋值就被拿来进行加1操作，所以才会报错。 解决办法： 在这条语句前增加x=0之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义 默认值的作用域 函数名.__defaults__属性：使用元组来保存所有位置参数默认值，它不会因为在函数体中使用了它而发生了变化。 函数名.__kwdefaults__属性：使用字典保存所有keyword-only参数的默认值。 使用可变类型（引用参数）作为默认值，就有可能修改这个默认值。 使用按需修改,例子。12345678910111213141516171819202122232425def foo(xyz=[], u='abc', z=123): xyz = xyz[:] # 影子拷贝 xyz.append(1) print(xyz)foo()print(foo.__defaults__)foo([10])print(foo.__defaults__)foo([10,5])print(foo.__defaults__)# 函数体内，不改变默认值# 使用影子拷贝创建一个新的对象，永远不能改变传入的参数# xyz都是传入参数或者默认参数的副本，如果就想修改原参数，无能为力def foo(xyz=None, u='abc', z=123): if xyz is None: xyz = [] xyz.append(1) print(xyz)# 使用不可变类型默认值# 如果使用缺省值None就创建一个列表# 如果传入一个列表，就修改这个列表 全局变量global使用global关键字的变量，将函数内的定义的局部变量声明成全局变量。 如果函数需要使用外部全局变量，请使用函数的形参传参解决。 尽量不使用 nonlocal关键字nonlocal将变量标记为不再本地作用域定义，而在上一级的某一级局部作用域中定义，但不能是全局作用域中定义。 7.闭包自由变量：未在本地作用域中定义的变量，例如定义在内层函数外的外层函数的作用域中的变量 闭包：是一概念，是嵌套函数中，指的是在内层函数中引用到外层函数的自由变量，就形成了闭包。 8.变量名解析原则LEGB Local，本地作用域、局部作用域的local命名空间。函数调用时创建，调用结束消亡。 Enclosing，Python2.2时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间。 Global，全局作用域，即一个模块的命名空间。模块被import时创建，解释器退出时消亡。 Build-in，内置模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡。例如 print(open)，print和open都是内置的变量。 函数变量作用域：级别：Built_in(内建) &gt; Global(全局) &gt; Enclosing（封装）&gt; local(本地) 9.函数的销毁全局函数销毁 重新定义同名函数 del 语句删除函数对象名称，函数对象的引用计数减1 程序结束时 12345678910def foo(xyz=[], u='abc', z=123): xyz.append(1) return xyzprint(foo(), id(foo), foo.__defaults__)def foo(xyz=[], u='abc', z=123): xyz.append(1) return xyzprint(foo(), id(foo), foo.__defaults__)del fooprint(foo(), id(foo), foo.__defaults__) 局部函数销毁 重新在上级作用域定义同名函数 del 语句删除函数名称，函数对象的引用计数减1 上级作用域销毁时 12345678910111213def foo(xyz=[], u='abc', z=123): xyz.append(1) def inner(a=10): pass print(inner) def inner(a=100): print(xyz) print(inner) return innerbar = foo()print(id(foo),id(bar), foo.__defaults__, bar.__defaults__)del barprint(id(foo),id(bar), foo.__defaults__, bar.__defaults__) 10.递归函数函数是需要压栈的，栈和线程相关。 11.匿名函数没有名字的函数，python借助lamdba表达式构建匿名函数。 参数列表不需要小括号。 冒号是用来区分参数列表和表达式的。 不需要return，表达式的值，就是匿名函数返回值。 lambda表达式（匿名函数）只能写在一行上，被成为单行函数。 用途：在高阶函数传参时，使用lambda表达式，往往能简化代码 格式：lambda 参数列表：表达式 123lambda x : x**2(lambda x : x**2) () #调用 12.高阶函数FIrst Class Object 函数也是对象，可调用对象 函数可以作为普通变量、参数、返回值等等。 高阶函数，至少满足下面的一个条件的函数。 接收一个或者多个函数作为参数，或者函数的输出是一个函数。 13.装饰器装饰器本质上是一个 Python 函数或类。 它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 多装饰器的函数执行顺序，由底向上 14.参数注解文档注解：函数内的最前面，使用三个双引号 函数注解： python3.5引入 对函数的参数进行类型注解 对函数的返回值进行类型注解 只对函数参数做一个辅助的说明，并不对函数参数进行类型检查 提供给第三方工具，做代码分析，发现隐藏的bug 函数注解的信息，保存在__annotations__属性中 变量注解：python3.6引入 函数参数类型检查 思路： 函数参数的检查，一定是在函数外 函数应该作为参数，传入到检查函数中 检查函数拿到函数传入的实际参数，与形参声明对比 __annotations__属性是一个字典，其中包括返回值类型的声明，加入要位置参数的判断，无法和字典中的声明对应，使用inspect模块 inspect模块：提取获取对象信息的函数，可以检查函数和类、类型检查 inspect.isfunction(add) , 是否是函数 inspect.ismethod(add) , 是否是类的方法 inspect.isgenerator(add) , 是否是生成器对象 inspect.isgeneratorfunction(add) , 是否是生成器函数 inspect.isclass(add) ， 是否是类 inspect.ismodule(inspect) , 是否是模块 inspect.isbuiltin(print) , 是否是内建对象 signature(callable)，获取签名（函数签名包含了一个函数的信息，包括函数名，它的参数类型，它的所在的类和名称空间及其他信息） Parameter对象 保存在元组中 输入属性：inspect.signature.parameters.annotation/name/kind/default 返回属性：inspect.signature.return_annotation 当不知道该方法下面有多少属性的时候，可以先用type查看该它的类型，然后通过导入模块，使用参数注解的方式来查看。","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-标准库、解析式、生成器","slug":"07python标准库、解析式、生成器","date":"2017-08-14T16:00:00.000Z","updated":"2018-12-07T08:25:51.877Z","comments":true,"path":"2017/08/15/07python标准库、解析式、生成器/","link":"","permalink":"http://luoqian67.github.io/blog/2017/08/15/07python标准库、解析式、生成器/","excerpt":"","text":"标准库datetime模块 对日期、时间、时间戳的处理 datetime类 类方法： today():返回本地时区当前时间的datetime对象 now(tz=None)：返回当前时间的datetime对象，时间到微秒，如果tz为None，返回和today()一样 utcnow()：没有时区的当前时间（国际化的时候建议用这个） fromtimestamp(timestamp , tz = None) 从一个时间戳返回一个datetime对象 datetime对象 timestamp()：返回一个到微秒的时间戳 时间戳：格林威治时间1970年1月1日0点到现在的秒数。 构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043) year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒 weekday() 返回星期的天，周一0，周日6 isoweekday() 返回星期的天，周一1，周日7 date() 返回日期date对象 time() 返回时间time对象 replace() 修改并返回新的时间 isocalendar() 返回一个三元组(年，周数，周的天) 日期格式化 类方法 strptime(date_string, format) ，返回datetime对象 对象方法 strftime(format) ，返回字符串 字符串format函数格式化 1234import datetimedt = datetime.datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")print(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))print(\"&#123;0:%Y&#125;/&#123;0:%m&#125;/&#123;0:%d&#125; &#123;0:%H&#125;::&#123;0:%M&#125;::&#123;0:%S&#125;\".format(dt)) timedelta对象 datetime2 = datetime1 + timedelta datetime2 = datetime1 - timedelta timedelta = datetime1 - datetime2 构造方法 123- datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) - year = datetime.timedelta(days=365) total_seconds() 返回时间差的总秒数 time模块 time.sleep(secs) 将调用线程挂起指定的秒数（发起一个系统调用，让程序暂停） 解析式列表解析式 语法: [返回值 for 元素 in 可迭代对象 if 条件] 使用中括号[]，内部是for循环，if条件语句可选 返回一个新的列表 列表解析式是一种语法糖： 编译器会优化，不会因为简写而影响效率，反而会因优化而提高了效率。 减少了程序员工作量，减少出错。 简化了代码，但可读性增强，不便于可读。 举例： 获取10以内的偶数12345678#普通even = []for x in range(10): if x % 2 == 0: even.append(x) #解析式even = [x for x in range(10) if x%2 == 0] 思考: 有这样的赋值语句 newlist = [print(i) for i in range(10)]打印出来的是什么？print()把所有的i全打印出来，newlist里面则是10个None 获取20以内的偶数，如果同时是3的倍数，把它打印出来 12[i for i in range(20) if not i % 2 and i % 3 == 0][i for i in range(20) if not i % 2 if i % 3 == 0] 获取20以内2的倍数或者3的倍数，把它打印出来[i for i in range(20) if not i % 2 or i % 3 == 0] “0001.abadicddws” 是ID格式，要求ID格式是以点号分割，左边是4位从1开始的整数，右边是10位随机小写英文字母。请依次生成前100个ID的列表 123456789101112import stringimport randomx= string.ascii_lowercase[\"&#123;:&gt;04&#125;.&#123;&#125;\".format(i,\"\".join(random.choices(x,k = 10))) for i in range(1,8)]['0001.rvverptnre', '0002.beqkpbxhfl', '0003.woxvvayzjo', '0004.wrbnnkelcc', '0005.kpsjowcfvz', '0006.pnqwqzlttc', '0007.wehobydqnf'] 字典解析式 语法： {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}就行了 使用key:value形式 立即返回一个字典用法：1234567&#123;x:(x,x+1) for x in range(10)&#125;&#123;x:[x,x+1] for x in range(10)&#125;&#123;(x,):[x,x+1] for x in range(10)&#125;&#123;[x]:[x,x+1] for x in range(10)&#125; #[x]不可哈希，字典的k要求可哈希&#123;chr(0x41+x):x**2 for x in range(10)&#125;&#123;str(x):y for x in range(3) for y in range(4)&#125; # 输出多少个元素？#会覆盖，返回&#123;0：3，1：3，2：3&#125; 集合解析式 语法 {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}就行了 立即返回一个集合用法12&#123;(x,x+1) for x in range(10)&#125;&#123;[x] for x in range(10)&#125; #[x]是个集合，不能哈希，所以放在集合解析式里面会报错 生成器生成器Generator生成器指的是生成器对象，可以由生成器表达式得到，也可以使用yield关键字得到一个生成器函数，调用这个函数得到一个生成器对象。 生成器函数： 函数体内包含yield语句的函数，返回一个生成器对象，生成器函数的函数体不会立即执行。 生成器对象，是一个可迭代对象，是一个迭代器。 生成器对象，是延迟计算，惰性求值。 next(generator)会从函数的当前位置向后执行到之后碰到的第一个yield语句，会弹出值，并暂停函数执行。 再次执行会执行到下一个yield语句，没有多余的yield语句能执行，如果函数没有显式的return语句，继续调用next函数就会抛出StopIteration异常。 return会导致无法继续获取下一个值，抛出StopIteration异常。 生成器函数，它是函数，不过这个函数不像普通的函数调用时能返回一个合法的值，它返回的是一个还没有求过任何值的生成器对象，用next拨一下才会往后执行一下。 生成器提供了一个send方法，该方法可以和生成器方向沟通。调用send方法，就可以把send的实参传递给yield语句做结果，这个结果可以在等式右边被赋值给其他变量。yield和next一样可以推动生成器启动并执行。 123456789101112131415#举例def gen(): print('line 1') yield 1 print('line 2') yield 2 print('line 3') return 3next(gen()) # line 1next(gen()) # line 1g = gen()print(next(g)) # line 1print(next(g)) # line 2print(next(g, 'End')) # 没有元素给个缺省值print(next(g, 'End')) # 没有元素给个缺省值 生成器的应用 12345678910111213141516171819202122232425262728#计数器def inc(): def counter(): i = 0 while True: i += 1 yield i c = counter() return lambda : next(c)foo = inc()print(foo()) #调用的时候是因为inc()函数返回的是一个匿名函数，而匿名函数的调用方式是（lambda 参数列表：函数体)(),所以调用的时候是foo后要加上（），即也就是inc()()。#等价于def inc(): def counter(): i = 0 while True: i += 1 yield i c = counter() def _inc(): #用到外面的自由变量（c）：闭包 return next(c) return _incfoo = inc() #可调用对象，函数print(foo()) yield fromyield from是python3.3出现的新语法 yield from iterable 是for item in iterable： yield item形式的语法糖。 123456for x in range(1000): yield x #等价于yield from range(1000) 从可迭代对象中一个个拿数据 12345678910def counter(n): #生成器，迭代器 for x in range(n): yield x def inc(n): yield from counter(n) foo = inc(10)print(next(foo))print(next(foo)) 协程coroutine 生成器的高级用法 比进程、线程轻量级 是在用户空间调度函数的一种实现 Python3 asyncio就是协程实现，已经加入到标准库 Python3.5 使用async、await关键字直接原生支持协程 协程调度器实现思路 有2个生成器A、B next(A)后，A执行到了yield语句暂停，然后去执行next(B)，B执行到yield语句也暂停，然后再次调用next(A)，再调用next(B)在，周而复始，就实现了调度的效果 可以引入调度的策略来实现切换的方式 协程是一种非抢占式调度 生成器表达式Generator expression 语法 (返回值 for 元素 in 可迭代对象 if 条件) 列表解析式的中括号换成小括号就行了 返回一个生成器 和列表解析式的区别 生成器表达式是按需计算（或称惰性求值、延迟计算），需要的时候才计算值，返回迭代器，可以迭代，从前到后走完一遍后，不能回头。 列表解析式是立即返回值，返回的不是迭代器，返回可迭代对象列表， 从前到后走完一遍后，可以重新回头迭代。 和列表解析式的对比 计算方式 生成器表达式延迟计算，列表解析式立即计算 内存占用 单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表 生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多 列表解析式构造新的列表需要占用内存 计算速度 单看计算时间看，生成器表达式耗时非常短，列表解析式耗时长 但是生成器本身并没有返回任何值，只返回了一个生成器对象 列表解析式构造并返回了一个新的列表 生成器 可迭代对象(able结尾) 迭代器(or结尾)，是不是迭代器用next（）方法可以检测，iter（）方法可以把一个可迭代对象封装成迭代器。 生成器和迭代器是不同的对象，但都是可迭代对象，生成器对象，就是迭代器对象，迭代器不一定是生成器。 内建函数 标识 id 返回对象的唯一标识，CPython返回内存地址 哈希 hash() 返回一个对象的哈希值 类型 type() 返回对象的类型 类型转换 float() int() bin() hex() oct() bool() list() tuple() dict() set() complex() bytes() bytearray() 输入 input([prompt]) 接收用户输入，返回一个字符串 打印 print(*objects, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) 打印输出，默认使用空格分割、换行结尾，输出到控制台 对象长度 len(s) 返回一个集合类型的元素个数 isinstance(obj, class_or_tuple) 判断对象obj是否属于某种类型或者元组中列出的某个类型 isinstance(True, int) issubclass(cls, class_or_tuple) 判断类型cls是否是某种类型的子类或元组中列出的某个类型的子类 issubclass(bool, int) 绝对值abs(x) x为数值 最大值max() 最小值min() 返回可迭代对象中最大或最小值 返回多个参数中最大或最小值 round(x) 四舍六入五取偶，round(-0.5) pow(x , y) 等价于 x**y range(stop) 从0开始到stop-1的可迭代对象；range(start, stop[, step])从start开始到stop-1结束步长为step的可迭代对象 divmod(x, y) 等价于 tuple (x//y, x%y) sum(iterable[, start]) 对可迭代对象的所有数值元素求和，start：初始值 sum(range(1,100,2)) chr(i) 给一个一定范围的整数返回对应的字符 chr(97) chr(20013) ord(c) 返回字符对应的整数 ord(‘a’) ord(‘中’) sortedsorted(iterable[, key][, reverse] )排序 返回一个新的列表，对一个可迭代对象的所有元素进行排序，默认升序 reverse是反转123sorted([1, 3, 5])sorted([1, 3, 5], reverse=True) #[5， 3 ， 1]sorted(&#123;'c':1, 'b':2, 'a':1&#125;) 翻转 reversed(seq)返回一个翻转元素的迭代器(惰性求值) 12345list(reversed(\"13579\"))&#123; reversed((2, 4)) &#125; # 有几个元素？for x in reversed(['c','b','a']): print(x)reversed(sorted(&#123;1, 5, 9&#125;)) 枚举 enumerate(seq, start=0) 迭代一个序列，返回索引数字和元素构成的二元组start表示索引开始的数字，默认是01234for x in enumerate([2,4,6,8]): print(x)for x in enumerate(\"abcde\"): print(x,end=\" \") 迭代器和取元素 iter(iterable)、next(iterator[, default]) iter将一个可迭代对象封装成一个迭代器next对一个迭代器取下一个元素。如果全部元素都取过了，再次next会抛StopIteration异常12345it = iter(range(5))next(it)it = reversed([1,3,5])next(it) 拉链函数zip(*iterables)像拉链一样，把多个可迭代对象合并在一起，返回一个迭代器将每次从不同对象中取到的元素合并成一个元组 12345list(zip(range(10),range(10)))list(zip(range(10),range(10),range(5),range(10)))dict(zip(range(10),range(10)))&#123;str(x):y for x,y in zip(range(10),range(10))&#125; 过滤数据filter(function, iterable) — &gt;filter object 过滤可迭代对象的元素，返回一个迭代器 function是一个具有一个参数的函数。返回bool 123#例子：过滤出数列中能被3整除的数字In [4]: list(filter(lambda x: x%3 == 0,[1,9,32,3,21,0,-1,123]))Out[4]: [9, 3, 21, 0, 123] reduce：连续计算，连续从一个可迭代对象中获取值，来进行计算，需要从functools模块中导入 映射map(func, *iterables) —-&gt; map object 对多个可迭代对象的元素按照指定的函数进行映射，返回一个迭代器","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python练习","slug":"06python习题代码","date":"2017-08-11T01:00:00.000Z","updated":"2018-12-07T07:48:07.041Z","comments":true,"path":"2017/08/11/06python习题代码/","link":"","permalink":"http://luoqian67.github.io/blog/2017/08/11/06python习题代码/","excerpt":"","text":"打印图形打印锥形12345678910111213141516#给定一个数字和一个符号，打出锥形import mathl = input().split()n = math.floor(math.sqrt((int(l[0])+1)/2))for i in range(-n,n+1): if i &lt; 0 : x = -i print(\" \"*(n-x)+l[1]*(2*x-1)) elif i&gt;1: x = i print(\" \"*(n-x)+l[1]*(2*x-1)) else: print(end=\"\")z = n**2*2-1print(int(l[0])-z) 31 * ******* ***** *** * *** ***** ******* 0 123456#坐标法打印锥形n = 7e = 7//2for i in range(-e,e+1): x = -i if i &lt; 0 else i print(\" \"*(e-x)+ \"*\" * (2*x+1)) ******* ***** *** * *** ***** ******* 打印菱形12345678#打印菱形n = 7e = -(n//2)for i in range(e,n+e): if i&lt;=0: print(\" \"*abs(i)+\"*\"*(n+2*i)) else : print(\" \"*i+\"*\"*(n-2*i)) * *** ***** ******* ***** *** * 打印闪电12345678910#打印闪电n = 7e = n//2for i in range(-e,e+1): if i&lt;0: print(\" \"*abs(i)+ \"*\" * (e+i+1)) elif i == 0: print(\"*\"*n) else: print(\" \"*3+\"*\"*(e-i+1)) * ** *** ******* *** ** * 打印正方形1234567#打印一个边长为n的正方形var = int(input(\"&gt;&gt;\"))for i in range(var): if i ==0 or i == var-1: print(\"*\"*var) else: print(\"*\" + \" \"*(var-2) + \"*\") &gt;&gt;4 **** * * * * **** 123456n = 4for i in range(n): if i % (n-1)==0: print(\"*\"*n) else: print(\"*\"+\" \"*(n-2)+\"*\") **** * * * * **** 12345678#打印一个边长为n的正方形n = int(input(\"&gt;&gt;\"))e = -(n//2)for i in range(e,n+e): if i == e or i == n+e-1: print (\"*\"*n) else : print(\"*\"+\" \"*(n-2)+\"*\") &gt;&gt;6 ****** * * * * * * * * ****** 12345678910111213#统计你输入的每个数字有多少个，按照升序输出l = input().split()l = int(l[0])num = list()num1 = [0]*10while l&gt;0: x = l % 10 num1[x] += 1 num.append(x) l //=10for i in range(10): if num1[i] !=0: print(\"&#123;&#125;:&#123;&#125;\".format(i,num1[i])) 1231013 0:1 1:3 2:1 3:2 1234567891011121314151617181920212223242526272829303132#读数字zz = input().split()a = int(zz[0])l = ['ling','yi','er','san','si','wu','liu','qi','ba','jiu','fu']i = 0li =list()x = ay = abs(a)while abs(x)&gt;0: x = abs(x)//10 i += 1for j in range(i): m = 10**(i-1) y = y// m li.append(y) i -= 1 y = abs(a) % mlength = len(li)if a&gt;0: for i in li: if int(i)&lt;length: print(\"&#123;&#125;\".format(str(l[i])),end=\" \") else: print(\"&#123;&#125;\".format(str(l[i])),end=\"\")else: print(str(l[10]),end=\" \") for i in li: if int(i)&lt;length: print(\"&#123;&#125;\".format(str(l[i])),end=\" \") else: print(\"&#123;&#125;\".format(str(l[i])),end=\"\") -123 fu yi er san 三个数排序1234567891011121314151617181920#只用判断，三个数排序l = list()for i in range(3): l.append(int(input(\"&gt;&gt;\")))if l[0] &gt; l[1]: if l[0] &gt; l[2]: if l[1]&gt;l[2]: print(l[0],l[1],l[2]) else: print(l[0],l[2],l[1]) else: print(l[2],l[1],l[0])else : if l[0] &gt; l[2]: print(l[1],l[0],l[2]) else: if l[1]&lt;l[2]: print(l[2],l[1],l[0]) else: print(l[1],l[2],l[0]) &gt;&gt;1 &gt;&gt;3 &gt;&gt;2 3 2 1 1234567891011#使用max函数，三个数排序l = list()for i in range(3): l.append(int(input(\"&gt;&gt;\")))while l: if len(l) == 1: print(l[0]) break m = max(l) print(m) l.remove(max(l)) &gt;&gt;2 &gt;&gt;3 &gt;&gt;1 3 2 1 123456#使用sort（）函数，三个数排序l = list()for i in range(3): l.append(int(input(\"&gt;&gt;\")))l.sort()l &gt;&gt;1 &gt;&gt;4 &gt;&gt;2 [1, 2, 4] 冒泡法排序（重要）1234567891011121314151617181920#优化后的冒泡法（重要）#l=[1,9,8,5,6,7,4,3,2]l=[1,2,3,4,5,6,7,9,8]length = len(num)count = 0count_swap = 0for i in range(length): flag = False for j in range(length-i-1): count += 1 if l[j] &gt; l[j+1]: tmp = l[j] l[j] = l[j+1] l[j+1] = tmp flag = True count_swap += 1 if not flag: breakprint(l,count,count_swap) [1, 2, 3, 4, 5, 6, 7, 8, 9] 15 1 优化点：可以设定一个标记判断此轮是否有数据交换发生，如果没有发生交换，可以结束排序，如果发生交换，则进行下一轮 最差的排序情况是，初始顺序和目标顺序完全相反，遍历次数1，…,n-1之和n*（n-）/2 最好的排序情况是，初始顺序与目标顺序完全相同，遍历次数n-1 时间复杂度O（n^2） 二分法查找1234567891011121314#二分法查找def banery_serch(list,item): low = 0 high = len(list)-1 while low &lt;= high: mid = (low+high)//2 giss = list[mid] if item == mid: print(Ture) elif item &gt; mid: high = mid - 1 else: low = mid +1my_list = [1,2,3,5,2,6,4,7,9] 给定一个数，输入为几位数，并依次输出12345678910111213141516 #给定一个数，输入为几位数num = int(input(\"&gt;&gt;\"))i = 0flag = Falsewhile num &gt; 0: a = num%10 print(\"a\",a,end=\" \") num = num//10 #给定一个数字判断有几位num = int(input(\"&gt;&gt;\"))i = 1while num &gt;= 10: num = num/10 i += 1print(\"i\",i) &gt;&gt;1234 a 4 a 3 a 2 a 1 12345678910111213 #给定一个数，并依此输出\\nx = '02300'x = int(x)n = 5w = 10000flag = Falsefor i in range(n): y = x // w if flag or y: flag = True print(y,end=\" \") x = x % w w = w //10 2 3 0 0 12345678910111213141516c = int('00211')w = 10000length = 5flag = Falsewhile w: t = c //w if flag: print(t,end=\" \") else: if t: print(t,end=\" \") flag =True else: length -=1 c %= w w //=10 2 1 1 求均值1234567891011a = int(input(\"&gt;&gt;\")) l = list() num = 0 for i in range(a): x = int(input('&gt;&gt;')) if x == None: break else: l.append(x) num = num+l[i] print(num/len(l)) &gt;&gt;3 &gt;&gt;1 1.0 &gt;&gt;3 2.0 &gt;&gt;4 2.6666666666666665 打印乘法表打印倒乘法表123456#打印倒乘法表for i in range(1,10): print(\"\\t\"*(i-1),end=\"\") for j in range(i,10): print (\"&#123;&#125;x&#123;&#125;=&#123;:&lt;&#123;&#125;&#125;\".format(i,j,i*j,2 if j&lt;2 else 3),end=\" \") print() 1x1=1 1x2=2 1x3=3 1x4=4 1x5=5 1x6=6 1x7=7 1x8=8 1x9=9 2x2=4 2x3=6 2x4=8 2x5=10 2x6=12 2x7=14 2x8=16 2x9=18 3x3=9 3x4=12 3x5=15 3x6=18 3x7=21 3x8=24 3x9=27 4x4=16 4x5=20 4x6=24 4x7=28 4x8=32 4x9=36 5x5=25 5x6=30 5x7=35 5x8=40 5x9=45 6x6=36 6x7=42 6x8=48 6x9=54 7x7=49 7x8=56 7x9=63 8x8=64 8x9=72 9x9=81 打印正乘法表12345#打印九九乘法表：for i in range(1,10): for j in range(1,i+1): print(\"&#123;&#125;x&#123;&#125;=&#123;&#125;\\t\".format(j,i,i*j),end=\" \") print() 1x1=1 1x2=2 2x2=4 1x3=3 2x3=6 3x3=9 1x4=4 2x4=8 3x4=12 4x4=16 1x5=5 2x5=10 3x5=15 4x5=20 5x5=25 1x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36 1x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49 1x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64 1x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81 12345#打印九九乘法表：for i in range(1,10): for j in range(1,i+1): print(j,\"x\",i,\"=\",j*i,\" \",end=\" \") print() 1 x 1 = 1 1 x 2 = 2 2 x 2 = 4 1 x 3 = 3 2 x 3 = 6 3 x 3 = 9 1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25 1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36 1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49 1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 8 = 64 1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 9 = 72 9 x 9 = 81 ​ 一到五阶乘之和12345678#一到五阶乘之和a= 1sum = 0for i in range(1,6): a *= i sum += a i += 1print(\"sum =\",sum ) 12345#100内的所有奇数之和a = 0for i in range (1,100,2): a = a+iprint(\"a=\",a) a= 2500 123456#100内的所有奇数之和a = 0for i in range(1,100,2): if not i%2 == 0: a += iprint(\"a=\",a) 斐波那契数列打印100以内的斐波那契数列123456# 打印100以内的斐波那契数列i = 0j = 1while i &lt; 100: print(i,end=\" \") i,j=j,i+j 0 1 1 2 3 5 8 13 21 34 55 89 12345678# 打印100以内的斐波那契数列i = 0j = 1while i&lt;=100: print (i,end=\" \") k = i + j i = j j = k 0 1 1 2 3 5 8 13 21 34 55 89 求斐波那契数列第101项123456789#求斐波那契数列第101项i = 0j = 1m = 1while m&lt;=101: i, j = j, i + j m += 1 print(i) 573147844013817084101 求素数寻常法12345678910111213#求10万内的所有素数import mathn = 100000count = 1for i in range(3,n,2): if i &gt; 10 and i % 5 ==0: continue #所有大于10 的素数中，个位数只有1，3，7，9，所以此处筛出5结尾的 for j in range(3,int(math.sqrt(i)+1),2): if i % j ==0: break else: count += 1print (count) 9592 利用素数列表，空间换时间123456789101112131415161718192021#存储质数#合数一定可以分解为几个质数的乘积，2是质数#质数一定不能整除1和本身之内的整数#使用质数来取模比利用基数取模计算次数更少import mathn = 100000count = 1primenumber = [2]for i in range(3,n,2): flag = False edge = math.sqrt(i) for j in primenumber: if i % j == 0: flag = True break if j &gt; edge: break if not flag: count += 1 primenumber.append(i)print(count) 利用孪生素数123456789101112131415161718#大于3 的素数只有6N-1和6N+1两种形式，如果6N-1和6N+1都是素数便叫作孪生素数import mathn = 100count = 2primenumber = [2,3]step = 2x = 5while x &lt; n: for i in range(3,int(math.sqrt(x)+1),2): if x % i == 0: break else: count += 1 primenumber.append(x) x += step step = 4 if step == 2 else 2print(count)print(primenumber) 埃式筛素数123456789101112#埃式筛素数def eratosthenes(n): IsPrime = [True] * (n + 1) IsPrime[1] = False for i in range(2, int(n ** 0.5) + 1): if IsPrime[i]: for j in range(i * 2, n + 1, i): IsPrime[j] = False return &#123;x for x in range(2, n + 1) if IsPrime[x]&#125;if __name__ == \"__main__\": print (eratosthenes(100)) {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} 杨辉三角计算杨辉三角，普通法12345678910#计算杨辉三角 普通法triangle = [[1],[1,1]]for i in range(2,6): swap = triangle[i-1] cul = [1] for j in range(i-1): cul.append(swap[j]+swap[j+1]) cul.append(1) triangle.append(cul)triangle 计算杨辉三角 补0法12345678910#计算杨辉三角 补0法triangle = [[1]]n = 7for i in range(1,n): swap = triangle[i-1]+[0] cul = [1] for j in range(len(swap)-1): cul.append(swap[j]+swap[j+1]) triangle.append(cul)print(triangle) 杨辉三角，对称法123456789101112#杨辉三角，对称法n=6triangle = [[1],[1,1]]for i in range(2,n): tmp = triangle[-1] cul = [1] * (i+1) for j in range(i//2): cul[j+1] = tmp[j]+tmp[j+1] if i != 2j: cul[-j-2] = cul[j+1] triangle.append(cul)triangle 中点的确定[1][1,1][1,2,1][1,3,3,1][1,4,6,4,1][1,5,10,10,5,1]把整个杨辉三角看成一个左对齐的二维矩阵。i == 2时，在第3行，中点的列索引j==1i == 3时，在第4行，无中点i == 4时，在第5行，中点的列索引j==2得到以下规律，如果i==2j，则有中点 杨辉三角，单列表方法12345678910111213#杨辉三角，单列表解决n = 6row = [1] * nfor i in range(n): z = 1 offset = n - i for j in range(1,i//2+1): val = z + row[j] z = row[j] row[j] = val if i != 2*j: row[-j - offset] = val print(row[:i+1])","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python-内置数据结构","slug":"05python内置数据结构思维导图","date":"2017-07-19T05:15:00.000Z","updated":"2018-12-07T07:44:52.701Z","comments":true,"path":"2017/07/19/05python内置数据结构思维导图/","link":"","permalink":"http://luoqian67.github.io/blog/2017/07/19/05python内置数据结构思维导图/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"python基础","slug":"04python基础","date":"2017-06-30T07:15:17.000Z","updated":"2018-12-07T13:00:08.140Z","comments":true,"path":"2017/06/30/04python基础/","link":"","permalink":"http://luoqian67.github.io/blog/2017/06/30/04python基础/","excerpt":"","text":"基础语法：一.冯诺依曼体系架构：五大部件： CPU:包括运算器和控制器，CPU只和一件设备，内存打交道。 运算器：是完成各类算术运算，逻辑运算，数据传输等数据加工处理。数据是通过总线传输，总线则是使用电信号传输。 控制器：是用于控制程序的执行。 存储器memory：用于记忆程序和数据，例如内存（缺点：掉电易失数据） I 输入设备：将数据或者程序数据传输到计算机中，例如键盘，鼠标。 O 输出设备：将数据或者程序的处理结果展示给用户，例如显示显示器，打印机。 CPU有三级cache，寄存器，cpu临时要计算的数据存储在寄存器中，寄存器的频率和CPU几乎同频率的运算频率，多级缓存则逐级递减。 高级语言和低级语言之间需要一个转换的工具：编译器，解释器。 编译语言：把源代码转换成目标机器的CPU指令。例如：C，C++。解释语言：解释后转换成字节码，运行在虚拟机上，解释器执行中间代码（bytecode）。例如：java，python，C#等语言。 二.程序：算法 + 数据结构 数据是一切程序的核心 数据结构是数据在计算机中的类型和组织方式 算法是处理数据的方式，算法有优劣之分 算法运行时间并不以秒为单位，算法运行时间是从其增速的角度度量的。 python语言类型：python是动态语言、强类型语言。python中：赋值即定义，如果一个变量已经定义，赋值相当于重新定义。（动态语言的特性） 语言的分类： 静态编译语言： 事先声明变量类型，类型不能再改变 编译时检查 动态编译语言： 不用事先声明类型，随时可以赋值为其他类型 编程时不知道是什么类型，很难推断。 强类型语言： 不同类型之间的操作，必须先强制类型转换为同一类型。例：print（’a’+1）弱类型语言： 不同类型之间操作，自动隐式转换，Javascript中console.log(1,+’a’) 重点：什么是动态语言，什么是强类型语言，强弱怎么区分?强弱是一个相对概念，用一个字符串加上一个数字就可判定。 python解释器： 官方Cpython：c语言开发，广泛的python解释器 IPython：一个交互式，功能增强的Cpython PyPy：python语言写的python解释器，JIT（jist type）技术，动态编译python代码。（效率比cpython高）。 Jython：python的源代码编译成java的字节码，跑在JVM上。 IronPython：与Jython类似，运行在.net平台上的解释器，python代码被编译成.net的字节码。 运算符优先级： 算术运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 &gt; 赋值运算符 单目运算符 &gt; 双目运算符 （JVM、PVM）内存管理： 变量无须事先声明，也不需要指定类型（动态语言的特性） python编程中一般无须关心变量的存亡，一般也不用关心内存的管理。 python使用引用技术记录所有对象的引用数： 当对象引用数变为0，它就可以被垃圾回收（GC）的自动回收机制回收(不建议手动管理，会影响性能) 计数增加： 赋值给其他变量就增加引用计数，例如：x=3;y=x. 计数减少： 函数运行结束时，局部变量就会被自动销毁，对象引用计数减少 变量被赋值给其他对象。例如：x=3,y=x（3的计数加一）,x=4（4的计数加一，3的计数减一） 注意：有关性能的时候，就要考虑变量的引用问题，切记尽量不要手动干预，但是该释放内存，还是尽量不释放内存，看需求。注意：垃圾回收还有包括规整，即碎片整理 共享引用：多个变量引用一个对象 ==是判断内容是否相等 is是判断是否指向同一内存空间，使用id来查看内存地址 界限为256，256以下的整数已被python缓存 判断一个东西有多少在引用： 12import syssys.getrefcount(4) False等价布尔值，相当于bool(value) 空集合 空字符串 空字典 空列表 空元组 none对象 0 列表、链表、队列、栈的区别重点：下列四者区别和特点 内存是线性编址的。 列表list：一个队列，一个排列整齐的队伍列表中的个体称作元素，由若干个元素组成列表元素可是是任意对象（数字，字符串，列表，元组，对象）列表内元素有顺序，可以使用索引。列表可以是一个可迭代对象列表是可变的，连续的内存中的顺序结构，通过偏移量在查询（检索起来快）“有顺序”“可索引”“可变”“可迭代”“线性结构”尽量不要使用remove和insert，比较耗时 链表：有序的在内存中分布散落，查询比列表慢，插入比列表快 queue：队列，先进先出不是为了遍历 stack：栈，后进先出 元组修改一般对于返回None的都意味着没有新的产生，就都是就地修改 元组：一个有序的元素组成的集合，不可变对象元组 + 元组，元组*数字，返回一个新元组。并不是改变原先的元组元组是只读的 字符串：是一个字面常量，不可变，可迭代 运算符判断 题 -&gt; 结果 6 or 2 &gt; 1 -&gt; 6 0 or 5 &lt; 4 -&gt; False 5 &lt; 4 or 3 -&gt; 3 2 &gt; 1 or 6 -&gt; True 3 and 2 &gt; 1 -&gt; True 0 and 3 &gt; 1 -&gt; 0 2 &gt; 1 and 3 -&gt; 3 3 &gt; 1and 0 -&gt; 0 print(1 or 2) -&gt; 1 print(0 or 100) -&gt; 100 print(1 and 2) -&gt; 2 print（bool(2)） -&gt; True print(bool(-2)) -&gt; True print(bool(0) -&gt; False 方法： x or y x为 (True) 非零，则返回x x and y x (True)非零，则返回y 非零转换成bool True 0转换成bool是False 拓展：while 1 的效率要比 while True高，因为Ture要先转换成1，然后再转化成二进制 网络传输，big:大端模式， 低字节放在高地址上就是大端模式 高字节放到低地址上就是小端模式 Windows小端模式 mac大端模式 python上下文：使用with方法不用每次都手动关闭文件123with open(\"file.xxx\") as f: for line in f.readlines(): print(line) 使用二进制写文件可以使用一个模块写：pickle.dump(word,file)读：pickle.load(file) 封装和解构： 封装：将多个值使用逗号分隔，结合在一起本质上返回了一个元组，只是省略了小括号t1 = (1,2) # 定义为元组t2 = 1,2 #将1，2封装成元组 解构把右边的元素解开，并顺序的赋给其他变量左边接纳的变量数要和右边解开的元素个数一致使用*变量名接收，但不能单独使用，被*变量名收集后组成一个列表例如： head,*mid,tail = “abcdefghijklmnopqrstuvwxyz” 例：12345temp = aa = bb = temp等价于a , b = b , a 等号右边使用了封装，而左边使用了解构 set和线性结构 线性结构的查询时间复杂度是O(n)，即随着数据规模的增大而增大 set、dict等结构，内部使用hash值作为key，时间复杂度为O(1),查询时间与数据规模无关。 set的元素要求必须可哈希 ​ 可变的数据结构不可哈希 ​ 元素不可索引 ​ set可以迭代 线性结构： 可迭代 for … in len()可以获取长度 通过下标可访问 可以切片 包括：列表、元组、字符串、bytes、bytearray不可变对象：元组、字符串、bytes 可hash对象：数值型：int、float、complex布尔型：True、False字符串：string、bytestuple，None以上都为不可变类型 可变类型：list，dict，bytearray 可迭代对象 能够通过迭代一次次返回不同的元素的对象。 所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，[‘a’, ‘a’]，虽然这个列表有2个元素，值一样，但是两个’a’是不同的元素 可以迭代，但是未必有序，未必可索引 可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器等 可以使用成员操作符in、not in，in本质上就是在遍历对象 字典的遍历和移除：不能直接遍历删除字典，要使用一个容器记录一个这个字典的key，然后通过遍历key来从字典中删除。 权限判定可以将弄成集合加载到内存中进行集合计算，速度要比在数据库中操作对比快得多。比如说微博的redis OrderedDict有序字典可以记录元素插入的顺序，打印的时候也是按照这个顺序输出打印3.6版本的Python的字典就是记录key插入的顺序（IPython不一定有效果） 应用场景： 假如使用字典记录了N个产品，这些产品使用ID由小到大加入到字典中 除了使用字典检索的遍历，有时候需要取出ID，但是希望是按照输入的顺序，因为输入顺序是有序的 否则还需要重新把遍历到的值排序 光盘、磁盘都是随机访问的","categories":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://luoqian67.github.io/blog/tags/python/"}]},{"title":"Linux基础-文件管理和重定向","slug":"03Linux基础（二）-文件管理和重定向","date":"2017-04-15T07:18:00.000Z","updated":"2018-12-07T07:34:19.661Z","comments":true,"path":"2017/04/15/03Linux基础（二）-文件管理和重定向/","link":"","permalink":"http://luoqian67.github.io/blog/2017/04/15/03Linux基础（二）-文件管理和重定向/","excerpt":"","text":"Linux基础-文件管理和重定向1. 每一个分区都是一个独立存在的文件系统2. 目录：路径映射符3. 文件文件有两种数据 元数据：描述数据的数据属性 metadata 数据：data FHS：文件系统层级结构标准 4. Linux下的文件类型 -：普通文件 d：目录文件 b：块设备 c：字符设备 l：符号链接文件 p：管道文件pip，FIFO（first in，first out） s：套接字文件：服务加IP端口，作为一个服务的入口。socket 5. 显示当前路径 每个shell和系统进程都有一个当前的工作目录 CWD:current work directory 显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 6. 绝对路径和相对路径绝对路径: 以正斜杠开始 完整的文件的位置路径 可用于任何想指定一个文件名的时候 相对路径名: 不以斜线开始 指定相对于当前工作目录或某目录的位置 可以作为一个简短的形式指定一个文件名 注： 基名:basename 目录名:dirname 7. cd命令cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录 ：cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd - 选项：-P 相关的环境变量： 显示环境变量：printenv PWD：当前目录路径 OLDPWD：上一次目录路径 ~ ：当前用户家目录 ~luo ：用户luo家目录 ~+ ：当前工作目录 ~- ：前一个工作目录 8. 显示目录 列出当前目录的内容或指定目录(显示的数据都是元数据) 用法：ls [options][files_or_dirs] 示例: ls -a ：包含隐藏文件 ls -l ：显示额外的信息 ls -R ：目录递归显示 ls -ld ： 目录和符号链接信息 ls -1 ：文件分行显示 ls –S ：按从大到小排序 ls –t ： 按mtime排序 ls –u ：配合-t选项，显示并按atime从新到旧排序 ls –U : 按目录存放顺序显示 ls –X : 按文件后缀排序 9. 查看文件状态:显示当前文件的时间戳 命令：stat 文件：metadata, data 三个时间戳： access time：访问时间，atime，读取文件内容 modify time: 修改时间, mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变 注意：元数据发生变化，数据不一定变化数据发生变化，元数据一定变化 10. 文件通配符（对文件名做通配）(glob、globing、wildcard) * ：匹配零个或多个字符 ? ：匹配任何单个字符 [0-9] : 匹配数字范围 [a-z] ：字母 [A-Z] ：字母 [wang] : 匹配列表中的任何的一个字符 [^wang] : 匹配列表中的所有字符以外的字符 预定义的字符类：（帮助：man 7 glob） [:digit:]：任意数字，相当于0-9 [:lower:]：任意小写字母 [:upper:]：任意大写字母 [:alpha:]：任意大小写字母 [:alnum:]：任意数字或字母 [:blank:]：水平空白字符 [:space:]：水平或垂直空白字符 [:punct:]：标点符号 [:print:]：可打印字符 [:cntrl:]：控制（非打印）字符 [:graph:]：图形字符 [:xdigit:]：十六进制字符 11. touch命令：touch [OPTION]... FILE... -a 仅改变 atime和ctime -m 仅改变 mtime和ctime -t [[CC]YY]MMDDhhmm[.ss]指定atime和mtime的时间戳 -c 如果文件不存在，则不予创建 例如：touch -m -t 201806300000.00 /etc/passwd 1234567891011121314151617[root@localhost ~]# stat /etc/passwdFile: `/etc/passwd&apos;Size: 1677 Blocks: 8 IO Block: 4096 regular fileDevice: 803h/2051d Inode: 787752 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: (0/ root)Access: 2017-04-10 18:57:44.311586312 +0800Modify: 2017-04-10 18:48:32.693647980 +0800Change: 2017-04-10 18:48:32.693647980 +0800[root@localhost ~]# touch -m -t 201703300000.00 /etc/passwd[root@localhost ~]# stat /etc/passwdFile: `/etc/passwd&apos;Size: 1677 Blocks: 8 IO Block: 4096 regular fileDevice: 803h/2051d Inode: 787752 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2017-04-10 18:57:44.311586312 +0800Modify: 2017-03-30 00:00:00.000000000 +0800Change: 2017-04-10 14:13:22.439425983 +0800 12. 复制：所谓的复制就是创建一个新的空文件，然后在将源文件的数 据流读出来，然后写进去。cp默认不复制目录下的内容，选项：-r：递归复制12341.cp [OPTION]... [-T] SOURCE DEST2.cp [OPTION]... SOURCE... DIRECTORY3.cp [OPTION]... -t DIRECTORY SOURCE...（2.3等同）4.cp SRC DEST SRC是文件： 如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中。 ​ 基于安全，建议为cp命令使用-i选项。 如果DEST是目录：在DEST下新建与原文件同名的文件，并 将SRC中内容填充至新文件中。 cp SRC… DEST SRC…：多个文件 DEST必须存在，且为目录，其它情形均会出错； cp SRC DEST SRC是目录：此时使用选项：-r 如果DEST不存在：则创建指定目录，复制SRC目录中所有文件 至DEST中； 如果DEST存在： 如果DEST是文件：报错 如果DEST是目录 cp的常用选项 1234567891011121314151617-i：覆盖前提示 –n:不覆盖，注意两者顺序-r, -R: 递归复制目录及内部的所有内容-a: 归档，相当于-dR --preserv=all-d：--no-dereference --preserv=links 不复制件，只 复制 链接名--preserv[=ATTR_LIST] （元数据信息） mode: 权限 ownership: 属主、属组 timestamp: （时间戳（atime、mtime不变）（cti会变）） links：链接属性 xattr：拓展属性 context：保持selinux的安全属性 all：以上所有-p: 等同--preserv=mode,ownership,timestamp-v: --verbose 显示提示信息-f: --force 强制-u:--update 只复制源比目标更新文件或目标不存在的文件--backup=numbered 目标存在，覆盖前先备份加数字后缀 cp命令中：具体的流程是： 分配一个空闲的inode号，在inode表中生成新条目，在目录中创建一个目录项，将名称inode编号关联拷贝数据生成新的文件。 13. 移动和重命名文件123mv [OPTION]... [-T] SOURCE DESTmv [OPTION]... SOURCE... DIRECTORYmv [OPTION]... -t DIRECTORY SOURCE... 常用选项： -i: 交互式 -f: 强制 mv操作时，具体的流程是： 如果mv命令的目标和源在相同的文件系统，作为mv 命令用新的文件名创建对应新的目录项，删除旧目录条目对应的旧的文件名，不影响inode（除时间戳）或磁盘上的数据位置：没有数据被移动！ 如果目标和源在一个不同的文件系统， mv相当于cp和rm。 14. 删除rm [OPTION]... FILE... 常用选项： -i: 交互式 -f: 强制删除 -r: 递归 –no-preserve-root : 强制删除/目录，忽略root示例： rm -rf / rm操作时候，具体的逻辑是： 链接数递减，从而释放的inode号可以被重用 把数据块放在空闲列表中 删除目录项 数据实际上不会马上被删除，但当另一个文件使用数据块时将被覆盖。 15. 目录操作tree 显示目录树 -d: 只显示类型为目录 -L level：指定显示的层级数目 -P ：pattern 只显示由指定pattern匹配到的路径123[root@localhost ~]# tree -P *Base* /etc/yum.repos.d//etc/yum.repos.d/└── CentOS-Base.repo mkdir 创建目录 -p: 存在时不报错，且可自动创建所需的各目录 -v: 显示详细信息 -m MODE: 创建目录时直接指定权限123[root@localhost ~]# mkdir -p -v -m 777 /tmp/cmkdir: created directory `/tmp/c&apos;[root@localhost ~]# rmdir 删除空目录 -p: 递归删除父空目录 -v: 显示详细信息 rm -r 递归删除目录树12345678910[root@localhost ~]# mkdir -p -v /tmp/x/y/zmkdir: created directory `/tmp/x&apos;mkdir: created directory `/tmp/x/y&apos;mkdir: created directory `/tmp/x/y/z&apos;[root@localhost ~]# rmdir -p -v /tmp/x/y/zrmdir: removing directory, `/tmp/x/y/z&apos;rmdir: removing directory, `/tmp/x/y&apos;rmdir: removing directory, `/tmp/x&apos;rmdir: removing directory, `/tmp&apos;rmdir: failed to remove directory `/tmp&apos;: Directory not empty 16. 索引节点inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项(inode table)，包含有关文件的信息（ 元数据 包括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 文件引用一个是 inode号 人是通过文件名来引用一个文件 一个目录是目录下的文件名和文件inode号之间的映射 17. 硬链接和软链接详细说明[https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/inde.html#listing1(https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/inde.html#listing1 “转载自IBM博客”)​ 1. 硬链接 创建硬链接会增加额外的记录项以引用文件 对应于同一文件系统上一个物理文件 每个目录引用相同的inode号 创建时链接数递增 删除文件时： rm命令递减计数的链接 文件要存在，至少有一个链接数 当链接数为零时，该文件被删除 不能跨越驱动器或分区 语法: ln filename [linkname ] 注意： 目录不能使用硬链接 2. 软链接 一个符号链接指向另一个文件 ls - l的 显示链接的名称和引用的文件 一个符号链接的内容是它引用文件的名称 可以对目录进行 可以跨分区 指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增 - 加或减目标文件inode的引用计数； 语法：ln -s filename ​​[linkname] 注意:加粗部分为硬链接和软链接的核心区别。 18. 确定文件内容文件可以包含多种类型的数据检查文件的类型，然后确定适当的打开命令或应用程序使用​语法：file [options] &lt;filename&gt;...​常用选项: -b 列出文件辨识结果时，不显示文件名称 -f filelist 列出文件filelist中文件名的文件类型 -F 使用指定分隔符号替换输出文件名后默认的”:”分隔符 -L 查看对应软链接对应文件的文件类型 –help 显示命令在线帮助 19. 标准输入与输出 程序：指令+数据 读入数据：Input 输出数据：Output 打开的文件都有一个fd: file descriptor (文件描述符) Linux给程序提供三种I/O设备 标准输入（STDIN）－0 默认接受来自键盘的输入 标准输出（STDOUT）－1 默认输出到终端窗口 标准错误（STDERR）－2 默认输出到终端窗口 I/O重定向：改变默认位置 输入重定向： 12345[root@localhost ~]# cat &gt; /tmp/luoq.txt &lt;&lt;EOF&gt; woshishui&gt; EOF[root@localhost ~]# cat /tmp/luoq.txtwoshishui 20. 把输出和错误重新定向到文件 STDOUT和STDERR可以被重定向到文件 命令 操作符号 文件名 支持的操作符号包括： > 把STDOUT重定向到文件 2&gt; 把STDERR重定向到文件 &amp;&gt; 把所有输出重定向到文件12345678910[root@localhost ~]# touch /tmp/error.txt;cat /tmp/luo.txt1 2&gt;/tmp/error.txt[root@localhost ~]# cat /tmp/error.txtcat: /tmp/luo.txt1: No such file or directory[root@localhost ~]# [root@localhost ~]# cat /tmp/luoq.txt &amp;&gt; /tmp/error.txt[root@localhost ~]# cat /tmp/error.txtwoshishui[root@localhost ~]# cat /tmp/luoq.txt11 &amp;&gt; /tmp/error.txt[root@localhost ~]# cat /tmp/error.txtcat: /tmp/luoq.txt11: No such file or directory > 文件内容会被覆盖 set –C 禁止将内容覆盖已有文件,但可追加 >| file 强制覆盖 set +C 允许覆盖 >&gt; 原有内容基础上，追加内容 2&gt; 覆盖重定向错误输出数据流 2&gt;&gt; 追加重定向错误输出数据流 标准输出和错误输出各自定向至不同位置 COMMAND &gt; /path/to/file.out 2&gt;/path/to/error.out 合并标准输出和错误输出为同一个数据流进行重定向 &amp;&gt; 覆盖重定向 &amp;&gt;&gt; 追加重定向 COMMAND &gt; /path/to/file.out 2&gt;&amp;1 （顺序很重要） COMMAND &gt;&gt; /path/to/file.out 2&gt;&amp;1 ()：合并多个程序的STDOUT ( cal 2007 ; cal 2008 ) &gt; all. 21. tr命令tr 转换和删除字符​ 语法:tr [OPTION]... SET1 [SET2] 选项： -c –C –complement：取字符集的补集 -d –delete：删除所有属于第一字符集的字符 -s –squeeze-repeats：把连续重复的字符以单独一个字符表示 -t –truncate-set1：将第一个字符集对应字符转化为第二字符集对应的字符 [:alnum:]：字母和数字 [:alpha:]：字母 [:cntrl:]：控制（非打印）字符 [:digit:]：数字 [:graph:]：图形字符 [:lower:]：小写字母 [:print:]：可打印字符 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制字符 例如：tr ‘a-z’ ‘A-Z’&lt; /etc/issue 22. 管道 管道（使用符号“|”表示）用来连接命令 命令1 | 命令2 | 命令3 | … 将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT送到命令3的STDIN STDERR默认不能通过管道转发，可利用2&gt;&amp;1 或 |&amp; 实现 最后一个命令会在当前shell进程的子shell进程中执行来 组合多种工具的功能 ls | tr ‘a-z’ ‘A-Z’ 有些命令不支持管道传输过来的数据，可以加上 - 执行 23. tee命令，一路输入两路输出 命令1 | tee [-a ] 文件名 | 命令2 把命令1的STDOUT保存在文件中，做为命令2的输入 -a 追加 使用： 保存不同阶段的输出 复杂管道的故障排除 同时查看和记录输出 例如：[root@localhost ~]# cat /etc/passwd | tr -d &#39;abc&#39; | tr &#39;d-z&#39; &#39;D-Z&#39; | tee /tmp/luo.txt 24. selinux：安全Linux策略 配置文件在/etc/selinux/config ： 查看状态的命令：getenforce 三种状态： enforcing：强制：违反规则不能运行 permissive许可：可以允许运行，但是会记录，用来后期的审计 disabled：禁用：关闭selinux 25. 历史命令：history的环境变量配置：HISTCONTROL -ignoredups（忽略重复） -ignorespace（忽略空格） -ignoreboth（忽略所有) 26.权限认证；授权：审计 Authentication；Authorization；Adition","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/tags/Linux/"}]},{"title":"umask总结","slug":"02umask总结","date":"2017-03-29T01:14:00.000Z","updated":"2018-12-13T13:16:06.936Z","comments":true,"path":"2017/03/29/02umask总结/","link":"","permalink":"http://luoqian67.github.io/blog/2017/03/29/02umask总结/","excerpt":"","text":"umask总结umask：反向掩码 umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask 如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定 umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~/.bashrc","categories":[{"name":"杂项","slug":"杂项","permalink":"http://luoqian67.github.io/blog/categories/杂项/"}],"tags":[]},{"title":"Linux基础-权限管理","slug":"01Linux基础（一）-权限管理","date":"2017-03-28T01:11:00.000Z","updated":"2018-12-07T07:24:35.405Z","comments":true,"path":"2017/03/28/01Linux基础（一）-权限管理/","link":"","permalink":"http://luoqian67.github.io/blog/2017/03/28/01Linux基础（一）-权限管理/","excerpt":"","text":"Linux基础-权限管理一.权限管理1.用户权限：认证：1.1 Authentication；授权：Authorization；审计：Adition 1.2 Linux用户和组的主要配置文件： /etc/passwd：用户及其属性信息（名称、UID、主组ID等） /etc/group：组及其属性信息 /etc/shadow：用户密码及其相关属性 /etc/gshadow：组密码及其相关属性 1.3 安全上下文：进程代表用户在进行：谁启动了进程，进程就拥有谁的身份（以进程（process）发起者的身份运行）。 root:/bin/cat mage:/bin/cat 1.4 用户1.4.1 用户User： 令牌token,identity Linux用户：Username/UID 用户级别： 管理员：root, 0 普通用户：1-65535 系统用户：1-499, 1-999 （CentOS7） 对守护进程获取资源进行权限分配 登录用户:500+, 1000+（CentOS7） 交互式登录 1.4.2 passwd文件格式： login name：登录用名（wang） passwd：密码 (x) UID：用户身份编号 (1000) GID：登录默认所在组编号 (1000) GECOS：用户全名或注释 home directory：用户主目录 (/home/wang) shell：用户默认使用shell (/bin/bash) 123tcpdump:x:72:72::/:/sbin/nologinvampire:x:500:500:vampire:/home/vampire:/bin/bashmysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/false 1.4.3 shadow文件格式： 登录用名 用户密码:一般用sha512加密 从1970年1月1日起到密码最近一次被更改的时间 密码再过几天可以被变更（0表示随时可被变更） 密码再过几天必须被变更（99999表示永不过期） 密码过期前几天系统提醒用户（默认为一周） 密码过期几天后帐号会被锁定 从1970年1月1日算起，多少天后帐号失效 123tcpdump:!!:17735::::::vampire:$6$yk7XOpZX0ZngOz6D$qVI/.Q7Ch7M.KRfjsPC. WTiN9w2qJgUofENaFlnLxXpvzIN/lICVwcIme1b3LHMixqXxnEIGkgepuUIpsoadU1:1773 5:0:99999:7:::mysql:!!:17737:::::: 1.4.4 用户创建语法：useradd [options] LOGIN -u UID -o 配合-u 选项，不检查UID的唯一性 -g GID：指明用户所属基本组，可为组名，也可以GID -c “COMMENT”：用户的注释信息 -d HOME_DIR: 以指定的路径(不存在)为家目录 -s SHELL: 指明用户的默认shell程序 ​ 可用列表在/etc/shells文件中 -G GROUP1[,GROUP2,…]：为用户指明附加组，组须事先存在 -N 不创建私用组做主组，使用users组做主组 -r: 创建系统用户 CentOS 6: ID&lt;500，CentOS 7: ID&lt;1000 -m 创建家目录，用于系统用户 -M 不创建家目录，用于非系统用户 123[root@localhost ~]# useradd -u 111 luoqian -c \"vamp\" -s /bin/csh -m[root@localhost ~]# tail -1 /etc/passwdluoqian:x:111:501:vamp:/home/luqoian:/bin/csh 1.4.5 用户属性的修改：语法：`usermod [OPTION] login -u UID: 新UID -g GID: 新主组 -G GROUP1[,GROUP2,…[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项 -s SHELL：新的默认SHELL -c ‘COMMENT’：新的注释信息 -d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用-m选项 -l login_name: 新的名字； -L: lock指定用户,在/etc/shadow 密码栏的增加 ! -U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉 -e YYYY-MM-DD: 指明用户账号过期日期 -f INACTIVE: 设定非活动期限 1.4.6 删除用户：语法：userdel [OPTION]... login -r: 删除用户家目录 1.4.7 切换用户或以其他用户身份执行命令语法：su [options...] [-] [user [args...]] 切换用户的方式： su UserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录 su - UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换 root su至其他用户无须密码；非root用户切换时需要密码 换个身份执行命令： su [-] UserName -c &#39;COMMAND&#39; 选项：-l --login ​ su -l UserName 相当于 su - UserName 1.4.8 修改密码语法：passwd [OPTIONS] UserName:修改指定用户的密码 常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 1.5 组1.5.1 Linux组的类别 用户的主要组（primary group） 用户必须属于一个且只有一个主组 组名同用户名，且仅包含一个用户，私有组 用户的附加组（supplementary group） 一个用户可以属于零个或多个附加组 1.5.2 组group： Linux组：Groupname/GID 管理员组：root, 0 普通组： 系统组：1-499, 1-999（CENTOS7） 普通组：500+, 1000+（CENTOS7） 1.5.3 group文件格式 群组名称：就是群组名称 群组密码：通常不需要设定，密码是被记录在 /etc/gshadow GID：就是群组的 ID 以当前组为附加组的用户列表(分隔符为逗号) 1234[root@localhost ~]# cat /etc/grouproot:x:0:bin:x:1:bin,daemondaemon:x:2:bin,daemon 1.5.4 gshadow文件格式 群组名称：就是群组名称 群组密码： 组管理员列表：组管理员的列表，更改组密码和成员 以当前组为附加组的用户列表：(分隔符为逗号) 12345[root@localhost ~]# cat /etc/gshadowroot:::bin:::bin,daemondaemon:::bin,daemonsys:::bin,adm 1.5.5 创建组：语法：groupadd [OPTION]... group_name -g GID: 指明GID号；[GID_MIN, GID_MAX] -r: 创建系统组 CentOS 6: ID&lt;500 CentOS 7: ID&lt;1000 1.5.6 修改和删除组： 组属性修改：groupmod语法：groupmod [OPTION]… group 12-n group_name: 新名字-g GID: 新的GID 组删除：groupdel groupdel GROUP 1.5.7 更改组密码1234567组密码：gpasswdgpasswd [OPTION] GROUP -a user 将user添加至指定组中 -d user 从指定组中移除用户user -A user1,user2,... 设置有管理权限的用户列表newgrp命令：临时切换主组 如果用户本不属于此组，则需要组密码 2 文件权限：2.1 文件的权限主要针对三类对进行定义 owner: 属主, u，文档所有者 group: 属组, g，文档所属组用户 other: 其他, o，其他用户 每个文件针对每类访问者都义了三种权限 r: Readable：读 w: Writable：写 x: eXcutable：执行 2.2 文件和目录权限的区别： 文件： r: 可使用文件查看类工具获取其内容 w: 可修改其内容 x: 可以把此文件提请内核启动为一个进程 目录： r: 可以使用ls查看此目录中文件列表 w: 可在此目录中创建文件，也可删除此目录中的文件 x: 可以使用ls -l查看此目录中文件列表，可以cd进入此目录 2.3 修改文件权限：12345678910chmod [OPTION]... OCTAL-MODE FILE... -R: 递归修改权限（改目录的时候想修改目录内部所有文件的权限，但是不建议）chmod [OPTION]... MODE[,MODE]... FILE... MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]... --reference=RFILE FILE... （referance）参考RFILE文件的权限，将FILE的修改为同RFILE 2.4 修改文件的属组和属主： 修改文件的属主：chown chown [OPTION]… [OWNER][:[GROUP]] FILE… 用法： OWNER OWNER:GROUP :GROUP 命令中的冒号可用.替换 -R: 递归 语法：-chown [OPTION]... --reference=RFILE FILE... 修改文件的属组：chgrp 123chgrp [OPTION]... GROUP FILE...chgrp [OPTION]... --reference=RFILE FILE...-R 递归 注意： - (权限一定要给全，不然会从左边补全，例如如果给77，则默认为077） - (目录一定要有执行权限，普通文件不能随便给执行权限（防止一些恶意文件留后门）)， - (只写+w,只有属主加写权限) 2.5 新建文件和目录的默认权限 umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask 如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定 umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~/.bashrc 2.6 访问控制列表 ACL：Access Control List，实现灵活的权限管理 除了文件的所有者，所属组和其它人，可以对更多的用户设置权限 CentOS7 默认创建的xfs和ext4文件系统具有ACL功能 CentOS7 之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加 tune2fs –o acl /dev/sdb1 mount –o acl /dev/sdb1 /mnt/test ACL生效顺序：所有者，自定义用户，自定义组，其他人 为多用户或者组的文件和目录赋予访问权限rwx mount -o acl /directory getfacl file |directory setfacl -m u:wang:rwx file|directory setfacl -Rm g:sales:rwX directory setfacl -M file.acl file|directory setfacl -m g:salesgroup:rw file| directory setfacl -m d:u:wang:rx directory setfacl -x u:wang file |directory setfacl -X file.acl directory123456789101112131415161718[root@localhost ~]# getfacl linux222.txt# file: linux222.txt# owner: root# group: root user::rw-group::r--other::r--[root@localhost ~]# setfacl -m u:vampire:wx linux222.txt[root@localhost ~]# getfacl linux222.txt# file: linux222.txt# owner: root# group: rootuser::rw-user:vampire:-wxgroup::r--mask::rwxother::r--","categories":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://luoqian67.github.io/blog/tags/Linux/"}]}]}